{{fbdoc item="title" value="File I/O with FreeBASIC"}}----

Sous FreeBASIC, il y a 4 fa&ccedil;ons possibles d'ex&eacute;cuter une Entr&eacute;e/Sortie fichier:

1. En utilisant les commandes BASIC int&eacute;gr&eacute;es comme ##[[KeyPgOpen Open]]## , ##[[KeyPgGetfileio Get]]##, ##[[KeyPgPutfileio Put]]## et ##[[KeyPgClose Close]]##. Cette voie est la plupart du temps portable sur toutes les plates-formes support&eacute;es par FreeBASIC. Les fichiers ouverts sont identifi&eacute;s par des "file numbers" (num&eacute;ros de fichier), qui sont sp&eacute;cifiques &agrave; FreeBASIC et ne peuvent &ecirc;tre transmis aux fonctions ci-dessous.

2. En utilisant les fonctions C d'E/S de flux comme fopen, fread, ftell, fclose (voir Flux E/S dans [[ProPgCruntime Fonctions biblioth&egrave;que C standard]]) de la biblioth&egrave;que C sur lesquelles FreeBASIC s'appuie. Ce qui est l&eacute;g&egrave;rement plus rapide et ajoute quelques fonctionnalit&eacute;s &agrave; la m&eacute;thode ci-dessus et reste bien portable. Les fichiers ouverts sont identifi&eacute;s par des pointeurs de fichiers, comme dans le langage C, ce qui est &agrave; nouveau propre &agrave; cette m&eacute;thode d'acc&egrave;s.  La fonction ##[[KeyPgFileattr FileAttr]]## peut &ecirc;tre utilis&eacute;e pour retourner un pointeur flux E/S &agrave; partir d'un num&eacute;ro de fichier comme dans le 1. ci-dessus.

3. En utilisant les fonctions E/S, de bas niveau,  du langage C comme _open, _read, _write, _close (voir E/S bas niveau dans [[ProPgCruntime Fonctions biblioth&egrave;que C standard]]). Ces fonctions doivent &ecirc;tre portables, mais jusqu'&agrave; pr&eacute;sent, les en-t&ecirc;tes ne sont disponibles que pour Win32 seulement, donc le code qu'elles utilisent ne sera pas compil&eacute; sur d'autres plates-formes, pour le moment.

4. En parlant directement au noyau OS (DOS: utilisez DOS et DPMI INT's , Win32: utilisez les appels API comme CreateFile, WriteFile). Ce n'est pas portable. Les fichiers sont identifi&eacute;s par des "handles" (identificateurs) g&eacute;n&eacute;r&eacute;s en propre par le noyau de l'OS.

Cet exemple montre et compare les m&eacute;thodes 1. et 2. d&eacute;crites ci-dessus et rapporte les valeurs retourn&eacute;es par les fonctions utilis&eacute;es. On attend 2 arguments de ligne de commande, fournissant les noms de 2 fichiers **diff&eacute;rents** de la m&ecirc;me taille ce qui permet de comparer le rendement en lecture (Assurez-vous que le cache des fichiers est vide avant de commencer le test) :

{{fbdoc item="ex"}}
{{fbdoc item="filename" value="examples/manual/fileio/basicvsc.bas"}}%%(freebasic)
DATA " File I/O example & test GET vs FREAD | (CL) 2008-10-12 Public Domain "
DATA " http://www.freebasic.net/wiki/wikka.php?wakka=ProPgFileIO "
REM
REM Compile with FB 0.20 or newer
REM
REM In the commandline supply preferably 2 different files of same big size
REM Default is "BLAH" for both (bad)
REM In both loops (GET and FREAD) the last read can be "empty" ... no problem

#include "crt\stdio.bi" '' Otherwise the "C"-stuff won't work

DIM AS FILE  PTR   QQ   '' This is the C-like file access pointer
DIM AS UBYTE PTR   BUF  '' Buffer used for both FB-like and C-like read
DIM AS UINTEGER    FILN '' FB-like "filenumber"

DIM AS UINTEGER    AA, BB, CC, DD, EE
DIM AS ULONGINT    II64 '' We do try to support files >= 4 GiB

DIM AS STRING      VGSTEMP, VGSFILE1, VGSFILE2

? : READ VGSTEMP : ? VGSTEMP : READ VGSTEMP : ? VGSTEMP : ?

VGSTEMP=COMMAND$(1) : VGSFILE1="BLAH"
IF (VGSTEMP<>"") THEN VGSFILE1=VGSTEMP
VGSTEMP=COMMAND$(2) : VGSFILE2=VGSFILE1
IF (VGSTEMP<>"") THEN VGSFILE2=VGSTEMP

BUF = ALLOCATE(32768) '' 32 KiB - hoping it won't fail, BUF could be 0 ...

? : ? "FB - OPEN - GET , """+VGSFILE1+"""": SLEEP 1000
FILN = FREEFILE : AA=0 : II64=0 '' AA counts blocks per 32 KiB already read
BB=OPEN (VGSFILE1 FOR BINARY ACCESS READ AS #FILN)
'' Result 0 is OK here, <>0 is evil
'' "ACCESS READ" should prevent file creation if it doesn't exist
? "OPEN result  : " ; BB
IF (BB=0) THEN '' BB will be "reused" for timer below
  BB=CAST(UINTEGER,(TIMER*100)) '' No UINTEGER TIMER in FB, make units 10 ms
  CC=GET (#FILN,,*BUF,32768,DD)
  '' CC has the success status, 0 is OK, <>0 is bad
  '' DD is the amount of data read
  '' EOF is __NOT__ considered as error here
  ? "0th GET      : ";CC;" ";DD
  ? "2 bytes read : ";BUF[0];" ";BUF[1]
  DO
	AA=AA+1 : II64=II64+CAST(ULONGINT,DD)
	IF (DD<32768) OR (CC<>0) THEN EXIT DO '' Give up
	CC=GET (#FILN,,*BUF,32768,DD)
  LOOP
  EE=CAST(UINTEGER,(TIMER*100))-BB
  ? "Time         : ";(EE+1)*10;" ms"
  IF (AA>1) THEN ? "Last GET     : ";CC;" ";DD
  ? "Got __EXACTLY__ ";II64;" bytes in ";AA;" calls"
  CLOSE #FILN
ENDIF

? : ? "C - FOPEN - FREAD , """+VGSFILE2+"""" : SLEEP 1000
AA=0 : II64=0 '' AA counts blocks per 32 KiB already read
QQ=FOPEN(VGSFILE2,"rb")
'' Here 0 is evil and <>0 good, opposite from above !!!
'' File will not be created if it doesn't exist (good)
'' "rb" is case sensitive and must be lowercase, STRPTR seems not necessary
? "FOPEN result : " ; QQ
IF (QQ<>0) THEN
  BB=CAST(UINTEGER,(TIMER*100)) '' No UINTEGER TIMER in FB, make units 10 ms
  DD=FREAD(BUF,1,32768,QQ) '' 1 is size of byte - can't live without :-D
  '' Returns size of data read, <32768 on EOF, 0 after EOF, or "-1" on error
  ? "0th FREAD    : ";DD
  ? "2 bytes read : ";BUF[0];" ";BUF[1]
  DO
	AA=AA+1
	IF (DD<=32768) THEN II64=II64+CAST(ULONGINT,DD)
	IF (DD<>32768) THEN EXIT DO '' ERR or EOF
	DD=FREAD(BUF,1,32768,QQ)
  LOOP
  EE=CAST(UINTEGER,(TIMER*100))-BB
  ? "Time         : ";(EE+1)*10;" ms"
  IF (AA>1) THEN ? "Last FREAD   : ";DD
  ? "Got __EXACTLY__ ";II64;" bytes in ";AA;" calls"
  FCLOSE(QQ)
ENDIF

DEALLOCATE(BUF): SLEEP 1000 '' Crucial

END
%%

{{fbdoc item="see"}}
	- [[CatPgFile Fonctions d'E/S fichiers]]
	- [[ProPgCruntime Fonctions de la biblioth&egrave;que C standard]]
	- [[KeyPgGetfileio Get (Commande E/S fichiers)]]

{{fbdoc item="back" value="CatPgProgrammer|Programmer's Guide"}}