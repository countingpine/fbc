{{fbdoc item="title" value="File I/O with FreeBASIC"}}----

Sous ""FreeBASIC"", il y a 4 façons possibles d'exécuter une Entrée/Sortie fichier:

1. En utilisant les commandes BASIC intégrées comme ##[[KeyPgOpen Open]]## , ##[[KeyPgGetfileio Get]]##, ##[[KeyPgPutfileio Put]]## et ##[[KeyPgClose Close]]##. Cette voie est la plupart du temps portable sur toutes les plates-formes supportées par ""FreeBASIC"". Les fichiers ouverts sont identifiés par des "file numbers" (numéros de fichier), qui sont spécifiques à ""FreeBASIC"" et ne peuvent être transmis aux fonctions ci-dessous.

2. En utilisant les fonctions C d'E/S de flux comme fopen, fread, ftell, fclose (voir Flux E/S dans [[ProPgCruntime Fonctions bibliothèque C standard]]) de la bibliothèque C sur lesquelles ""FreeBASIC"" s'appuie. Ce qui est légèrement plus rapide et ajoute quelques fonctionnalités à la méthode ci-dessus et reste bien portable. Les fichiers ouverts sont identifiés par des pointeurs de fichiers, comme dans le langage C, ce qui est à nouveau propre à cette méthode d'accès.  La fonction ##[[KeyPgFileattr FileAttr]]## peut être utilisée pour retourner un pointeur flux E/S à partir d'un numéro de fichier comme dans le 1. ci-dessus.

3. En utilisant les fonctions E/S, de bas niveau,  du langage C comme _open, _read, _write, _close (voir E/S bas niveau dans [[ProPgCruntime Fonctions bibliothèque C standard]]). Ces fonctions doivent être portables, mais jusqu'à présent, les en-têtes ne sont disponibles que pour ""Win32"" seulement, donc le code qu'elles utilisent ne sera pas compilé sur d'autres plates-formes, pour le moment.

4. En parlant directement au noyau OS (DOS: utilisez DOS et DPMI INT's , ""Win32"": utilisez les appels API comme ""CreateFile"", ""WriteFile""). Ce n'est pas portable. Les fichiers sont identifiés par des "handles" (identificateurs) générés en propre par le noyau de l'OS.

Cet exemple montre et compare les méthodes 1. et 2. décrites ci-dessus et rapporte les valeurs retournées par les fonctions utilisées. On attend 2 arguments de ligne de commande, fournissant les noms de 2 fichiers **différents** de la même taille ce qui permet de comparer le rendement en lecture (Assurez-vous que le cache des fichiers est vide avant de commencer le test) :

{{fbdoc item="ex"}}
{{fbdoc item="filename" value="examples/manual/fileio/basicvsc.bas"}}%%(freebasic)
DATA " File I/O example & test GET vs FREAD | (CL) 2008-10-12 Public Domain "
DATA " http://www.freebasic.net/wiki/wikka.php?wakka=ProPgFileIO "
REM
Rem Compile With FB 0.20 Or newer
REM
REM In the commandline supply preferably 2 different files of same big size
REM Default is "BLAH" for both (bad)
Rem In both loops (Get And FREAD) the last Read can be "empty" ... no problem

#include "crt\stdio.bi" '' Otherwise the "C"-stuff won't work

DIM AS FILE  PTR   QQ   '' This is the C-like file access pointer
Dim As UByte Ptr   BUF  '' Buffer used for both FB-like and C-like read
DIM AS UINTEGER    FILN '' FB-like "filenumber"

DIM AS UINTEGER    AA, BB, CC, DD, EE
DIM AS ULONGINT    II64 '' We do try to support files >= 4 GiB

DIM AS STRING      VGSTEMP, VGSFILE1, VGSFILE2

? : READ VGSTEMP : ? VGSTEMP : READ VGSTEMP : ? VGSTEMP : ?

VGSTEMP=COMMAND$(1) : VGSFILE1="BLAH"
IF (VGSTEMP<>"") THEN VGSFILE1=VGSTEMP
VGSTEMP=COMMAND$(2) : VGSFILE2=VGSFILE1
IF (VGSTEMP<>"") THEN VGSFILE2=VGSTEMP

BUF = ALLOCATE(32768) '' 32 KiB - hoping it won't fail, BUF could be 0 ...

? : ? "FB - OPEN - GET , """+VGSFILE1+"""": SLEEP 1000
FILN = FREEFILE : AA=0 : II64=0 '' AA counts blocks per 32 KiB already read
BB=OPEN (VGSFILE1 FOR BINARY ACCESS READ AS #FILN)
'' Result 0 is OK here, <>0 is evil
'' "ACCESS READ" should prevent file creation if it doesn't exist
? "OPEN result  : " ; BB
IF (BB=0) THEN '' BB will be "reused" for timer below
  BB=CAST(UINTEGER,(TIMER*100)) '' No UINTEGER TIMER in FB, make units 10 ms
  CC=GET (#FILN,,*BUF,32768,DD)
  '' CC has the success status, 0 is OK, <>0 is bad
  '' DD is the amount of data read
  '' EOF is __NOT__ considered as error here
  ? "0th GET      : ";CC;" ";DD
  ? "2 bytes read : ";BUF[0];" ";BUF[1]
  DO
	AA=AA+1 : II64=II64+CAST(ULONGINT,DD)
	IF (DD<32768) OR (CC<>0) THEN EXIT DO '' Give up
	CC=GET (#FILN,,*BUF,32768,DD)
  LOOP
  EE=CAST(UINTEGER,(TIMER*100))-BB
  ? "Time         : ";(EE+1)*10;" ms"
  IF (AA>1) THEN ? "Last GET     : ";CC;" ";DD
  ? "Got __EXACTLY__ ";II64;" bytes in ";AA;" calls"
  CLOSE #FILN
ENDIF

? : ? "C - FOPEN - FREAD , """+VGSFILE2+"""" : SLEEP 1000
AA=0 : II64=0 '' AA counts blocks per 32 KiB already read
QQ=FOPEN(VGSFILE2,"rb")
'' Here 0 is evil and <>0 good, opposite from above !!!
'' File will not be created if it doesn't exist (good)
'' "rb" is case sensitive and must be lowercase, STRPTR seems not necessary
? "FOPEN result : " ; QQ
IF (QQ<>0) THEN
  BB=CAST(UINTEGER,(TIMER*100)) '' No UINTEGER TIMER in FB, make units 10 ms
  DD=FREAD(BUF,1,32768,QQ) '' 1 is size of byte - can't live without :-D
  '' Returns size of data read, <32768 on EOF, 0 after EOF, or "-1" on error
  ? "0th FREAD    : ";DD
  ? "2 bytes read : ";BUF[0];" ";BUF[1]
  DO
	AA=AA+1
	IF (DD<=32768) THEN II64=II64+CAST(ULONGINT,DD)
	If (DD<>32768) Then Exit Do '' ERR or EOF
	DD=FREAD(BUF,1,32768,QQ)
  LOOP
  EE=CAST(UINTEGER,(TIMER*100))-BB
  ? "Time         : ";(EE+1)*10;" ms"
  IF (AA>1) THEN ? "Last FREAD   : ";DD
  ? "Got __EXACTLY__ ";II64;" bytes in ";AA;" calls"
  FCLOSE(QQ)
ENDIF

DEALLOCATE(BUF): SLEEP 1000 '' Crucial

END
%% 

{{fbdoc item="see"}}
	- [[CatPgFile Fonctions d'E/S fichiers]]
	- [[ProPgCruntime Fonctions de la bibliothèque C standard]]
	- [[KeyPgGetfileio Get (Commande E/S fichiers)]]

{{fbdoc item="back" value="CatPgProgrammer|Programmer's Guide"}}