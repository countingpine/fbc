{{fbdoc item="title" value="Internal graphics formats"}}----

**Formats des pixels**

	Quand un mode graphique est défini par les fonctions ##[[KeyPgScreengraphics Screen]]## ou ##[[KeyPgScreenres ScreenRes]]##, GfxLib crée également un tampon dans la mémoire système standard et définit un format de pixel interne approprié pour le mode. Il existe essentiellement trois formats internes de pixels, sélectionnés en fonction de la profondeur de l'écran, comme décrit dans le tableau suivant:

	{{table columns="4" cellpadding="1" cells="Profondeur d'écran;Octets internes par pixel;Masque binaire;Format pixel ;1bpp; 1; &h1;indice de couleur de la palette;2bpp; 1; &h3;palette color index;4bpp; 1; &hF;indice de couleur de la palette;8bpp; 1; &hFF;indice de couleur de la palette;15/16bpp; 2; &hFFFF;RRRRRGGGGGGBBBBB;24/32bpp; 4; &hFFFFFFFF;AAAAAAAARRRRRRRRGGGGGGGGBBBBBBBB"}}

	Toutes les opérations de dessin travaillent sur ce tampon vidéo RAM; lorsque l'affichage réel doit être mis à jour, ""GfxLib"" copie le contenu du tampon vidéo vers la mémoire d'affichage réelle, effectuant automatiquement dans le processus la conversion du format interne des pixels vers n'importe quel format pixel utilisé par l'affichage réel. En limitant les formats internes de pixel à 3, la bibliothèque vous évite d'avoir à faire face à une pléthore de formats d'affichage réel.

**Les valeurs de couleur**

	Lorsque vous appelez une primitive graphique qui accepte une couleur, ceci peut être indiqué de deux façons. Dans les modes 8 bits par pixel ou moins, la valeur de couleur doit être directement un indice de couleur 8 bits dans la palette courante et cela correspond au format interne de pixel pour ces modes. Dans les profondeurs de couleur plus élevées, la valeur de couleur devrait toujours avoir la forme ##&hAARRVVBB##; c'est ce que les macros ##[[KeyPgRgb RGB]]## et ##[[KeyPgRgba RGBA]]## retournent et qui est équivalent à la représentation du format interne de 24/32bpp (24/32 bits par pixel). Si la profondeur de couleur courante est de 24 ou 32bpp (bits par pixel), cela signifie que la valeur de la couleur passe non-modifiée. Si un mode 15/16bpp (15/16 bits par pixel) est en cours d'utilisation, en interne chaque primitive convertit automatiquement la couleur de la forme ##&hAARRVVBB## vers le format interne de pixel ##RRRRRVVVVVVBBBBB## (notez que dans ce processus le canal alpha est perdu, car les modes 15/16bpp (15/16 bits par pixel) ne le supportent pas). Une fois que la valeur de couleur est l'un des trois formats de pixel, la primitive limite sa plage à celle supportée par la profondeur de couleur courante, en utilisant une opération de bits ##[[KeyPgOpAnd And]]##  avec un masque de plage. Donc si nous sommes en 8bpp , la valeur de la couleur passée subit un ##[[KeyPgOpAnd And]]## ##&hFF## par exemple.

**Notes sur la transparence**

	Pour les modes 8bpp (8 bits par pixel) ou inférieurs, l'indice de couleur 0 est toujours considéré comme la couleur transparente pour les modes ##[[KeyPgPutgraphics Put]]## qui supportent la transparence. Pour des profondeurs supérieures, ##[[KeyPgRgb RGB]](255, 0, 255)## représente toujours la couleur transparente. Dans les modes 15/16bpp (15/16 bits par pixel), cela se traduit par la valeur interne ##&hF81F##, tandis que dans les modes 24/32bpp (24/32 bits par pixel) cela devient ##&hFFFF00FF##. Notez que dans les modes 24/32bpp (24/32 bits par pixel), ##[[KeyPgPutgraphics Put]]## identifie la couleur transparente simplement en regardant les composantes rouge, verte et bleue de la valeur de la couleur, tandis que la valeur alpha peut prendre n'importe quelle valeur. Cela signifie que dans les modes 24/32bpp (24/32 bits par pixel), par exemple, ##&h00FF00FF##, ##&h10FF00FF##, ##&hABFF00FF## et ##&hFFFF00FF## tous représentent la couleur transparente, puisque les 24 bits inférieurs sont toujours ##&hFF00FF##.

**Formats tampon**

	Dans ""FreeBASIC"", les images peuvent être utilisées comme des tableaux (comme dans QB) ou comme des pointeurs. Quoi qu'il en soit, les données image sont contenues dans un seul segment continu. Le bloc est constitué d'un en-tête suivi par les données image. L'en-tête peut être de deux types (ancien et nouveau style) et détermine le format des données image qui suivent.

		Un en-tête de bloc **ancien style** est constitué de 4 octets (32 bits, ou 4 octets). Les 3 premiers bits contiennent la profondeur de la couleur image en octets par pixel (profondeur de couleur de 8 bits -> 1; profondeur de couleur de 16 bits -> 2; profondeur de couleur de 32 bits -> 4). Les 13 bits suivants contiennent la largeur de l'image. Les 16 derniers bits contiennent la hauteur de l'image. S'il vous plaît, notez que le caractère intrinsèque de l'en-tête permet seulement des tailles allant jusqu'à ##8191 * 65535## pixels. Les données pixel réelles suivent l'en-tête, et sont compactées une rangée de pixels après l'autre; aucun alignement des données n'est prévu. La taille finale du bloc peut alors être calculée en utilisant la formule:

			##taille = 4 + (largeur * hauteur * octets_par_pixel )##

		Un en-tête de bloc **nouveau style** est constitué de 32 octets. Le premier "dword" = double- word = 4 octets (32 bits) doit être égal à la valeur 7, permettant à  ""GfxLib"" d'identifier un nouveau type de bloc. Le second "dword" contien la profondeur de couleur de l'image, en octets par pixel. Les troisième et le quatrième "dword" contiennent respectivement la largeur et la hauteur de l'image, ce qui élimine effectivement la limite de taille de l'image imposée par l'**ancien style** de bloc. Le cinquième "dword" contient le nombre de pixels par ligne ("pitch"), en octets; cela indique combien d'octets prend une rangée de pixels dans l'image. Le "pitch" (nombre de pixels par ligne, en octets) dans le **nouveau style** de bloc est toujours complété pour en faire un multiple de 16, pour permettre aux données de la ligne de pixels d' être alignées sur la limite du paragraphe. Les 3 autres "dword" (total 12 octets) de l'en-tête sont actuellement inutilisés et réservés pour une utilisation future. La taille finale de l'image est:

			##taille = 32 + ( ( ( ( largeur * octets_par_pixel ) + &hF ) and not &hF ) * hauteur )##

	Le format des images créées par ##[[KeyPgImagecreate ImageCreate]]## et ##[[KeyPgGetgraphics Get]]## dépend du dialecte utilisé. Dans le dialecte //[[CompilerOptlang -lang fb]]//, les images seront créées avec l'en-tête nouveau style.  Dans les dialectes //[[CompilerOptlang -lang fblite]]// et //[[CompilerOptlang -lang qb]]//, l'en-tête image de style ancien sera créée.

	Toutes les primitives graphiques peuvent travailler aussi bien avec des blocs image de style ancien que de style nouveau.  Pour accéder facilement aux informations image, ##[[KeyPgImageInfo ImageInfo]]## peut être utilisé pour obtenir des propriétés utiles d'un tampon image - telles que ses dimensions, sa profondeur de couleur, le "pitch" t un pointeur vers les données pixel - quel que soit le format utilisé.
	Il est également possible d'accéder directement à l'en-tête de l'image pour obtenir ces informations.  Pour plus d'informations sur comment accéder à la structure de l'en-tête, voyez [[FaqPggetputstructure cet exemple]].

{{fbdoc item="see"}}
	- ##[[KeyPgScreengraphics Screen (Graphique)]]##
	- ##[[KeyPgScreenres ScreenRes]]##
	- ##[[KeyPgGetgraphics Get (Graphique)]]##
	- ##[[KeyPgPutgraphics Put (Graphique)]]##
	- ##[[KeyPgImagecreate ImageCreate]]##
	- ##[[KeyPgImageInfo ImageInfo]]##
	- ##[[KeyPgTransGfx Trans]]##
	- ##[[KeyPgAlphaGfx Alpha]]##

{{fbdoc item="back" value="CatPgProgrammer|Programmer's Guide"}}
