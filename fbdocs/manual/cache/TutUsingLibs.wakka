{{fbdoc item="title" value="Utilisation de biblioth&egrave;ques"}}----
Ceci est un extrait d'un article publié dans QBXL Magazine, avec la permission de SJ Zero, l'auteur.


La plus grande force FreeBASIC est sa capacité à intégrer de façon transparente un certain nombre de bibliothèques C standard, tout en conservant la facilité d'utilisation comme QB. Même avant que FB n'ait une bibliothèque graphique intégrée, des codeurs intrépides utilisaient SDL pour avoir des routines graphiques et son fonctionnelles. Avant la version actuelle incluant SDL_net et Winsock, n certain nombre de codeurs, moi y compris, se sont battus avec les en-têtes pour obtenir le support réseau dans FreeBASIC. Aujourd'hui, je vais juste couvrir la façon de commencer avec trois bibliothèques avancées: SDL, fmod et tinyPTC. Après avoir compris les principes fondamentaux, vous verrez que l'utilisation de bibliothèques C est assez simple à quelques exceptions près, les bibliothèques C ne sont pas plus difficiles à utiliser en FreeBASIC que le sont les bibliothèques QB.



== Quelles sont ces bibliothèques, en tout cas? ==

Ces bibliothèques sont particulièrement utiles parce qu'ils ont tendance à fournir des fonctions de jeux. 

SDL est une bibliothèque avec le support intégré des entrées et des graphismes et tout un tas de sous-bibliothèques pour [[http://www.libsdl.org/projects/SDL_net/ le réseau]], [[http://www.libsdl.org/projects/SDL_ttf/ le support des polices TrueType]] et [[http://www.libsdl.org/projects/SDL_mixer/ l'audio]]. Il peut être utilisé avec OpenGL, mais je ne couvrira pas cela aujourd'hui.

TinyPTC est avant tout une bibliothèque graphique, la plus simple disponible. Il ne fait guère plus que de vous donner un pointeur vers la région où on dessine.

FMod est une bibliothèque musicale et de son 3D. Quoique sa licence soit bizarre, elle fonctionne de façon acceptable pour lire des sons et elle encapsule bien le son 3D.

== Inclure la bibliothèque ==

La première étape pour obtenir qu'une de ces bibliothèques fonctionne est d'inclure leurs fichiers en-tête dans votre projet.
Pour SDL, c'est tout simplement:
%%
 '$INCLUDE: "SDL\SDL.bi"
%%
Pour FMOD, c'est 
%%
 '$Include: 'fmod.bi'
%%
et pour TinyPTC, vous aurez
%%
 '$INCLUDE: 'tinyptc.bi'
%%
'''2. Initialisation de la bibliothèque, chargement d'un fichier'''

De toute évidence, vous ne pouvez pas inclure la lib et démarrer pour faire des trucs de première. 
Pour initilize SDL et charger un bitmap dans mémoire, vous devez:
%%
CONST SCR_WIDTH = 640
CONST SCR_HEIGHT = 480
DIM MenuScreen AS SDL_Surface ptr 'notre bitmap
DIM Shared video AS SDL_Surface ptr 'notre surface écran

SDL_Init ( SDL_INIT_VIDEO )
video = SDL_SetVideoMode( SCR_WIDTH, SCR_HEIGHT, 32, 0 ) 'mode video 640x480x32
MenuScreen = SDL_LoadBMP("bitmap.bmp")
%%
Pour initialiser FMOD et charger un son dans la mémoire, vous devez taper: 
%%
DIM sound AS INTEGER 'c'est juste une poignée (handle), c'est donc un int!

IF FSOUND_GetVersion <= FMOD_VERSION THEN
ErrorQuit "FMOD version " + STR$(FMOD_VERSION) + " ou supérieure requise"
End If

If FSOUND_Init(44100, 32, 0) = FALSE Then
ErrorQuit "Ne peut pas initialiser FMOD"
End If

sound = FSOUND_Sample_Load(FSOUND_FREE,"sound.wav", FSOUND_HW3D, 0, 0)
%%
Enfin, il n'y a pas de formats de données à charger avec TinyPTC parce qu'il est tellement simple, mais vous l'initialiser en allant:
%%
const SCR_WIDTH = 320
const SCR_HEIGHT = 200
const SCR_SIZE = SCR_WIDTH*SCR_HEIGHT

if( ptc_open( "tinyPTC test", SCR_WIDTH, SCR_HEIGHT ) = 0 ) then
end -1
end if
%%
== Blitting, Playing, or Plotting ==

L'étape la plus importante, évidemment, est d'obtenir ce que vous voulez à l'écran ou les enceintes. Cette partie est relativement facile, et peut être encapsulée dans une autre fonction enveloppe. Pour SDL, l'envoi d'une image à l'écran, c'est aller:

%%
SUB BlitImage(x as integer,y as integer,image as sdl_surface ptr, dest as sdl_surface ptr) 
DIM Rectangle as SDL_Rect 
DIM Rectangle2 as SDL_Rect 


Rectangle.X = 0 
Rectangle.Y = 0 
rectangle.w = image->w 
rectangle.h = image->h 
Rectangle2.x = x 
Rectangle2.y = y 

SDL_BlitSurface image, @rectangle, dest, @rectangle2

END SUB%%

Pour FMOD, la étapes pour jouer un son ne sont pas si difficiles que cela soit:
%%
FUNCTION fModPlayWave( samp1 as integer ) AS INTEGER 
'où samp1 est le nombre retourné par FSOUND_SampleLoad

DIM position(0 to 2)' as FSound_Vector
DIM vel(0 to 2)' FSound_Vector


fModPlayWave = FSOUND_PlaySoundEx(FSOUND_FREE, samp1, NULL, TRUE)

END FUNCTION
%%
Et TinyPTC, à nouveau, n'est pas une bibliothèque de haut niveau comme les deux autres, peut tracer des pixels en utilisant la code suivant:
%%
SUB putd(BYREF buffer(), BYVAL x AS INTEGER, BYVAL y AS INTEGER, BYVAL colr as INTEGER)
	    buffer((y * SCR_WIDTH) + x) = colr
		ptc_update @buffer(0) 'Ceci est un pageFlip
END SUB
%%


== Arrêter ==
Donc, vous n'avez pas à gérer la mémoire et faire toutes les tâches ennuyeuses et banales, vous devez vous rappeler de fermer la bibliothèque avant que votre programme se termine. Heureusement, les trois programmes permettent cela avec une seule ligne. Si vous ne pouvez pas l'arrêter, la bibliothèque ne se soucie pas. C'est beau.

%%
SDL: SDL_Quit ()
%%
%%
fmod: FSOUND_Close ()
%%
%%
tinyPTC: PTC_Close ()
%%
Il n'y a plus qu'à se quitter!
Comme vous pouvez le voir, ce n'est pas fondamentalement plus difficile d'utiliser des bibliothèques en FreeBASIC qu'en QuickBASIC. En fait, parce que les codeurs n'ont pas besoin de faire des pirouettes pour atteindre la mémoire, c'est en fait beaucoup plus facile, même avec le plus moderne OS et matériel.

