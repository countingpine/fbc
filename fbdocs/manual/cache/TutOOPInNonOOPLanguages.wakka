{{fbdoc item="title" value="OOP dans les langages Non-OOP"}}----

Contrairement à la croyance populaire, la programmation orientée objet ne nécessite pas un langage orienté objet.

Ce que vous obtenez avec un langage OO est un ensemble de constructions qui vous aident à écrire des programmes OO, mais dans de nombreux cas ils sont inutiles et parfois elles sont contreproductives.

Quoi qu'il en soit, ce n'est pas une diatribe contre les langages OO, mais plutôt une diatribe contre l'acceptation aveugle de l'idée qu'un langage spécifiquement OO est nécessaire pour écrire des programmes orientés objets.

Afin de démontrer qu'il n'est pas nécessaire d'avoir un langage OO cet exemple présente une technique qui est généralement présentée comme un exemple de programmation basée classe; et c'est ainsi, mais vous ne trouverez pas le mot "class" dans cet exemple.

Le code a été testé en utilisant FB 0.16 pour win32.

Si vous avez à concaténer un grand nombre de chaînes dans la plupart des BASICs, vous trouverez généralement que c'est un processus coûteux en temps. En fait, les opérations de chaîne FreeBASIC sont remarquablement rapides, mais vous pouvez faire encore mieux en utilisant un constructeur de chaînes.

Un constructeur chaîne est tout simplement une classe qui gère un tampon de chaîne de telle manière à éviter les appels répétés à la fonction d'allocation mémoire, car cela est une opération relativement coûteuse en temps. Les méthodes de la classe fournissent des moyens de manipulation le tampon et de conversion entre elle et le type de chaîne d'origine.

Le truc qui le rend plus rapide que le type construit pour les grandes chaînes et les grands nombres d'ajouts est que la chaîne est stockée dans un tamponémoire alloué qui est toujours plus grand que la longueur réelle de la chaîne. Cela signifie que l'ajout à la fin de la chaîne signifie en général de simplement copier le contenu de la nouvelle chaîne à l'emplacement de la mémoire après le dernier caractère de la chaîne actuelle. Dans cette implémentation, le tampon est une ZString ainsi il est donc facile de la convertir en une chaîne ordinaire dynamique.

Le module FreeBASIC encapsule une définition de type pour une structure. Les instances de cette structure organisent les attributs de l'objet. Les méthodes sont tout simplement les fonctions publiques normales du FreeBASIC et les sous-programmes définis dans le même module. Lorsque vous voulez appeler une méthode vous utilisez la syntaxe normale FreeBASIC:
%%(freebasic) s = StringB_ToString(AStringBInstance)%%

Par convention tous les noms de méthodes commencent par le nom de la classe et un trait de soulignement et le premier argument est toujours l'instance du type. Cet argument doit toujours être passé par référence pour assurer des changements d'état permanents et aussi pour éviter d'inutiles perte temps de copie.

Pour ajouter une nouvelle méthode il vous suffit d'ajouter une nouvelle fonction ou un sous-programme suivant ces règles.

Vous pouvez facilement mettre en oeuvre la composition des objets, mais l'héritage ne peut être obtenu de manière habituelle. Vous pouvez étendre les classes simplement en définissant de nouvelles fonctions qui prennent d'ailleurs des arguments de type de classe. Si la classe originale définit l'ensemble de ses méthodes comme surchargées, vous pouvez même créer de nouvelles méthodes de même nom tant qu'elles ont des signatures différentes.


Voici un exemple de code:
%%(freebasic)
'-----------------------------------------------------------------------------
' Classes without built in oop.

' Define a struct for the properties and a sub or function for each
' method.  Pass the struct as the first argument in all calls.

' By convention the argument will be Me as in VB Classic

' Strings in FB are so fast that a string builder class is 
' not needed most of the time but if you are concatenating 
' thousands of strings to build web pages for instance this might be useful.

' And please don't start complaining about the lack of inheritance; that
' is not a requirement for the use of objects.  There is no legal definition of 
' Object Oriented Programming but the most important part of any definition 
' is the close association between the data and the code that manipulates it.

'You can easily extend this class to provide more methods.
'-----------------------------------------------------------------------------


type StringB
  len as integer ' used length
  allocated as integer
  s as zstring ptr   ' buffer of at least len characters
end type


'-----------------------------------------------------------------------------
' Create a new StringB by calling one of these constructors.
'-----------------------------------------------------------------------------
public function StringB_New overload (byval InitialSize as integer) as StringB
  dim sb as StringB
  sb.allocated = InitialSize
  sb.s = allocate(InitialSize)
  *sb.s = ""
  StringB_New = sb
end function


public function StringB_New(byref InitialValue as string) as StringB
  dim sb as StringB
  sb = StringB_New(len(InitialValue))
  *sb.s = InitialValue
  sb.len = len(InitialValue)
  StringB_New = sb
end function

public sub StringB_Dispose(byref Me as StringB)
  deallocate Me.s
end sub

  
public function StringB_ToString(byref Me as StringB) as string 
  StringB_ToString = *Me.s
end function


sub StringB_Append overload(byref Me as StringB, byref s as string)

  dim i as integer = Me.len
  Me.len += len(s)
  if Me.len >= Me.allocated then
	Me.allocated = 2*Me.len
	dim as zstring ptr p = reallocate(Me.s, Me.allocated )
	if p=0 then
	  ' failed to reallocate
	  print "StringB_Append failed to reallocate", Me.allocated
	  return 
	end if
	Me.s = p
  end if
  *(Me.s + i) = s
  
end sub


sub StringB_Append(byref Me as StringB, byref other as StringB)
  StringB_Append Me, StringB_ToString(other)
end sub
%%

