{{fbdoc item="title" value="OOP In Non-OOP Languages"}}----

Contrairement &agrave; la croyance populaire, la programmation orient&eacute;e objet ne n&eacute;cessite pas un langage orient&eacute; objet.

Ce que vous obtenez avec un langage OO est un ensemble de constructions qui vous aident &agrave; &eacute;crire des programmes OO, mais dans de nombreux cas ils sont inutiles et parfois elles sont contreproductives.

Quoi qu'il en soit, ce n'est pas une diatribe contre les langages OO, mais plut&ocirc;t une diatribe contre l'acceptation aveugle de l'id&eacute;e qu'un langage sp&eacute;cifiquement OO est n&eacute;cessaire pour &eacute;crire des programmes orient&eacute;s objets.

Afin de d&eacute;montrer qu'il n'est pas n&eacute;cessaire d'avoir un langage OO cet exemple pr&eacute;sente une technique qui est g&eacute;n&eacute;ralement pr&eacute;sent&eacute;e comme un exemple de programmation bas&eacute;e classe; et c'est ainsi, mais vous ne trouverez pas le mot "class" dans cet exemple.

Le code a &eacute;t&eacute; test&eacute; en utilisant FB 0.16 pour win32.

Si vous avez &agrave; concat&eacute;ner un grand nombre de cha&icirc;nes dans la plupart des BASICs, vous trouverez g&eacute;n&eacute;ralement que c'est un processus co&ucirc;teux en temps. En fait, les op&eacute;rations de cha&icirc;ne FreeBASIC sont remarquablement rapides, mais vous pouvez faire encore mieux en utilisant un constructeur de cha&icirc;nes.

Un constructeur cha&icirc;ne est tout simplement une classe qui g&egrave;re un tampon de cha&icirc;ne de telle mani&egrave;re &agrave; &eacute;viter les appels r&eacute;p&eacute;t&eacute;s &agrave; la fonction d'allocation m&eacute;moire, car cela est une op&eacute;ration relativement co&ucirc;teuse en temps. Les m&eacute;thodes de la classe fournissent des moyens de manipulation le tampon et de conversion entre elle et le type de cha&icirc;ne d'origine.

Le truc qui le rend plus rapide que le type construit pour les grandes cha&icirc;nes et les grands nombres d'ajouts est que la cha&icirc;ne est stock&eacute;e dans un tampon&eacute;moire allou&eacute; qui est toujours plus grand que la longueur r&eacute;elle de la cha&icirc;ne. Cela signifie que l'ajout &agrave; la fin de la cha&icirc;ne signifie en g&eacute;n&eacute;ral de simplement copier le contenu de la nouvelle cha&icirc;ne &agrave; l'emplacement de la m&eacute;moire apr&egrave;s le dernier caract&egrave;re de la cha&icirc;ne actuelle. Dans cette impl&eacute;mentation, le tampon est une ZString ainsi il est donc facile de la convertir en une cha&icirc;ne ordinaire dynamique.

Le module FreeBASIC encapsule une d&eacute;finition de type pour une structure. Les instances de cette structure organisent les attributs de l'objet. Les m&eacute;thodes sont tout simplement les fonctions publiques normales du FreeBASIC et les sous-programmes d&eacute;finis dans le m&ecirc;me module. Lorsque vous voulez appeler une m&eacute;thode vous utilisez la syntaxe normale FreeBASIC:
%%(freebasic) s = StringB_ToString(AStringBInstance)%%

s = StringB_ToString(AStringBInstance)%%

Par convention tous les noms de m&eacute;thodes commencent par le nom de la classe et un trait de soulignement et le premier argument est toujours l'instance du type. Cet argument doit toujours &ecirc;tre pass&eacute; par r&eacute;f&eacute;rence pour assurer des changements d'&eacute;tat permanents et aussi pour &eacute;viter d'inutiles perte temps de copie.

Pour ajouter une nouvelle m&eacute;thode il vous suffit d'ajouter une nouvelle fonction ou un sous-programme suivant ces r&egrave;gles.


Vous pouvez facilement mettre en oeuvre la composition des objets, mais l'h&eacute;ritage ne peut &ecirc;tre obtenu de mani&egrave;re habituelle. Vous pouvez &eacute;tendre les classes simplement en d&eacute;finissant de nouvelles fonctions qui prennent d'ailleurs des arguments de type de classe. Si la classe originale d&eacute;finit l'ensemble de ses m&eacute;thodes comme surcharg&eacute;es, vous pouvez m&ecirc;me cr&eacute;er de nouvelles m&eacute;thodes de m&ecirc;me nom tant qu'elles ont des signatures diff&eacute;rentes.
Voici un exemple de code:
'-----------------------------------------------------------------------------
'-----------------------------------------------------------------------------

' Classes without built in oop.
' Define a struct for the properties and a sub or function for each

' method.  Pass the struct as the first argument in all calls.

' By convention the argument will be Me as in VB Classic
' Strings in FB are so fast that a string builder class is 
' not needed most of the time but if you are concatenating 

' thousands of strings to build web pages for instance this might be useful.
' And please don't start complaining about the lack of inheritance; that
' is not a requirement for the use of objects.  There is no legal definition of 
' Object Oriented Programming but the most important part of any definition 

' is the close association between the data and the code that manipulates it.
'You can easily extend this class to provide more methods.


'-----------------------------------------------------------------------------
  Type StringB
  Len As Integer ' used length
  allocated As Integer
s As ZString Ptr   ' buffer of at least len characters


End Type
'-----------------------------------------------------------------------------
' Create a new StringB by calling one of these constructors.
'-----------------------------------------------------------------------------
  Public Function StringB_New Overload (ByVal InitialSize As Integer) As StringB
  Dim sb As StringB
  sb.allocated = InitialSize
  sb.s = Allocate(InitialSize)
  *sb.s = ""
StringB_New = sb


End Function
  Public Function StringB_New(ByRef InitialValue As String) As StringB
  Dim sb As StringB
  sb = StringB_New(Len(InitialValue))
  *sb.s = InitialValue
  sb.len = Len(InitialValue)
StringB_New = sb

End Function
  Public Sub StringB_Dispose(ByRef Me As StringB)
Deallocate Me.s

  
End Sub
  Public Function StringB_ToString(ByRef Me As StringB) As String 
StringB_ToString = *Me.s


End Function

  Sub StringB_Append Overload(ByRef Me As StringB, ByRef s As String)
  Dim i As Integer = Me.len
  Me.len += Len(s)
	If Me.len >= Me.allocated Then
	Me.allocated = 2*Me.len
	Dim As ZString Ptr p = Reallocate(Me.s, Me.allocated )
	  If p=0 Then
	  ' failed to reallocate
	  Print "StringB_Append failed to reallocate", Me.allocated
	Return 
	End If
  Me.s = p
  End If
  
*(Me.s + i) = s


End Sub
  Sub StringB_Append(ByRef Me As StringB, ByRef other As StringB)
StringB_Append Me, StringB_ToString(other)
End Sub