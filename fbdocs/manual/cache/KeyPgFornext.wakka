{{fbdoc item="title" value="FOR...NEXT"}}----
D&eacute;claration de contr&ocirc;le de flux pour boucler

{{fbdoc item="syntax"}}##
	**For** //iterator// [ [[KeyPgAs as]] [[DataType datatype]] ] = //startvalue// **To** //endvalue// [ **Step** //stepvalue// ]
		[ //statement block// ]
	**Next** [ //iterator// ]
##
{{fbdoc item="param"}}
	##//iterator//##
		Une variable qui est utilis&eacute;e pour effectuer une it&eacute;ration d'une valeur initiale &agrave; une valeur finale
	##//datatype//##
		Si sp&eacute;cifi&eacute;e, la variable ##//iterator//## sera automatiquement d&eacute;clar&eacute;e avec le type ##//datatype//##.
	##//startvalue//##
		Une expression qui d&eacute;signe la valeur de d&eacute;part de l'it&eacute;rateur
	##//endvalue//##
		Une expression utilis&eacute;e pour comparer avec la valeur de l'it&eacute;rateur
	##//stepvalue//##
		Une expression qui est ajout&eacute;e &agrave; l'it&eacute;rateur apr&egrave;s chaque it&eacute;ration

{{fbdoc item="desc"}}
	Une boucle ##**For...Next**## initialise l'##//iterator//## avec ##//startvalue//##, puis &eacute;x&eacute;cute le ##//statement block = bloc d'instructions//##, incr&eacute;mente ##//iterator//## de ##//stepvalue//## jusqu'&agrave; ce qu'il atteigne ##//endvalue//##. Si ##//stepvalue//## n'est pas pr&eacute;cis&eacute; explicitement il sera fix&eacute; &agrave; 1.

	Les valeurs de ##//stepvalue//## et ##//endvalue//## sont stock&eacute;es en interne imm&eacute;diatement apr&egrave;s l'ex&eacute;cution de l'instruction ##**For**## et donc aucune ne peut &ecirc;tre chang&eacute;e &agrave; l'int&eacute;rieur de la boucle ##**For**##. (les variables qui les d&eacute;finissent peuvent &ecirc;tre chang&eacute;es, mais en changeant ces variables &agrave; l'int&eacute;rieur de la boucle ##**For**## n'affectera pas son ex&eacute;cution. (Voir les exemples)
	
	L' ##//iterator//## peut &ecirc;tre d&eacute;fini en ayant la m&ecirc;me port&eacute;e que la d&eacute;claration ##**For**## en utilisant la syntaxe de ##[[KeyPgAs As]] [[DataType datatype]]##. Avec cette syntaxe, //iterator// est cr&eacute;&eacute; et d&eacute;truit dans la port&eacute;e de ##**For...Next**##. Voir diff&eacute;rences de dialecte ci-dessous.

	Si ##//endvalue//## est inf&eacute;rieure &agrave; ##//startvalue//## alors une ##//stepvalue//## n&eacute;gative doit &ecirc;tre pr&eacute;cis&eacute;e ou le ##//statement block//## ne s'ex&eacute;cutera pas du tout, puisque ##//startvalue//## est d&eacute;j&agrave; sup&eacute;rieure &agrave; ##//endvalue//##.

	La d&eacute;claration ##**For**## provoque l'ex&eacute;cution des instructions du ##//statement block//## tant qu'est effectu&eacute;e la comparaison ##//iterator//## **plus grand que** ##//endvalue//## (ou **plus petit que** ##//endvalue//## si ##//stepvalue// < 0##). ##//iterator//## sera increment&eacute; de la valeur de ##//stepvalue//## apr&egrave;s chaque ex&eacute;cution du ##//statement block//##. Si Aucun incr&eacute;ment n'est donn&eacute;, ##//iterator//## sera implicitement increment&eacute; de ##1##.

	Si un ##[[KeyPgExit Exit]]## ##**For**## est rencontr&eacute; dans le ##//statement block//##, la boucle se termine et l'ex&eacute;cution reprend imm&eacute;diatement apr&egrave;s la d&eacute;claration suivant ##**Next**##. Si ##[[KeyPgContinue Continue]]## ##**For**## est rencontr&eacute;, le reste du ##//statement block//## est saut&eacute; et l'ex&eacute;cution reprend &agrave; la d&eacute;claration FOR.

	Comme toutes les d&eacute;clarations de contr&ocirc;le de flux, ##**For**## peut &ecirc;tre imbriqu&eacute;, ce qui signifie qu'il peut &ecirc;tre utilis&eacute; dans un bloc d'instructions d'une autre d&eacute;claration ##**For**##.

	**Note**: Quand ##//stepvalue//## est n&eacute;gatif, ##**For**## boucle tant qu'est effectu&eacute;e la comparaison ##//iterator//## //plus petit que// ##//end_value//##.

	##//For//##, ##//Next//## et ##//Step//## sont des op&eacute;rateurs qui peuvent &ecirc;tre surcharg&eacute;s dans des types d&eacute;finis par l'utilisateur. Voir [[KeyPgOpFor Op&eacute;rateur For]], [[KeyPgOpNext Op&eacute;rateur Next]], [[KeyPgOpStep Op&eacute;rateur]]

{{fbdoc item="ex"}}
{{fbdoc item="filename" value="examples/manual/control/for-next.bas"}}%%(freebasic)
Dim i As Single
Print "counting from 3 to 0, with a step of -0.5"
dim i as single
for i = 3 to 0 step -0.5
	print "i is " & i
next i%%
{{fbdoc item="filename" value="examples/manual/control/for-next2.bas"}}%%(freebasic)
dim as integer i, j, k, toTemp, stepTemp
j = 9: k = 1

for i = 0 to j step k
	
	j = 0: k = 0 '' Changing j and k has no effect on the current loop.
	print i;
	
next i
print

' Internally, this is what the above example does:
j = 9: k = 1

i = 0: toTemp = j: stepTemp = k
do while iif(stepTemp >= 0, i <= toTemp, i >= toTemp)
	
	j = 0: k = 0 '' Changing j and k has no effect on the current loop.
	print i;
	
	i += stepTemp
loop
print%%

{{fbdoc item="lang"}}
	- Dans les dialectes //[[CompilerOptlang -lang qb]]// et //[[CompilerOptlang -lang fblite]]//, les variables d&eacute;clar&eacute;es dans une boucle FOR..NEXT ont une [[ProPgVariableScope port&eacute;e]] &agrave; l'&eacute;chelle de la fonction comme dans QB.
	- Dans les dialectes //[[CompilerOptlang -lang fb]]// et //[[CompilerOptlang -lang deprecated]]// les variables d&eacute;clar&eacute;es dans une boucle ##**For**##..##**Next**## ne sont visibles que dans le bloc et ne peuvent &ecirc;tre utilis&eacute;es en-dehors de lui.

{{fbdoc item="diff"}}
	- Les arguments ##[[KeyPgByref ByRef]]## ne peuvent &ecirc;tre utilis&eacute;s comme compteurs.

{{fbdoc item="see"}}
	- ##[[KeyPgContinue Continue]]##
	- ##[[KeyPgDoloop Do...Loop]]##
	- ##[[KeyPgExit Exit]]##

{{fbdoc item="back" value="CatPgControlFlow|Control Flow"}}