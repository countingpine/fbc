{{fbdoc item="title" value="FOR...NEXT"}}----
Déclaration de contrôle de flux pour boucler

{{fbdoc item="syntax"}}##
	**For** //iterator// [ [[KeyPgAs as]] [[DataType datatype]] ] = //startvalue// **To** //endvalue// [ **Step** //stepvalue// ]
		[ //statement block// ]
	**Next** [ //iterator// ]
##
{{fbdoc item="param"}}
	##//iterator//##
		Une variable qui est utilisée pour effectuer une itération d'une valeur initiale à une valeur finale
	##//datatype//##
		Si spécifiée, la variable ##//iterator//## sera automatiquement déclarée avec le type ##//datatype//##.
	##//startvalue//##
		Une expression qui désigne la valeur de départ de l'itérateur
	##//endvalue//##
		Une expression utilisée pour comparer avec la valeur de l'itérateur
	##//stepvalue//##
		Une expression qui est ajoutée à l'itérateur après chaque itération

{{fbdoc item="desc"}}
	Une boucle ##**For...Next**## initialise l'##//iterator//## avec ##//startvalue//##, puis éxécute le ##//statement block = bloc d'instructions//##, incrémente ##//iterator//## de ##//stepvalue//## jusqu'à ce qu'il atteigne ##//endvalue//##. Si ##//stepvalue//## n'est pas précisé explicitement il sera fixé à 1.

	Les valeurs de ##//stepvalue//## et ##//endvalue//## sont stockées en interne immédiatement après l'exécution de l'instruction ##**For**## et donc aucune ne peut être changée à l'intérieur de la boucle ##**For**##. (les variables qui les définissent peuvent être changées, mais en changeant ces variables à l'intérieur de la boucle ##**For**## n'affectera pas son exécution. (Voir les exemples)
	
	L' ##//iterator//## peut être défini en ayant la même portée que la déclaration ##**For**## en utilisant la syntaxe de ##[[KeyPgAs as]] [[DataType datatype]]##. Avec cette syntaxe, //iterator// est créé et détruit dans la portée de ##**For...Next**##. Voir différences de dialecte ci-dessous.

	Si ##//endvalue//## est inférieure à ##//startvalue//## alors une ##//stepvalue//## négative doit être précisée ou le ##//statement block//## ne s'exécutera pas du tout, puisque ##//startvalue//## est déjà supérieure à ##//endvalue//##.

	La déclaration ##**For**## provoque l'exécution des instructions du ##//statement block//## tant qu'est effectuée la comparaison ##//iterator//## **plus grand que** ##//endvalue//## (ou **plus petit que** ##//endvalue//## si ##//stepvalue// < 0##). ##//iterator//## sera incrementé de la valeur de ##//stepvalue//## après chaque exécution du ##//statement block//##. Si Aucun incrément n'est donné, ##//iterator//## sera implicitement incrementé de ##1##.

	Si un ##[[KeyPgExit Exit]]## ##**For**## est rencontré dans le ##//statement block//##, la boucle se termine et l'exécution reprend immédiatement après la déclaration suivant ##**Next**##. Si ##[[KeyPgContinue Continue]]## ##**For**## est rencontré, le reste du ##//statement block//## est sauté et l'exécution reprend à la déclaration FOR.

	Comme toutes les déclarations de contrôle de flux, ##**For**## peut être imbriqué, ce qui signifie qu'il peut être utilisé dans un bloc d'instructions d'une autre déclaration ##**For**##.

	**Note**: Quand ##//stepvalue//## est négatif, ##**For**## boucle tant qu'est effectuée la comparaison ##//iterator//## //plus petit que// ##//end_value//##.

	##//For//##, ##//Next//## et ##//Step//## sont des opérateurs qui peuvent être surchargés dans des types définis par l'utilisateur. Voir [[KeyPgOpFor Opérateur For]], [[KeyPgOpNext Opérateur Next]], [[KeyPgOpStep Opérateur]]

{{fbdoc item="ex"}}
{{fbdoc item="filename" value="examples/manual/control/for-next.bas"}}%%(freebasic)
Dim i As Single
Print "counting from 3 to 0, with a step of -0.5"
dim i as single
for i = 3 to 0 step -0.5
	print "i is " & i
next i%%
{{fbdoc item="filename" value="examples/manual/control/for-next2.bas"}}%%(freebasic)
dim as integer i, j, k, toTemp, stepTemp
j = 9: k = 1

for i = 0 to j step k
	
	j = 0: k = 0 '' Changing j and k has no effect on the current loop.
	print i;
	
next i
print

' Internally, this is what the above example does:
j = 9: k = 1

i = 0: toTemp = j: stepTemp = k
do while iif(stepTemp >= 0, i <= toTemp, i >= toTemp)
	
	j = 0: k = 0 '' Changing j and k has no effect on the current loop.
	print i;
	
	i += stepTemp
loop
print%%

{{fbdoc item="lang"}}
	- Dans les dialectes //[[CompilerOptlang -lang qb]]// et //[[CompilerOptlang -lang fblite]]//, les variables déclarées dans une boucle FOR..NEXT ont une [[ProPgVariableScope portée]] à l'échelle de la fonction comme dans QB. 
	- Dans les dialectes //[[CompilerOptlang -lang fb]]// et //[[CompilerOptlang -lang deprecated]]// les variables déclarées dans une boucle ##**For**##..##**Next**## ne sont visibles que dans le bloc et ne peuvent être utilisées en-dehors de lui.

{{fbdoc item="diff"}}
	- Les arguments ##[[KeyPgByref Byref]]## ne peuvent être utilisés comme compteurs.

{{fbdoc item="see"}}
	- ##[[KeyPgContinue Continue]]##
	- ##[[KeyPgDoloop Do...Loop]]##
	- ##[[KeyPgExit Exit]]##

{{fbdoc item="back" value="CatPgControlFlow|Control Flow"}}

