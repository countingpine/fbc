{{fbdoc item="title" value="So Biff wants to have a high score table in his game "}}----
Ecrit par Lachie Dazdarian (Septembre, 2007)

==Introduction==

À plus d'une occasion, des novices en programmation m'ont interrogé sur un ensemble de routines qui chargent un tableau des meilleurs scores à partir d'un fichier externe, entrent correctement un nouveau meilleur score, puis enregistrent le tableau modifié des scores les plus élevés.
Utilisant le même ensemble de routines pour les scores les plus élevés depuis la création de "Ball Blazing Fantasy", j'ai décidé d'écrire un tutoriel sur cela et de mettre en oeuvre une certaine souplesse manquante (ainsi que quelques corrections), quelque chose qui avait besoin d'être fait depuis longtemps, mais parce que ces routines ne faisaient pas leur travail parfaitement.
Le tutoriel vous rappellera un certain nombre des routines supplémentaires utiles (pour la gestion de la table des scores les plus élevés), comme la saisie du nom et le cryptage de fichiers, mais que je n'ai pas écrites moi-même.


==Faisons-le!==

Il est assez évident que nous aurons besoin de deux sous-programmes distincts, un pour le chargement/la lecture et un autre pour l'écriture/la modification de notre tableau des meilleurs scores.
Nous allons commencer avec le chargement/la lecture d'un tableau de scores élevés, car cette partie est la plus facile et un départ logique.
Le sous-programme pour lire un tableau des meilleurs scores devraient fonctionner relativement simplement. Il va ouvrir un fichier qui contient les entrées de noms et le score, les stocker dans des variables appropriées et ensuite les afficher sur l'écran, cette partie étant plus dépendante des souhaits du développeur et des besoins (la méthode d'affichage, la position de la table des scores élevés, son formatage, etc.)
Premièrement, nous devons créer un fichier texte contenant notre nom et les entrées de score. Créez un fichier nommé 'high_scores.dat', ouvrez-le avec "Notepad" et entrez ce qui suit:

%%(freebasic)
FRED
10000
BILL
9000
SARAH
8000
BOB
7000
RED
6000
SUE
5000
DAVID
4000
GREG
3000
TIM
2000
GEORGE
1000
%%

Il contient 10 entrées de scores élevés, formaté avec le nom suivi par le score correspondant. Je trouve cette mise en forme la plus adaptée pour l'édition, même si vous pouvez en choisir un où tous les noms sont répertoriés en premier, puis suivis de tous les scores. Cependant, aucun de ces deux types de formatage n'a d'avantages plus importants, nous allons donc travailler sur celui avec lequel j'ai commencé.

Ce fichier sera utilisé avec le sous-programme "ReadHighScore" suivant.

Commençons notre programme principal avec quelques déclarations d'initialisation nécessaires:

%%(freebasic)
#include "fbgfx.bi"
Using FB

const num_of_entries = 10
%%

"num_of_entries" sera le nombre d'entrées score (noms ou des scores dans le tableau des meilleurs scores), et doit correspondre au nombre d'entrées dans le fichier "high_score.dat" (pas les lignes, mais les ENTREES de score élevé!).

Nous devons maintenant déclarer notre sous-programme avec:

%%(freebasic)
DECLARE SUB ReadHighScore (highscore_file AS STRING)
%%

La variable "highscore_file" indiquera le nom du fichier que le sous-programme "ReadHighScore" ouvrira. Il n'est pas nécessaire de déclarer le sous-programme de cette façon, mais cela ajoute une certaine souplesse d'utilisation.

Après cela, nous devons déclarer les variables suivantes:

%%(freebasic)DIM SHARED workpage AS INTEGER
DIM SHARED hname(num_of_entries) AS STRING
DIM SHARED hscore(num_of_entries) AS STRING
%%

La variable "workpage" n'est pas liée à ce tutoriel et sera utilisée pour échanger des pages d'écran de travail à l'intérieur de la boucle où le tableau des meilleurs scores sera affiché. Le tableau "hname" contiendra les entrées nom, tandis que le tableau "hscore" contiendra les entrées de la table de pointage score élevé.

Enfin, nous allons initialiser notre écran et les pages de travail/visibles avec:

%%(freebasic)ScreenRes 640, 480, 32, 2, GFX_ALPHA_PRIMITIVES+GFX_WINDOWED 
ScreenSet 1, 0
Suite à ce code, il faut placer celui-ci:
%%

(freebasic)

%%ReadHighScore "high_scores.dat"
End
Sub ReadHighScore (highscore_file As String)

End Sub

Vous pouvez compiler ce code, mais rien ne se passera car le sous-programme "ReadHighScore" est vide. Remplissons-le!
%%

Nous le démarrons en ouvrant le fichier "high_scores.dat" et en y lisant les données nécessaires. S'il vous plaît référez-vous à l'instruction OPEN de FreeBASIC pour des infos sur l'ouverture de fichiers dans FreeBASIC si cela ne vous est pas familier.
Comme nous voulons ouvrir le fichier en utilisant un identificateur de fichier FREE, nous avons besoin de dimensionner une variable qui va contenir cette information et la transmettre. Utilisez ce code:

(freebasic)

%%Dim free_filehandle As Integer
free_filehandle = FreeFile

Nous devons maintenant ouvrir le fichier de scores élevés avec:
%%

(freebasic)

%%Open highscore_file For Input As #free_filehandle
Une fois le fichier ouvert en lecture (FOR INPUT), nous allons utiliser une boucle pour récupérer toutes les données qu'il contient et les stocker dans nos variables "hname" et "hscore":
%%

(freebasic)

%%For count_entry As Integer = 1 To num_of_entries
Input #free_filehandle, hname(count_entry)
Input #free_filehandle, hscore(count_entry)
' If the end of file is reached, exit the FOR loop.
If EOF(free_filehandle) Then Exit For
Next count_entry
Notez comment la variable "count_entry" est utilisée et comment pour chaque entrée le nom est stocké SUIVI du score correspondant. "hname(1)" correspondra au nom avec le meilleur score et "hscore(1)" au plus haut score. "hname(num_of_entries)" correspondra au nom avec le score le plus bas et "hscore(num_of_entries)" le plus petit score dans le tableau des meilleurs scores.
%%

N'oubliez pas maintenant de fermer le dossier avec:

(freebasic)

%%Close #free_filehandle
Tout ce dont nous avons besoin maintenant c'est d'une boucle qui permettra d'afficher tous ces noms et scores, joliment disposés dans un tableau. 
%%

(freebasic)

%%Do
ScreenLock

ScreenSet workpage, workpage Xor 1
Line (0,0)-(639,479), RGBA(0, 0, 0, 255), BF

Draw String (285, 120), "TOP SCORES", RGBA(255,255, 255, 255)

For count_entry As Integer = 1 To num_of_entries

Draw String (270, 140 + count_entry * 12), hname(count_entry), RGBA(255,255, 255, 250-count_entry*10)
Draw String (340, 140 + (count_entry) * 12), hscore(count_entry), RGBA(255,255, 255, 250-count_entry*10)
Next count_entry
Draw String (245, 400), "Press ESCAPE to exit", RGBA(255,255, 255, 220)

workpage Xor = 1

ScreenUnlock
Sleep 10

Loop Until MultiKey(SC_ESCAPE)

Une simple boucle DO...LOOP qui se terminera quand l'utilisateur appuiera sur ESCAPE.
%%

J'ai utilisé "Draw String" pour afficher les noms et les scores. Une autre boucle FOR est utilisée pour parcourir les entrées noms et scores et de les afficher en plaçant le score le plus faible en-dessous de celui qui lui est immédiatement supérieur (Notez comment la position Y du texte à afficher est liée à la variable "count_entry" augmentée de 12 pour obtenir plus d'espace entre les scores verticalement). J'ai aussi utilisé une petite astuce pour afficher chaque résultat suivant avec moins translucidité (dernier paramètre dans la fonction RGBA).
Après avoir placé tout ce code dans le sous-programme "ReadHighScore", vous pouvez le compiler et le résultat souhaité s'affichera sur l'écran.

Maintenant, quand nous avons fini avec la partie facile du problème, nous allons passer à l'écriture de nouvelles entrées dans notre tableau des meilleurs scores.

J'ai construit le sous-programme "WriteHighScore" comme ceci:

(freebasic)

%%Sub WriteHighScore (highscore_file As String, users_score As Integer)

Ce qui signifie qu'il sera appelé avec un fichier de table des scores élevés et un score que nous voulons entrer. Si ce score est évalué comme étant inférieur au plus faible dans le tableau des meilleurs scores, aucun code sera exécuté.

%%

Ce sous-programme devrait commencer par le code suivant:

(freebasic)

%%Dim free_filehandle As Integer
Dim startwrite As Integer

free_filehandle = FreeFile

Open highscore_file For Input As #free_filehandle

For count_entry As Integer = 1 To num_of_entries

Input #free_filehandle, hname(count_entry)
Input #free_filehandle, hscore(count_entry)
' If the end of file is reached, exit the FOR loop.
If EOF(free_filehandle) Then Exit For
Next count_entry
Close #free_filehandle

Comme vous le voyez il commence par le sous-programme "ReadHighScore". Afin d'évaluer le score de l'utilisateur et de modifier le tableau des meilleurs scores, nous devons ouvrir le fichier contenant nos entrées des scores les plus élevés et les stocker dans des variables appropriées. La variable "startwrite" indiquera où la nouvelle entrée doit être placée à l'intérieur du tableau des meilleurs scores (à quelle position).
%%

Le code qui suit doit être ouvert avec une clause IF qui va exécuter le code à l'intérieur seulement si le score de l'utilisateur est plus élevé que le plus petit score dans le tableau des meilleurs scores (naturellement):
(freebasic)

%%If users_score > hscore(num_of_entries) Then
For check_score As Integer = 1 To num_of_entries

If users_score > hscore(check_score) Then

InputName
' Record the position where the new score is
' to placed and exit FOR loop.
startwrite = check_score
Exit For
End If
Next check_score

La boucle FOR passe en revue les entrées scores les plus élevés de la plus elevée à la plus faible, et quand on trouve une entrée avec un score inférieur elle correspond à la position recherchée (marqué avec "startwrite" et "check_score" ) où notre nouvelle entrée sera enregistrée. Par exemple, dans la première boucle, le programme vérifie pour "hscore(1)" - le plus haut score dans le tableau des meilleurs scores. Si le score de l'utilisateur finit par être plus élevé que lui, il est évident que le score de l'utilisateur est le nouveau score supérieur et "startwrite" doit être 1. "InputName" est un sous-programme, que nous créerons plus tard, et à l'intérieur, l'utilisateur saisiera ... son nom. :P
%%

Ce qui suit est le "nexus" de notre sous-programme, le code qui place l'entrée nouveau meilleur score sur la position appropriée, et pousse toutes les plus basses d'une position vers le bas.

Vérifiez le code suivant:

(freebasic)

%%If startwrite = num_of_entries Then
hscore(startwrite) = users_score
hname(startwrite) = playername
Else
For write_pos As Integer = (num_of_entries - 1) To startwrite Step -1
 
hscore(write_pos + 1) = hscore(write_pos)
hname(write_pos + 1) = hname(write_pos)
Next write_pos
hscore(startwrite) = users_score
hname(startwrite) = playername
End If
La première condition vérifie si la nouvelle entrée est la plus basse (dernière) dans le tableau des meilleurs scores. Si c'est le cas, nous n'avons pas besoin d'examiner vers le bas toutes les entrées avec un score inférieur car il n'en existe pas, il suffit donc de remplacer l'entrée score le plus bas avec la nouvelle.
%%

Si ce N'EST PAS le cas, une boucle FOR est exécutée, qui boucle à partir de l'entrée du plus faible score jusqu'à la nouvelle entrée (marquée par "startwrite"), ce qui signifie, du bas vers le haut.
Par exemple, si notre tableau des meilleurs scores a 10 entrées et que la nouvelle entrée doit être placée sur la position 5, la boucle va de 9 à 5. Quand "write_pos" est de 9, les valeurs de "hscore(9)" et "hname(9)" sont passées à "hscore(9+1)" et "hname(9+1)". Lorsque "write_pos" est de 8, les valeurs de "hscore(8)" et "hname(8)" sont passées à "hscore(8+1)" et "hname(8+1)". Et ainsi de suite.

Après la boucle FOR nous devons saisir la nouvelle entrée sur sa position appropriée (pointée par "startwrite"), la nouvelle entrée étant fixée par "users_score" et "nomdujoueur", où "nomdujoueur" sera saisia à l'intérieur du sous-programme "InputName".

La dernière chose que nous devons faire sous "WriteHighScore" est de stocker à nouveau les nouvelles entrées scores élevés dans le fichier:

(freebasic)

%%free_filehandle = FreeFile
Open highscore_file For Output As free_filehandle

For count_entry As Integer = 1 To num_of_entries
Print #free_filehandle, hname(count_entry)
Print #free_filehandle, hscore(count_entry)
Next count_entry
Close free_filehandle
Notez comment FOR OUTPUT est utilisé et PRINT pour écrire des données dans des fichiers externes.
%%

Après cela, j'ai mis un appel à "ReadHighScore" et fermée avec END IF car je pense que la table des scores doit être affichée après une nouvelle entrée.
Ce dont nous avons besoin maintenant est de créer le sous-programme "InputName":
(freebasic)

%%Sub InputName
ScreenSet workpage, workpage Xor 1

ScreenSet 0,0
Line (0,0)-(639,479), RGBA(0, 0, 0, 255), BF
Locate 12, 17
Input ; "Please input your name: ", playername
End Sub

Bien sûr, cela va un "look" totalement différent dans votre jeu. Peut-être que vous demanderez au joueur d'entrer son nom à un emplacement différent dans le jeu (comme quand il/elle commence une nouvelle partie). Ayez à l'esprit que vous en avez besoin.
%%

Pour tester les sous-programmes, placez simplement...

(freebasic)

%%ReadHighScore "high_scores.dat"
WriteHighScore "high_scores.dat", 4500
End
...après le premier SCREENSET (sous-programmes externes). Changer le deuxième paramètre à l'appel de "WriteHighScore" pour entrer des scores différents à différents endroits dans la table des meilleurs scores.Je suis sûr que vous savez que lorsque vous appelez "WriteHighScore" le second paramètre ne doit pas être codé en dur avec un nombre statique, mais avec une variable dans laquelle vous allez stocker le score du joueur, quoi qu'il en soit dans votre cas (c'est à dire "Player.Score").
%%

**Et ensuite?**

Les seules autres choses que je souhaite partager sur cette question sont liées à un cryptage du score le plus élevé et un meilleur sous-programme de saisie du nom. Comme les deux routines utilisées ne sont pas de moi, je ne peux que donner des explications sur elles et de les donner dans un exemple de programme que vous pourrez facilement utiliser pour vos propres besoins.

Le cryptage est réalisé en utilisant deux fonctions, "neoENCpass" et "neodeENCpass". Une pour le chiffrement et l'autre pour le déchiffrement. Elles sont appelées avec une chaîne de caractères (dans notre cas, une chaîne du score le plus élevé) et un mot de passe qui est une chaîne de caractères que vous choisissez; et c'est la même chaîne de caractères qui doit être utilisée pour chiffrer et déchiffrer (bien sûr).
Après récupération d'une chaîne à partir d'un fichier, vous la décryptez comme ceci:
(freebasic)

%%Input #free_filehandle, hname(count_entry)
neoENCdepass SAdd(hname(count_entry)), Len(hname(count_entry)), "yourpass"
Avec les variables "hscore", qui sont des INTEGERs (ENTIERs), nous devons utiliser une variable temporaire STRING qui sera décryptée et sa valeur passée à "hscore".
%%

Le seul élément gênant de cette méthode réside dans le fait que vous devez avoir un code source distinct pour crypter/décrypter vos fichiers scores élevés, car les routines à l'intérieur d'un projet ne fonctionneront que si le fichier scores élevés est préalablement crypté. Je fournis un petit programme qui fait ce cryptage pour vous. Il est recommandé de garder une sauvegarde de votre fichier scores élevés dans un dossier séparé (Je l'ai également fourni dans le présent téléchargement zip), même s'il n'est pas chiffré.
Au lieu du cryptage vous pouvez utiliser des fichiers BINARY (binaires), mais je ne sais pas comment les utiliser à l'heure actuelle (je n'ai pas le temps d'apprendre; soumettant ce tutoriel dans la précipitation), et ce N'EST PAS équivalent pas au CRYPTAGE. Les fichiers cryptés qui utilisent ces routines ne peuvent être décryptés que si les personnes ont le mot de passe (ainsi pour la plupart), tandis que les fichiers binaires peuvent être lus par n'importe qui ayant votre source. Ah oui, en fournissant votre code source au public n'oubliez pas de changer les mots de passe de cryptage à l'intérieur.
Quoi qu'il en soit, en fin de compte, vous n'avez pas forcément besoin/préfèrer le cryptage. Mais personnellement, j'aime avoir mes fichiers de scores élevés/script cryptés de sorte que tous les Dick et Tom ne puissent pas les changer/lire avec "Notepad". Des scores élevés non-chiffrés  pourraient tuer le défi de se battre avec certains joueurs.
Je ne vais pas décrire la routine de saisie du nom, car c'est sans rapport avec le sujet. Vous avez le code, liez-le. C'est beaucoup mieux qu'un simple INPUT (vous pouvez l'utiliser avec vos propres bibliothèques d'affichage de police) et vous permet de limiter le nombre de caractères dans le nom. La routine a été écrite par Ryan Szrama, et l'en remercions.
Téléchargez l'exemple étendu (avec cryptage et meilleure saisie du nom): http://lachie.phatcode.net/Downloads/Managing_A_High_Score_Table.zip
Et c'est tout pour ce tutoriel.

Jusqu'à la prochaine fois, amusez-vous bien!
Un tutoriel écrit par Lachie D. (mailto CHR$(58) lachie13 CHR$(64) yahoo CHR$(46) com ; http://lachie.phatcode.net - The Maker Of Stuff)

A tutorial written by Lachie D. (mailto CHR$(58) lachie13 CHR$(64) yahoo CHR$(46) com ; [[http://lachie.phatcode.net]] - The Maker Of Stuff)
