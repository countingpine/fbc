{{fbdoc item="title" value="So Biff wants to have a high score table in his game "}}----
Ecrit par Lachie Dazdarian (Septembre, 2007)

**Introduction**

&Agrave; plus d'une occasion, des novices en programmation m'ont interrog&eacute; sur un ensemble de routines qui chargent un tableau des meilleurs scores &agrave; partir d'un fichier externe, entrent correctement un nouveau meilleur score, puis enregistrent le tableau modifi&eacute; des scores les plus &eacute;lev&eacute;s.
Utilisant le m&ecirc;me ensemble de routines pour les scores les plus &eacute;lev&eacute;s depuis la cr&eacute;ation de "Ball Blazing Fantasy", j'ai d&eacute;cid&eacute; d'&eacute;crire un tutoriel sur cela et de mettre en oeuvre une certaine souplesse manquante (ainsi que quelques corrections), quelque chose qui avait besoin d'&ecirc;tre fait depuis longtemps, mais parce que ces routines ne faisaient pas leur travail parfaitement.
Le tutoriel vous rappellera un certain nombre des routines suppl&eacute;mentaires utiles (pour la gestion de la table des scores les plus &eacute;lev&eacute;s), comme la saisie du nom et le cryptage de fichiers, mais que je n'ai pas &eacute;crites moi-m&ecirc;me.


**Faisons-le!**

Il est assez &eacute;vident que nous aurons besoin de deux sous-programmes distincts, un pour le chargement/la lecture et un autre pour l'&eacute;criture/la modification de notre tableau des meilleurs scores.
Nous allons commencer avec le chargement/la lecture d'un tableau de scores &eacute;lev&eacute;s, car cette partie est la plus facile et un d&eacute;part logique.
Le sous-programme pour lire un tableau des meilleurs scores devraient fonctionner relativement simplement. Il va ouvrir un fichier qui contient les entr&eacute;es de noms et le score, les stocker dans des variables appropri&eacute;es et ensuite les afficher sur l'&eacute;cran, cette partie &eacute;tant plus d&eacute;pendante des souhaits du d&eacute;veloppeur et des besoins (la m&eacute;thode d'affichage, la position de la table des scores &eacute;lev&eacute;s, son formatage, etc.)
Premi&egrave;rement, nous devons cr&eacute;er un fichier texte contenant notre nom et les entr&eacute;es de score. Cr&eacute;ez un fichier nomm&eacute; 'high_scores.dat', ouvrez-le avec "Notepad" et entrez ce qui suit:

%%(freebasic)
FRED
10000
BILL
9000
SARAH
8000
BOB
7000
RED
6000
SUE
5000
DAVID
4000
GREG
3000
TIM
2000
GEORGE
1000
%%

Il contient 10 entr&eacute;es de scores &eacute;lev&eacute;s, format&eacute; avec le nom suivi par le score correspondant. Je trouve cette mise en forme la plus adapt&eacute;e pour l'&eacute;dition, m&ecirc;me si vous pouvez en choisir un o&ugrave; tous les noms sont r&eacute;pertori&eacute;s en premier, puis suivis de tous les scores. Cependant, aucun de ces deux types de formatage n'a d'avantages plus importants, nous allons donc travailler sur celui avec lequel j'ai commenc&eacute;.

Ce fichier sera utilis&eacute; avec le sous-programme "ReadHighScore" suivant.

Commen&ccedil;ons notre programme principal avec quelques d&eacute;clarations d'initialisation n&eacute;cessaires:

%%(freebasic)
#include "fbgfx.bi"
Using FB

const num_of_entries = 10
%%

"num_of_entries" sera le nombre d'entr&eacute;es score (noms ou des scores dans le tableau des meilleurs scores), et doit correspondre au nombre d'entr&eacute;es dans le fichier "high_score.dat" (pas les lignes, mais les ENTREES de score &eacute;lev&eacute;!).

Nous devons maintenant d&eacute;clarer notre sous-programme avec:

%%(freebasic)
DECLARE SUB ReadHighScore (highscore_file AS STRING)
%%

La variable "highscore_file" indiquera le nom du fichier que le sous-programme "ReadHighScore" ouvrira. Il n'est pas n&eacute;cessaire de d&eacute;clarer le sous-programme de cette fa&ccedil;on, mais cela ajoute une certaine souplesse d'utilisation.

Apr&egrave;s cela, nous devons d&eacute;clarer les variables suivantes:

%%(freebasic)DIM SHARED workpage AS INTEGER
Dim Shared workpage As Integer
Dim Shared hname(num_of_entries) As String
Dim Shared hscore(num_of_entries) As String

%%

La variable "workpage" n'est pas li&eacute;e &agrave; ce tutoriel et sera utilis&eacute;e pour &eacute;changer des pages d'&eacute;cran de travail &agrave; l'int&eacute;rieur de la boucle o&ugrave; le tableau des meilleurs scores sera affich&eacute;. Le tableau "hname" contiendra les entr&eacute;es nom, tandis que le tableau "hscore" contiendra les entr&eacute;es de la table de pointage score &eacute;lev&eacute;.

Enfin, nous allons initialiser notre &eacute;cran et les pages de travail/visibles avec:
SCREENRES 640, 480, 32, 2, GFX_ALPHA_PRIMITIVES+GFX_WINDOWED
ScreenRes 640, 480, 32, 2, GFX_ALPHA_PRIMITIVES+GFX_WINDOWED
ScreenSet 1, 0

%%

Suite &agrave; ce code, il faut placer celui-ci:
ReadHighScore "high_scores.dat"
ReadHighScore "high_scores.dat"

End

Sub ReadHighScore (highscore_file As String)
End Sub

%%
Vous pouvez compiler ce code, mais rien ne se passera car le sous-programme "ReadHighScore" est vide. Remplissons-le!

Nous le d&eacute;marrons en ouvrant le fichier "high_scores.dat" et en y lisant les donn&eacute;es n&eacute;cessaires. S'il vous pla&icirc;t r&eacute;f&eacute;rez-vous &agrave; l'instruction OPEN de FreeBasic pour des infos sur l'ouverture de fichiers dans FreeBasic si cela ne vous est pas familier.

Comme nous voulons ouvrir le fichier en utilisant un identificateur de fichier FREE, nous avons besoin de dimensionner une variable qui va contenir cette information et la transmettre. Utilisez ce code:
DIM free_filehandle AS INTEGER

Dim free_filehandle As Integer
free_filehandle = FreeFile

%%

Nous devons maintenant ouvrir le fichier de scores &eacute;lev&eacute;s avec:
OPEN highscore_file FOR INPUT AS #free_filehandle
Open highscore_file For Input As #free_filehandle

%%

Une fois le fichier ouvert en lecture (FOR INPUT), nous allons utiliser une boucle pour r&eacute;cup&eacute;rer toutes les donn&eacute;es qu'il contient et les stocker dans nos variables "hname" et "hscore":
FOR count_entry AS INTEGER = 1 TO num_of_entries
For count_entry As Integer = 1 To num_of_entries
Input #free_filehandle, hname(count_entry)
Input #free_filehandle, hscore(count_entry)
' If the end of file is reached, exit the FOR loop.
If EOF(free_filehandle) Then Exit For
Next count_entry

%%

Notez comment la variable "count_entry" est utilis&eacute;e et comment pour chaque entr&eacute;e le nom est stock&eacute; SUIVI du score correspondant. "hname(1)" correspondra au nom avec le meilleur score et "hscore(1)" au plus haut score. "hname(num_of_entries)" correspondra au nom avec le score le plus bas et "hscore(num_of_entries)" le plus petit score dans le tableau des meilleurs scores.

N'oubliez pas maintenant de fermer le dossier avec:
CLOSE #free_filehandle 
Close #free_filehandle 

%%

Tout ce dont nous avons besoin maintenant c'est d'une boucle qui permettra d'afficher tous ces noms et scores, joliment dispos&eacute;s dans un tableau.
DO

Do
ScreenLock

ScreenSet workpage, workpage Xor 1

Line (0,0)-(639,479), RGBA(0, 0, 0, 255), BF

Draw String (285, 120), "TOP SCORES", RGBA(255,255, 255, 255)
For count_entry As Integer = 1 To num_of_entries
Draw String (270, 140 + count_entry * 12), hname(count_entry), RGBA(255,255, 255, 250-count_entry*10)
Draw String (340, 140 + (count_entry) * 12), hscore(count_entry), RGBA(255,255, 255, 250-count_entry*10)

Next count_entry

Draw String (245, 400), "Press ESCAPE to exit", RGBA(255,255, 255, 220)
workpage Xor = 1

ScreenUnlock

Sleep 10
Loop Until MultiKey(SC_ESCAPE)

%%
Une simple boucle DO...LOOP qui se terminera quand l'utilisateur appuiera sur ESCAPE.

J'ai utilis&eacute; "Draw String" pour afficher les noms et les scores. Une autre boucle FOR est utilis&eacute;e pour parcourir les entr&eacute;es noms et scores et de les afficher en pla&ccedil;ant le score le plus faible en-dessous de celui qui lui est imm&eacute;diatement sup&eacute;rieur (Notez comment la position Y du texte &agrave; afficher est li&eacute;e &agrave; la variable "count_entry" augment&eacute;e de 12 pour obtenir plus d'espace entre les scores verticalement). J'ai aussi utilis&eacute; une petite astuce pour afficher chaque r&eacute;sultat suivant avec moins translucidit&eacute; (dernier param&egrave;tre dans la fonction RGBA).

Apr&egrave;s avoir plac&eacute; tout ce code dans le sous-programme "ReadHighScore", vous pouvez le compiler et le r&eacute;sultat souhait&eacute; s'affichera sur l'&eacute;cran.

Maintenant, quand nous avons fini avec la partie facile du probl&egrave;me, nous allons passer &agrave; l'&eacute;criture de nouvelles entr&eacute;es dans notre tableau des meilleurs scores.

J'ai construit le sous-programme "WriteHighScore" comme ceci:

SUB WriteHighScore (highscore_file AS STRING, users_score AS INTEGER)

Sub WriteHighScore (highscore_file As String, users_score As Integer)

%%

Ce qui signifie qu'il sera appel&eacute; avec un fichier de table des scores &eacute;lev&eacute;s et un score que nous voulons entrer. Si ce score est &eacute;valu&eacute; comme &eacute;tant inf&eacute;rieur au plus faible dans le tableau des meilleurs scores, aucun code sera ex&eacute;cut&eacute;.

Ce sous-programme devrait commencer par le code suivant:
DIM free_filehandle AS INTEGER

Dim free_filehandle As Integer

Dim startwrite As Integer

free_filehandle = FreeFile

Open highscore_file For Input As #free_filehandle
For count_entry As Integer = 1 To num_of_entries
Input #free_filehandle, hname(count_entry)
Input #free_filehandle, hscore(count_entry)
' If the end of file is reached, exit the FOR loop.
If EOF(free_filehandle) Then Exit For

Next count_entry
Close #free_filehandle

%%
Comme vous le voyez il commence par le sous-programme "ReadHighScore". Afin d'&eacute;valuer le score de l'utilisateur et de modifier le tableau des meilleurs scores, nous devons ouvrir le fichier contenant nos entr&eacute;es des scores les plus &eacute;lev&eacute;s et les stocker dans des variables appropri&eacute;es. La variable "startwrite" indiquera o&ugrave; la nouvelle entr&eacute;e doit &ecirc;tre plac&eacute;e &agrave; l'int&eacute;rieur du tableau des meilleurs scores (&agrave; quelle position).

Le code qui suit doit &ecirc;tre ouvert avec une clause IF qui va ex&eacute;cuter le code &agrave; l'int&eacute;rieur seulement si le score de l'utilisateur est plus &eacute;lev&eacute; que le plus petit score dans le tableau des meilleurs scores (naturellement):
IF users_score > hscore(num_of_entries) THEN

If users_score > hscore(num_of_entries) Then

For check_score As Integer = 1 To num_of_entries
If users_score > hscore(check_score) Then
InputName
' Record the position where the new score is
' to placed and exit FOR loop.
startwrite = check_score
Exit For

End If
Next check_score

%%

La boucle FOR passe en revue les entr&eacute;es scores les plus &eacute;lev&eacute;s de la plus elev&eacute;e &agrave; la plus faible, et quand on trouve une entr&eacute;e avec un score inf&eacute;rieur elle correspond &agrave; la position recherch&eacute;e (marqu&eacute; avec "startwrite" et "check_score" ) o&ugrave; notre nouvelle entr&eacute;e sera enregistr&eacute;e. Par exemple, dans la premi&egrave;re boucle, le programme v&eacute;rifie pour "hscore(1)" - le plus haut score dans le tableau des meilleurs scores. Si le score de l'utilisateur finit par &ecirc;tre plus &eacute;lev&eacute; que lui, il est &eacute;vident que le score de l'utilisateur est le nouveau score sup&eacute;rieur et "startwrite" doit &ecirc;tre 1. "InputName" est un sous-programme, que nous cr&eacute;erons plus tard, et &agrave; l'int&eacute;rieur, l'utilisateur saisiera ... son nom. :P

Ce qui suit est le "nexus" de notre sous-programme, le code qui place l'entr&eacute;e nouveau meilleur score sur la position appropri&eacute;e, et pousse toutes les plus basses d'une position vers le bas.

V&eacute;rifiez le code suivant:
IF startwrite = num_of_entries THEN
If startwrite = num_of_entries Then
hscore(startwrite) = users_score
hname(startwrite) = playername
 
Else
For write_pos As Integer = (num_of_entries - 1) To startwrite Step -1
hscore(write_pos + 1) = hscore(write_pos)
hname(write_pos + 1) = hname(write_pos)
Next write_pos
hscore(startwrite) = users_score
hname(startwrite) = playername
End If

%%
La premi&egrave;re condition v&eacute;rifie si la nouvelle entr&eacute;e est la plus basse (derni&egrave;re) dans le tableau des meilleurs scores. Si c'est le cas, nous n'avons pas besoin d'examiner vers le bas toutes les entr&eacute;es avec un score inf&eacute;rieur car il n'en existe pas, il suffit donc de remplacer l'entr&eacute;e score le plus bas avec la nouvelle.

Si ce N'EST PAS le cas, une boucle FOR est ex&eacute;cut&eacute;e, qui boucle &agrave; partir de l'entr&eacute;e du plus faible score jusqu'&agrave; la nouvelle entr&eacute;e (marqu&eacute;e par "startwrite"), ce qui signifie, du bas vers le haut.

Par exemple, si notre tableau des meilleurs scores a 10 entr&eacute;es et que la nouvelle entr&eacute;e doit &ecirc;tre plac&eacute;e sur la position 5, la boucle va de 9 &agrave; 5. Quand "write_pos" est de 9, les valeurs de "hscore(9)" et "hname(9)" sont pass&eacute;es &agrave; "hscore(9+1)" et "hname(9+1)". Lorsque "write_pos" est de 8, les valeurs de "hscore(8)" et "hname(8)" sont pass&eacute;es &agrave; "hscore(8+1)" et "hname(8+1)". Et ainsi de suite.

Apr&egrave;s la boucle FOR nous devons saisir la nouvelle entr&eacute;e sur sa position appropri&eacute;e (point&eacute;e par "startwrite"), la nouvelle entr&eacute;e &eacute;tant fix&eacute;e par "users_score" et "nomdujoueur", o&ugrave; "nomdujoueur" sera saisia &agrave; l'int&eacute;rieur du sous-programme "InputName".

La derni&egrave;re chose que nous devons faire sous "WriteHighScore" est de stocker &agrave; nouveau les nouvelles entr&eacute;es scores &eacute;lev&eacute;s dans le fichier:
free_filehandle = FreeFile

free_filehandle = FreeFile
Open highscore_file For Output As free_filehandle
For count_entry As Integer = 1 To num_of_entries
Print #free_filehandle, hname(count_entry)
Print #free_filehandle, hscore(count_entry)
Next count_entry
Close free_filehandle

%%
Notez comment FOR OUTPUT est utilis&eacute; et PRINT pour &eacute;crire des donn&eacute;es dans des fichiers externes. 
Apr&egrave;s cela, j'ai mis un appel &agrave; "ReadHighScore" et ferm&eacute;e avec END IF car je pense que la table des scores doit &ecirc;tre affich&eacute;e apr&egrave;s une nouvelle entr&eacute;e.

Ce dont nous avons besoin maintenant est de cr&eacute;er le sous-programme "InputName":
SUB InputName

Sub InputName
ScreenSet workpage, workpage Xor 1
ScreenSet 0,0
Line (0,0)-(639,479), RGBA(0, 0, 0, 255), BF
Locate 12, 17

Input ; "Please input your name: ", playername
End Sub

%%

Bien s&ucirc;r, cela va un "look" totalement diff&eacute;rent dans votre jeu. Peut-&ecirc;tre que vous demanderez au joueur d'entrer son nom &agrave; un emplacement diff&eacute;rent dans le jeu (comme quand il/elle commence une nouvelle partie). Ayez &agrave; l'esprit que vous en avez besoin.

Pour tester les sous-programmes, placez simplement...
ReadHighScore "high_scores.dat"
ReadHighScore "high_scores.dat"
WriteHighScore "high_scores.dat", 4500
End

%%

...apr&egrave;s le premier SCREENSET (sous-programmes externes). Changer le deuxi&egrave;me param&egrave;tre &agrave; l'appel de "WriteHighScore" pour entrer des scores diff&eacute;rents &agrave; diff&eacute;rents endroits dans la table des meilleurs scores.Je suis s&ucirc;r que vous savez que lorsque vous appelez "WriteHighScore" le second param&egrave;tre ne doit pas &ecirc;tre cod&eacute; en dur avec un nombre statique, mais avec une variable dans laquelle vous allez stocker le score du joueur, quoi qu'il en soit dans votre cas (c'est &agrave; dire "Player.Score").

**Et ensuite?**
Les seules autres choses que je souhaite partager sur cette question sont li&eacute;es &agrave; un cryptage du score le plus &eacute;lev&eacute; et un meilleur sous-programme de saisie du nom. Comme les deux routines utilis&eacute;es ne sont pas de moi, je ne peux que donner des explications sur elles et de les donner dans un exemple de programme que vous pourrez facilement utiliser pour vos propres besoins.
Le cryptage est r&eacute;alis&eacute; en utilisant deux fonctions, "neoENCpass" et "neodeENCpass". Une pour le chiffrement et l'autre pour le d&eacute;chiffrement. Elles sont appel&eacute;es avec une cha&icirc;ne de caract&egrave;res (dans notre cas, une cha&icirc;ne du score le plus &eacute;lev&eacute;) et un mot de passe qui est une cha&icirc;ne de caract&egrave;res que vous choisissez; et c'est la m&ecirc;me cha&icirc;ne de caract&egrave;res qui doit &ecirc;tre utilis&eacute;e pour chiffrer et d&eacute;chiffrer (bien s&ucirc;r).

Apr&egrave;s r&eacute;cup&eacute;ration d'une cha&icirc;ne &agrave; partir d'un fichier, vous la d&eacute;cryptez comme ceci:
INPUT #free_filehandle, hname(count_entry)
Input #free_filehandle, hname(count_entry)
neoENCdepass SAdd(hname(count_entry)), Len(hname(count_entry)), "yourpass"

%%
Avec les variables "hscore", qui sont des INTEGERs (ENTIERs), nous devons utiliser une variable temporaire STRING qui sera d&eacute;crypt&eacute;e et sa valeur pass&eacute;e &agrave; "hscore".
Le seul &eacute;l&eacute;ment g&ecirc;nant de cette m&eacute;thode r&eacute;side dans le fait que vous devez avoir un code source distinct pour crypter/d&eacute;crypter vos fichiers scores &eacute;lev&eacute;s, car les routines &agrave; l'int&eacute;rieur d'un projet ne fonctionneront que si le fichier scores &eacute;lev&eacute;s est pr&eacute;alablement crypt&eacute;. Je fournis un petit programme qui fait ce cryptage pour vous. Il est recommand&eacute; de garder une sauvegarde de votre fichier scores &eacute;lev&eacute;s dans un dossier s&eacute;par&eacute; (Je l'ai &eacute;galement fourni dans le pr&eacute;sent t&eacute;l&eacute;chargement zip), m&ecirc;me s'il n'est pas chiffr&eacute;.
Au lieu du cryptage vous pouvez utiliser des fichiers BINARY (binaires), mais je ne sais pas comment les utiliser &agrave; l'heure actuelle (je n'ai pas le temps d'apprendre; soumettant ce tutoriel dans la pr&eacute;cipitation), et ce N'EST PAS &eacute;quivalent pas au CRYPTAGE. Les fichiers crypt&eacute;s qui utilisent ces routines ne peuvent &ecirc;tre d&eacute;crypt&eacute;s que si les personnes ont le mot de passe (ainsi pour la plupart), tandis que les fichiers binaires peuvent &ecirc;tre lus par n'importe qui ayant votre source. Ah oui, en fournissant votre code source au public n'oubliez pas de changer les mots de passe de cryptage &agrave; l'int&eacute;rieur.
Quoi qu'il en soit, en fin de compte, vous n'avez pas forc&eacute;ment besoin/pr&eacute;f&egrave;rer le cryptage. Mais personnellement, j'aime avoir mes fichiers de scores &eacute;lev&eacute;s/script crypt&eacute;s de sorte que tous les Dick et Tom ne puissent pas les changer/lire avec "Notepad". Des scores &eacute;lev&eacute;s non-chiffr&eacute;s  pourraient tuer le d&eacute;fi de se battre avec certains joueurs.
Je ne vais pas d&eacute;crire la routine de saisie du nom, car c'est sans rapport avec le sujet. Vous avez le code, liez-le. C'est beaucoup mieux qu'un simple INPUT (vous pouvez l'utiliser avec vos propres biblioth&egrave;ques d'affichage de police) et vous permet de limiter le nombre de caract&egrave;res dans le nom. La routine a &eacute;t&eacute; &eacute;crite par Ryan Szrama, et l'en remercions.

T&eacute;l&eacute;chargez l'exemple &eacute;tendu (avec cryptage et meilleure saisie du nom): http://lachie.phatcode.net/Downloads/Managing_A_High_Score_Table.zip
Et c'est tout pour ce tutoriel.

Jusqu'&agrave; la prochaine fois, amusez-vous bien!
