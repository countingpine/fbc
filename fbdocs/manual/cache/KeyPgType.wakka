{{fbdoc item="title" value="TYPE"}}----
D&eacute;clare un type d&eacute;fini par l'utilisateur.

{{fbdoc item="syntax"}}##

	**Type** //typename//
		//fieldname1// [[KeyPgAs as]] //[[DataType DataType]]//
		//fieldname2// [[KeyPgAs as]] //[[DataType DataType]]//
		...
	**End Type**

	**Type** //typename// [ [[KeyPgField Field]] = //alignment// ]
		[ [[KeyPgVisPrivate Private]]: ]
		[ [[KeyPgVisPublic Public]]: ]
		[ [[KeyPgVisProtected Protected]]: ]
		[[KeyPgDeclare declare]] [[KeyPgConstructor constructor]] [ ( [ //parameters// ] ) ]
		[[KeyPgDeclare declare]] [[KeyPgDestructor destructor]]  [ () ]
		[[KeyPgDeclare declare]] [ [[KeyPgStaticMember Static]] | [[KeyPgConstMember Const]] ] [[KeyPgMemberSub sub]] //fieldname// [//calling convention specifier//] [ [[KeyPgAlias alias]] //external_name// ] [ ( [ //parameters// ] ) ] [ [[KeyPgStatic Static]] ]
		[[KeyPgDeclare declare]] [ [[KeyPgStaticMember Static]] | [[KeyPgConstMember Const]] ] [[KeyPgMemberFunction function]] //fieldname// [//calling convention specifier//] [ [[KeyPgAlias alias]] //external_name// ] [ ( [ //parameters// ] ) ] [ [[KeyPgAs as]] [[DataType datatype]] ] [ [[KeyPgStatic Static]] ]
		//fieldname// [ ( //array subscripts// ) | : //bits// ] [[KeyPgAs as]] //[[DataType DataType]]// [ = //initializer// ]
		[[KeyPgAs as]] [[DataType DataType]] //fieldname// [ ( //array subscripts// ) | : //bits// ] [ = //initializer// ], ...
		[[KeyPgDeclare declare]] [[KeyPgOperator operator]] //operatorname//[ ( [ //parameters// ] ) ]
		[[KeyPgDeclare declare]] [[KeyPgProperty property]] //fieldname//[ ( [ //parameters// ] ) ] [ [[KeyPgAs as]] [[DataType datatype]] ]
		...
	**End Type**
##
{{fbdoc item="param"}}
	##//alignment//##
		Sp&eacute;cifie l'alignement d'octets pour les champs de donn&eacute;es.
	##//fieldname//##
		Nom du champ de donn&eacute;es ou d'un membre de proc&eacute;dure.
	##//external_name//##
		Nom de domaine si liens externes.
	##//parameters//##
		Les param&egrave;tres &agrave; passer &agrave; un membre de proc&eacute;dure.
	##//array subscripts//##
		Les indices pour d&eacute;clarer un tableau de longueur fixe.
	##//bits//##
		Nombre de bits occup&eacute;s par un champ de donn&eacute;es.
	##//initializer//##
		Initialisation par d&eacute;faut pour le champ de donn&eacute;es.
	##//operatorname//##
		Le nom de l'op&eacute;rateur &agrave; surcharger.
	##//calling convention specifier//##
		Peut &ecirc;tre ##[[KeyPgCdecl cdecl]]##, ##[[KeyPgStdcall stdcall]]## or ##[[KeyPgPascal pascal]]##.

{{fbdoc item="desc"}}
	##**Type**## est utilis&eacute; pour d&eacute;clarer des types de donn&eacute;es contenant un ou plusieurs bits, scalaire, tableau ou d'autres champs de ##**Type**##.

	Supporte membre de fonctions incluant ##[[KeyPgConstructor Constructor]]##, ##[[KeyPgDestructor Destructor]]##, ##[[KeyPgMemberFunction Function]]##, ##[[KeyPgOperator Operator]]##, ##[[KeyPgProperty Property]]## et ##[[KeyPgMemberSub Sub]]##.

	Les champs seront, par d&eacute;faut, des membres &agrave; acc&egrave;s ##[[KeyPgVisPublic Public:]]## sauf si, ##[[KeyPgVisPrivate Private:]]## ou ##[[KeyPgVisProtected Protected:]]## est sp&eacute;cifi&eacute;.

	Une ##[[KeyPgUnion Union]]## anonyme peut &ecirc;tre imbriqu&eacute;e dans une d&eacute;claration de ##**Type**##.

	##[[KeyPgField Field]]=//number//## est facultatif, s'il existe, il change l'alignement par d&eacute;faut des champs. ##[[KeyPgField Field]]=1## annule tout alignement, rendant le ##**Type**## contigu en m&eacute;moire. 

	##**Type**## peut &ecirc;tre utilis&eacute; pour retourner une variable de type temporaire. Voir ##[[KeyPgTypeTemp Type()]]##.

	##**Type**## peut &ecirc;tre utilis&eacute; pour d&eacute;clarer une d&eacute;finition de type ( c'est &agrave; dire un alias ou un autre nom ) pour un type d&eacute;j&agrave; d&eacute;clar&eacute; ou qui va &ecirc;tre d&eacute;clar&eacute;.  Voir ##[[KeyPgTypeAlias Type (Alias)]]##

	Les champs de donn&eacute;es peuvent avoir une valeur facultative ##//initializer//## par d&eacute;faut.  Cette valeur par d&eacute;faut initialise le champ de donn&eacute;es imm&eacute;diatement avant tout appel du constructeur.

	##[[KeyPgStaticMember Static]]## qui pr&eacute;c&egrave;de imm&eacute;diatement ##[[KeyPgMemberSub Sub]]## ou ##[[KeyPgMemberFunction Function]]## indique qu'aucun param&egrave;tre cach&eacute; ##[[KeyPgThis This]]## doit &ecirc;tre transmis au membre de la proc&eacute;dure.

	##[[KeyPgConstMember Const]]## qui pr&eacute;c&egrave;de imm&eacute;diatement ##[[KeyPgMemberSub Sub]]## ou ##[[KeyPgMemberFunction Function]]## indique que le param&egrave;tre cach&eacute; ##[[KeyPgThis This]]## est &agrave; consid&eacute;rer comme en lecture-seulement (read-only).

	 **Avertissement:**
	<li>Des pr&eacute;cautions particuli&egrave;res doivent &ecirc;tre prises lors de l'utilisation d'un type d&eacute;fini par l'utilisateur pour les entr&eacute;es/sorties (I / O) fichier.  Il est recommand&eacute; d'utiliser ##Field = 1## pour de tels cas, et cela peut &ecirc;tre n&eacute;cessaire pour lire les fichiers cr&eacute;&eacute;s par d'autres applications.
	<li>Les types de donn&eacute;es utilisateur qui contiennent des pointeurs vers des donn&eacute;es ne doivent pas &ecirc;tre &eacute;crits dans le fichier tel quel: lorsque les donn&eacute;es sont lues plus tard, les pointeurs seront presque toujours invalides, et les donn&eacute;es qu'ils pointaient ne seront plus disponibles.  Au lieu de cela, des routines d'entr&eacute;e / sortie personnalis&eacute;s doivent &ecirc;tre utilis&eacute;es, pour sauver les donn&eacute;es allou&eacute;es dans un format diff&eacute;rent dans le fichier.  Cela inclut les types de donn&eacute;es utilisateur contenant des cha&icirc;nes de longueur variable.
	<li>En outre, la lecture de cha&icirc;nes de longueur fixe dans un type utilisateur &agrave; partir de fichiers est probl&eacute;matique: &agrave; l'heure actuelle, les cha&icirc;nes de longueur fixe contiennent un caract&egrave;re NULL suppl&eacute;mentaires &agrave; la fin.  Afin de pr&eacute;server l'alignement le champ devra &ecirc;tre d&eacute;clar&eacute; avec un nombre de caract&egrave;res inf&eacute;rieur &agrave; la taille r&eacute;elle et l'acc&egrave;s au champ par son nom rendra le dernier caract&egrave;re indisponible.  Cela signifie &eacute;galement qu'il peut y avoir des probl&egrave;mes potentiels en passant la cha&icirc;ne aux fonctions qui attendent d'avoir l&agrave; un caract&egrave;re NULL.

<li>Une meilleure solution consiste &agrave; utiliser des tableaux de type ##**UByte**##, cela n&eacute;cessite un couple de fonctions auxiliaires de conversion ##//'vers / &agrave; partir de'//## la cha&icirc;ne. Voir l'exemple.
{{fbdoc item="ex"}}
Ceci est un exemple de style QB-style, ne comprenant pas des d&eacute;finitions de proc&eacute;dure
TYPE clr
	Type clr
	red As UByte
	green As UByte
blue As UByte

End Type
Dim c As clr
c.red = 255
c.green = 128
c.blue = 64

%%
Et ceci un exemple d'un type fontionnant comme un objet:
'' Example showing the problems with fixed length string fields in UDTs
'' Example showing the problems with fixed length string fields in UDTs
'' Suppose we have read a GIF header from a file
''                        signature         width        height

Dim As ZString*(10+1) z => "GIF89a" + MKShort(10) + MKShort(11)

Print "Using fixed-length string"
   Type hdr1 Field = 1
	                    As String*(6-1) sig /' We have to dimension the string with 1 char
   '  less to avoid misalignments '/
As UShort wid, hei

End Type
Dim As hdr1 Ptr h1 = CPtr(hdr1 Ptr, @z)

Print h1->sig, h1->wid, h1->hei '' Prints GIF89 (misses a char!)  10  11

'' We can do comparisons only with the 5 visible chars and creating a temporary string with LEFT


If Left(h1->sig, 5) = "GIF89" Then Print "ok" Else Print "error"
'' Using a ubyte array, we need an auxiliary function to convert it to a string
	Function ub2str( ub() As UByte ) As String
	Dim As Integer length = UBound(ub) + 1
	Dim As String res = Space(length)
	    For i As Integer = 0 To length-1
	res[i] = ub(i): Next
Function = res


End Function
Print

Print "Using an array of ubytes"
   Type hdr2 Field = 1
   sig(0 To 6-1) As UByte '' Dimension 6
As UShort wid, hei

End Type
Dim As hdr2 Ptr h2 = CPtr(hdr2 Ptr, @z)

'' Viewing and comparing is correct but a conversion to string is required
Print ub2str(h2->sig()), h2->wid, h2->hei '' Prints GIF89a  10  11 (ok)
If ub2str(h2->sig()) = "GIF89a" Then Print "ok" Else Print "error" '' Prints ok

%%
	{{fbdoc item="target"}}
	- L'alignement des champs par d&eacute;faut est de 4 octets pour les cibles DOS et Linux.
	
- L'alignement des champs par d&eacute;faut est de 8 octets pour les cibles Windows.
	{{fbdoc item="lang"}}
	<li>Les fonctionnalit&eacute;s relatives aux objets telles que les fonctions d&eacute;clar&eacute;es &agrave; l'int&eacute;rieur de blocs ##**Type**## sont prises en charge uniquement avec le dialecte //[[CompilerOptlang -lang fb]]// depuis la version 0.17b
	- Dans les dialectes //[[CompilerOptlang -lang fb]]// et //[[CompilerOptlang -lang fblite]]//, l'alignement des champs par d&eacute;faut d&eacute;pend de la plate-forme cible.
	- Avec le dialecte //[[CompilerOptlang -lang qb]]// les champs sont align&eacute;s &agrave; l'octet limites par d&eacute;faut, sauf indication contraire.

- Pour forcer l'alignement octet utilisez ##FIELD=1##.
	{{fbdoc item="diff"}}

- A l'heure actuelle, les cha&icirc;nes de longueur fixe ont un suppl&eacute;ment, le caract&egrave;re redondant de fin, ce qui signifie qu'elles prennent un octet suppl&eacute;mentaire par rapport &agrave; QB.  Pour cette raison, les types d&eacute;finis par l'utilisateur qui les utilisent ne sont pas compatibles avec QB lorsqu'ils les utilisent pour les Entr&eacute;es / Sories de fichier.
	{{fbdoc item="see"}}
	- ##[[KeyPgTypeAlias Type (Alias)]]##
	- ##[[KeyPgTypeTemp Type (Temporary)]]##
	- ##[[KeyPgUnion Union]]##
	- ##[[KeyPgEnum Enum]]##
	- ##[[KeyPgTypeof TypeOf]]##
	- ##[[KeyPgOffsetof OffsetOf]]##
	- ##[[KeyPgField Field]]##

- ##[[KeyPgWith With]]##