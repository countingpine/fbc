{{fbdoc item="title" value="TYPE"}}----
Déclare un type défini par l'utilisateur.

{{fbdoc item="syntax"}}##

	**Type** //typename//
		//fieldname1// [[KeyPgAs as]] //[[DataType DataType]]//
		//fieldname2// [[KeyPgAs as]] //[[DataType DataType]]//
		...
	**End Type**

	**Type** //typename// [ [[KeyPgField Field]] = //alignment// ]
		[ [[KeyPgVisPrivate Private]]: ]
		[ [[KeyPgVisPublic Public]]: ]
		[ [[KeyPgVisProtected Protected]]: ]
		[[KeyPgDeclare declare]] [[KeyPgConstructor constructor]] [ ( [ //parameters// ] ) ]
		[[KeyPgDeclare declare]] [[KeyPgDestructor destructor]]  [ () ]
		[[KeyPgDeclare declare]] [ [[KeyPgStaticMember Static]] | [[KeyPgConstMember Const]] ] [[KeyPgMemberSub sub]] //fieldname// [//calling convention specifier//] [ [[KeyPgAlias alias]] //external_name// ] [ ( [ //parameters// ] ) ] [ [[KeyPgStatic Static]] ]
		[[KeyPgDeclare declare]] [ [[KeyPgStaticMember Static]] | [[KeyPgConstMember Const]] ] [[KeyPgMemberFunction function]] //fieldname// [//calling convention specifier//] [ [[KeyPgAlias alias]] //external_name// ] [ ( [ //parameters// ] ) ] [ [[KeyPgAs as]] [[DataType datatype]] ] [ [[KeyPgStatic Static]] ]
		//fieldname// [ ( //array subscripts// ) | : //bits// ] [[KeyPgAs as]] //[[DataType DataType]]// [ = //initializer// ]
		[[KeyPgAs as]] [[DataType DataType]] //fieldname// [ ( //array subscripts// ) | : //bits// ] [ = //initializer// ], ...
		[[KeyPgDeclare declare]] [[KeyPgOperator operator]] //operatorname//[ ( [ //parameters// ] ) ]
		[[KeyPgDeclare declare]] [[KeyPgProperty property]] //fieldname//[ ( [ //parameters// ] ) ] [ [[KeyPgAs as]] [[DataType datatype]] ]
		...
	**End Type**
##
{{fbdoc item="param"}}
	##//alignment//##
		Spécifie l'alignement d'octets pour les champs de données.
	##//fieldname//##
		Nom du champ de données ou d'un membre de procédure.
	##//external_name//##
		Nom de domaine si liens externes.
	##//parameters//##
		Les paramètres à passer à un membre de procédure.
	##//array subscripts//##
		Les indices pour déclarer un tableau de longueur fixe.
	##//bits//##
		Nombre de bits occupés par un champ de données.
	##//initializer//##
		Initialisation par défaut pour le champ de données.
	##//operatorname//##
		Le nom de l'opérateur à surcharger.
	##//calling convention specifier//##
		Peut être ##[[KeyPgCdecl Cdecl]]##, ##[[KeyPgStdcall Stdcall]]## or ##[[KeyPgPascal Pascal]]##.

{{fbdoc item="desc"}}
	##**Type**## est utilisé pour déclarer des types de données contenant un ou plusieurs bits, scalaire, tableau ou d'autres champs de ##**Type**##.

	Supporte membre de fonctions incluant ##[[KeyPgConstructor Constructor]]##, ##[[KeyPgDestructor Destructor]]##, ##[[KeyPgMemberFunction Function]]##, ##[[KeyPgOperator Operator]]##, ##[[KeyPgProperty Property]]## et ##[[KeyPgMemberSub Sub]]##.

	Les champs seront, par défaut, des membres à accès ##[[KeyPgVisPublic Public:]]## sauf si, ##[[KeyPgVisPrivate Private:]]## ou ##[[KeyPgVisProtected Protected:]]## est spécifié.

	Une ##[[KeyPgUnion Union]]## anonyme peut être imbriquée dans une déclaration de ##**Type**##.

	##[[KeyPgField Field]]=//number//## est facultatif, s'il existe, il change l'alignement par défaut des champs. ##[[KeyPgField Field]]=1## annule tout alignement, rendant le ##**Type**## contigu en mémoire. 

	##**Type**## peut être utilisé pour retourner une variable de type temporaire. Voir ##[[KeyPgTypeTemp Type()]]##.

	##**Type**## peut être utilisé pour déclarer une définition de type ( c'est à dire un alias ou un autre nom ) pour un type déjà déclaré ou qui va être déclaré.  Voir ##[[KeyPgTypeAlias Type (Alias)]]##

	Les champs de données peuvent avoir une valeur facultative ##//initializer//## par défaut.  Cette valeur par défaut initialise le champ de données immédiatement avant tout appel du constructeur.

	##[[KeyPgStaticMember Static]]## qui précède immédiatement ##[[KeyPgMemberSub Sub]]## ou ##[[KeyPgMemberFunction Function]]## indique qu'aucun paramètre caché ##[[KeyPgThis This]]## doit être transmis au membre de la procédure.

	##[[KeyPgConstMember Const]]## qui précède immédiatement ##[[KeyPgMemberSub Sub]]## ou ##[[KeyPgMemberFunction Function]]## indique que le paramètre caché ##[[KeyPgThis This]]## est à considérer comme en lecture-seulement (read-only).

	 **Avertissement:**
	Des précautions particulières doivent être prises lors de l'utilisation d'un type défini par l'utilisateur pour les entrées/sorties (I / O) fichier.  Il est recommandé d'utiliser ##Field = 1## pour de tels cas, et cela peut être nécessaire pour lire les fichiers créés par d'autres applications.
	Les types de données utilisateur qui contiennent des pointeurs vers des données ne doivent pas être écrits dans le fichier tel quel: lorsque les données sont lues plus tard, les pointeurs seront presque toujours invalides, et les données qu'ils pointaient ne seront plus disponibles.  Au lieu de cela, des routines d'entrée / sortie personnalisés doivent être utilisées, pour sauver les données allouées dans un format différent dans le fichier.  Cela inclut les types de données utilisateur contenant des chaînes de longueur variable.
	En outre, la lecture de chaînes de longueur fixe dans un type utilisateur à partir de fichiers est problématique: à l'heure actuelle, les chaînes de longueur fixe contiennent un caractère NULL supplémentaires à la fin.  Afin de préserver l'alignement le champ devra être déclaré avec un nombre de caractères inférieur à la taille réelle et l'accès au champ par son nom rendra le dernier caractère indisponible.  Cela signifie également qu'il peut y avoir des problèmes potentiels en passant la chaîne aux fonctions qui attendent d'avoir là un caractère NULL.

	Une meilleure solution consiste à utiliser des tableaux de type ##**UByte**##, cela nécessite un couple de fonctions auxiliaires de conversion ##//'vers / à partir de'//## la chaîne. Voir l'exemple.

{{fbdoc item="ex"}}
Ceci est un exemple de style QB-style, ne comprenant pas des définitions de procédure
{{fbdoc item="filename" value="examples/manual/udt/type1.bas"}}%%(freebasic)
TYPE clr
	red AS UBYTE
	green AS UBYTE
	blue AS UBYTE
END TYPE

DIM c AS clr
c.red = 255
c.green = 128
c.blue = 64
%%

Et ceci un exemple d'un type fontionnant comme un objet:
{{fbdoc item="filename" value="examples/manual/udt/type2.bas"}}%%(freebasic)
'' Example showing the problems with fixed length string fields in UDTs
'' Suppose we have read a GIF header from a file
''                        signature         width        height
dim as zstring*(10+1) z => "GIF89a" + mkshort(10) + mkshort(11)

print "Using fixed-length string"

type hdr1 field = 1
   as string*(6-1) sig /' We have to dimension the string with 1 char
	                    '  less to avoid misalignments '/
   as ushort wid, hei
end type

dim as hdr1 ptr h1 = cptr(hdr1 ptr, @z)
print h1->sig, h1->wid, h1->hei '' Prints GIF89 (misses a char!)  10  11

'' We can do comparisons only with the 5 visible chars and creating a temporary string with LEFT

if left(h1->sig, 5) = "GIF89" then print "ok" else print "error"


'' Using a ubyte array, we need an auxiliary function to convert it to a string
function ub2str( ub() as ubyte ) as string
	dim as integer length = ubound(ub) + 1
	dim as string res = space(length)
	for i as integer = 0 to length-1
	    res[i] = ub(i): next
	function = res
end function


print
print "Using an array of ubytes"

type hdr2 field = 1
   sig(0 to 6-1) as ubyte '' Dimension 6
   as ushort wid, hei
end type

dim as hdr2 ptr h2 = cptr(hdr2 ptr, @z)
'' Viewing and comparing is correct but a conversion to string is required

print ub2str(h2->sig()), h2->wid, h2->hei '' Prints GIF89a  10  11 (ok)
if ub2str(h2->sig()) = "GIF89a" then print "ok" else print "error" '' Prints ok
%%

{{fbdoc item="target"}}
	- L'alignement des champs par défaut est de 4 octets pour les cibles DOS et Linux.
	- L'alignement des champs par défaut est de 8 octets pour les cibles Windows.

{{fbdoc item="lang"}}
	- Les fonctionnalités relatives aux objets telles que les fonctions déclarées à l'intérieur de blocs ##**Type**## sont prises en charge uniquement avec le dialecte //[[CompilerOptlang -lang fb]]// depuis la version 0.17b
	- Dans les dialectes //[[CompilerOptlang -lang fb]]// et //[[CompilerOptlang -lang fblite]]//, l'alignement des champs par défaut dépend de la plate-forme cible.
	- Avec le dialecte //[[CompilerOptlang -lang qb]]// les champs sont alignés à l'octet limites par défaut, sauf indication contraire.
	- Pour forcer l'alignement octet utilisez ##FIELD=1##.

{{fbdoc item="diff"}}
	- A l'heure actuelle, les chaînes de longueur fixe ont un supplément, le caractère redondant de fin, ce qui signifie qu'elles prennent un octet supplémentaire par rapport à QB.  Pour cette raison, les types définis par l'utilisateur qui les utilisent ne sont pas compatibles avec QB lorsqu'ils les utilisent pour les Entrées / Sories de fichier.

{{fbdoc item="see"}}
	- ##[[KeyPgTypeAlias Type (Alias)]]##
	- ##[[KeyPgTypeTemp Type (Temporary)]]##
	- ##[[KeyPgUnion Union]]##
	- ##[[KeyPgEnum Enum]]##
	- ##[[KeyPgTypeof Typeof]]##
	- ##[[KeyPgOffsetof OffsetOf]]##
	- ##[[KeyPgField Field]]##
	- ##[[KeyPgWith With]]##

{{fbdoc item="back" value="CatPgUserDefTypes|User Defined Types"}}

