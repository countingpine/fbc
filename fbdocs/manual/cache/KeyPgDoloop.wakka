{{fbdoc item="title" value="DO...LOOP"}}----
D&eacute;claration de contr&ocirc;le de flux pour une boucle.

{{fbdoc item="syntax"}}##
	**Do** [ { **Until** | **While** } //condition// ]
		[ //statement block// ]
	**Loop**
//ou//
	**Do**
		[ //statement block// ]
	**Loop** [ { **Until** | **While** } //condition// ]
##
{{fbdoc item="desc"}}
	L'instruction ##**Do**## ex&eacute;cute les instructions dans le //statement block (= bloc d'instructions)// jusqu'&agrave; ce que / tandis que la //condition//, s'il y en a une,  soit vraie.

	Si ##**Until**## est utilis&eacute;, la d&eacute;claration ##**Do**## arr&ecirc;te la r&eacute;p&eacute;tition du //statement block (= bloc d'instructions)// quand //condition// devient vraie. Le mot-cl&eacute; ##**While**## a un effet contraire, il arr&ecirc;te la boucle si //condition// est vraie. Si les deux //condition// et soit ##**Until**## ou ##**While**## sont omis, l'instruction ##**Do**## boucle ind&eacute;finiment.

	Si une instruction ##[[KeyPgExit Exit]]## ##**Do**## est rencontr&eacute;e &agrave; l'int&eacute;rieur du //statement block (= bloc d'instructions)//, la boucle est termin&eacute;e, et l'ex&eacute;cution reprend imm&eacute;diatement apr&egrave;s la d&eacute;claration ##**Loop**## qui l'enferme. Si une d&eacute;claration ##[[KeyPgContinue Continue]]## ##**Do**## est rencontr&eacute;e, le reste du //statement block (= bloc d'instructions) // est ignor&eacute; et l'ex&eacute;cution reprend &agrave; l'instruction ##**Do**##.

	Dans la premi&egrave;re syntaxe, la //condition// est v&eacute;rifi&eacute;e lorsque l'instruction ##**Do**## est rencontr&eacute;e pour la premi&egrave;re fois et si la //condition// est remplie, le //statement block (= bloc d'instructions)// sera ignor&eacute;. Dans la seconde syntaxe, la //condition// est d'abord v&eacute;rifi&eacute;e //apr&egrave;s// l'ex&eacute;cution du //statement block (= bloc d'instructions)//. Cela signifie que le //statement block (= bloc d'instructions)// est toujours garanti d'&ecirc;tre ex&eacute;cut&eacute; //au moins// une fois.

	//condition// peut &ecirc;tre n'importe quelle expression valide qui a la valeur False (z&eacute;ro) ou True (non nul).

{{fbdoc item="ex"}}
	Dans cet exemple, une boucle ##**Do**## est utilis&eacute;e pour compter le nombre total de nombres impairs de 1 &agrave; 10. La boucle sera r&eacute;p&eacute;t&eacute;e //until = jusqu'&agrave;// ce que la condition //n > 10// soit remplie:
{{fbdoc item="filename" value="examples/manual/control/do-loop.bas"}}%%(freebasic)
dim as integer n = 1                            '' number to check
dim as integer total_odd = 0                    '' running total of odd numbers
do until( n > 10 )
  if( ( n MOD 2 ) > 0 ) then total_odd += 1    '' add to total if n is odd (has remainder from division by 2)
  n += 1
loop
print "total odd numbers: " ; total_odd         '' prints '5'

end 0
%%

	Ici, une boucle DO infinie est utilis&eacute;e pour compter le nombre total de nombres pairs. Nous pla&ccedil;ons le test de condition dans la boucle par l'interm&eacute;diaire de ##[[KeyPgIfthen If...Then]]##, qui fait sortir de la boucle quand //n > 10// devient vrai:
{{fbdoc item="filename" value="examples/manual/control/do-loop2.bas"}}%%(freebasic)
   dim as integer n = 1                            '' number to check
   dim as integer total_even = 0                   '' running total of even numbers
   do
	  if( n > 10 ) then exit do                    '' exit if we've scanned our 10 numbers
   
	  if( ( n MOD 2 ) = 0 ) then total_even += 1   '' add to total if n is even (no remainder from division by 2)
	  n += 1
   loop
   print "total even numbers: " ; total_even       '' prints '5'

   end 0
%%

{{fbdoc item="lang"}}
	- Dans les dialectes //[[CompilerOptlang -lang qb]]// et //[[CompilerOptlang -lang fblite]]//, les variables d&eacute;clar&eacute;es dans le bloc de la boucle DO..LOOP ont une [[ProPgVariableScope port&eacute;e]] &agrave; l'&eacute;chelle de la fonction comme dans QB.
	- Dans les dialectes //[[CompilerOptlang -lang fb]]// et //[[CompilerOptlang -lang deprecated]]//, les variables d&eacute;clar&eacute;es dans un bloc FOR..NEXT ne sont visibles que dans ce bloc et ne peut &ecirc;tre consult&eacute;es &agrave; l'ext&eacute;rieur.

{{fbdoc item="diff"}}
	- Aucune

{{fbdoc item="see"}}
	- ##[[KeyPgContinue Continue]]##
	- ##[[KeyPgExit Exit]]##
	- ##[[KeyPgFornext For...Next]]##
	- ##[[KeyPgWhilewend While...Wend]]##

{{fbdoc item="back" value="CatPgControlFlow|Control Flow"}}