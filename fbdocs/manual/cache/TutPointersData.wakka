{{fbdoc item="title" value="Pointers, Data Types and Memory"}}----
//Ecrit par [[WikiRick rdc]]//

Si vous lisez l'article [[TutPointers Introduction aux pointeurs]] vous savez que les pointeurs contiennent des adresses d'emplacements mémoire. Vous pouvez manipuler les données de ces emplacements mémoire en utilisant l'opérateur de référence *. L'utilisation de pointeurs avec un seul item de données unique n'est pas un problème, mais que faire si vous avez besoin de stocker de multiples éléments de données et de les manipuler à l'aide d'un pointeur? C'est peut être un peu plus difficile à moins de comprendre comment les données sont stockées en mémoire.

Un emplacement mémoire dans un ordinateur a une longueur de 1 octet. Assez grand pour contenir un caractère ANSI (par opposition aux caractères Unicode, qui sont des caractères larges et occupent deux octets. Nous ne discuterons pas de caractères Unicode dans cet article.) Cependant, tous les types de données n'ont pas un seul octet de longueur. Voici un programme simple qui affiche la longueur en octets de chaque type de données.

##%%(freebasic)
dim a as byte
dim b as short
dim c as integer
dim d as longint
dim au as ubyte
dim bu as ushort
dim cu as uinteger
dim du as ulongint
dim e as single
dim f as double
dim g as integer ptr
dim h as byte ptr
dim s1 as string * 10 'fixed string
dim s2 as string      'variable length string
dim s3 as zstring ptr 'zstring


s1 = "Hello World!"
s2 = "Hello World from FreeBasic!"
s3 = allocate( len( s2 ) + 1 )
*s3 = s2

print "Byte: ";len(a)
print "Short: ";len(b)
print "Integer: ";len(c)
print "Longint: ";len(d)
print "UByte: ";len(au)
print "UShort: ";len(bu)
print "UInteger: ";len(cu)
print "ULongint: ";len(du)
print "Single: ";len(e)
print "Double: ";len(f)
print "Integer Pointer: ";len(g)
print "Byte Pointer: ";len(h)
print "Fixed String: ";len(s1)
print "Variable String: ";len(s2)
print "ZString: ";len(*s3)

deallocate s3

sleep
%%##

Affiche à l'écran:

##%%(freebasic)
Byte:  1
Short:  2
Integer:  4
Longint:  8
UByte:  1
UShort:  2
UInteger:  4
ULongint:  8
Single:  4
Double:  8
Integer Pointer:  4
Byte Pointer:  4
Fixed String:  10
Variable String:  27
ZString:  27
%%##

Notez que la longueur d'un pointeur est toujours de 4 octets (la même que celle d'un entier), indépendamment des données pointées, puisque un pointeur contient une adresse mémoire et non les données.

En regardant la longueur des différents types de données, vous voyez que pour [[KeyPgAllocate allocate]] suffisamment d'espace pour 10 entiers, il faut 40 octets de mémoire. Chaque entier prend 4 octets. Donc la question est, comment accéder à chaque valeur entière de la mémoire tampon? La réponse, l'arithmétique des pointeurs. Jetez un oeil au programme suivant.

##%%(freebasic)
option explicit

dim a as integer
dim aptr as integer ptr

'Allocate enough space for 2 integers
aptr = allocate(len(a) * 2)
'Load our first integer
*aptr = 1
print "Int #1: ";*aptr
'Move the pointer to the next integer position
'aptr + 4
*(aptr + 4) = 2
print "Int #2: ";*(aptr + 4)

deallocate aptr
sleep
end
%%##

Dans ce programme nous dimensionnons deux variables, un [[KeyPgInteger integer]] et un [[KeyPgInteger integer]] [[KeyPgPointer pointer]], aptr. Aptr pointera sur notre tampon mémoire qui contiendra deux entiers. La fonction [[KeyPgAllocate allocate]] requiert la taille du tampon mémoire dont nous avons besoin, donc nous multiplions la taille d'un [[KeyPgInteger integer]] par 2 pour réserver 8 octets de mémoire (chaque entier prendra 4 octets d'espace). 

Après le processus d'allocation, aptr contient l'adresse du premier octet de notre tampon mémoire. Stocker le premier entier consiste tout simplement à utiliser la référence de l'opérateur et de lui donner la valeur à 1. Pour afficher sa valeur, nous utilisons simplement *aptr.

Maintenant, laissez-moi vous poser une question: Comment le compilateur sait que la valeur 1 requiert 4 octets, et non pas 1 ou 2 octets? Parce que nous avons dimensionné aptr comme un //integer ptr//. Le compilateur sait qu'un entier occupe 4 octets et donc il charge les données dans quatre octets de mémoire. C'est pourquoi, lorsque nous affichons la valeur nous obtenons 1 et non pas un nombre étrange.

Pour charger la deuxième valeur dans notre tampon, nous utilisons:

##%%(freebasic)
*(aptr + 4) = 2
%%##

Cela peut paraître un peu étrange au premier abord. Aptr pointe sur le premier octet dans notre tampon mémoire. Un entier occupe 4 octets, donc pour arriver à la position de l'octet entier suivant, il faut ajouter 4 à aptr. Nous avons besoin de parenthèses autour de l'opération d'addition, car l'opérateur de référence * a une priorité supérieure à +. Les parenthèses nous assurent que nous effectuons l'opération d'addition en premier et qu'ensuite nous appliquons l'opérateur d'indirection.

Notez que nous n'avons pas incrémenter aptr directement. Si nous l'avions fait, aptr pointerait plus vers le début du tampon mémoire et le programme planterait quand on désallouerait le tampon, car [[KeyPgDeallocate deallocate]] s'effectuerait en-dehors du tampon mémoire. Si le besoin se faisait sentir d' incrémenter directement un pointeur, alors il faudrait créer une variable pointeur temporaire et l'incrémenter, plutôt que le pointeur utilisé dans l'allocation initiale. 

Les tampons mémoire et les pointeurs sont un moyen puissant pour stocker et manipuler des données en mémoire. Des précautions doivent être prises pour s'assurer que vous accédez correctement aux données en fonction du type de données stockées dans le tampon mémoire.