{{fbdoc item="title" value="Pointers, Data Types and Memory"}}----
//Ecrit par [[WikiRick rdc]]//

Si vous lisez l'article [[TutPointers Introduction aux pointeurs]] vous savez que les pointeurs contiennent des adresses d'emplacements m&eacute;moire. Vous pouvez manipuler les donn&eacute;es de ces emplacements m&eacute;moire en utilisant l'op&eacute;rateur de r&eacute;f&eacute;rence *. L'utilisation de pointeurs avec un seul item de donn&eacute;es unique n'est pas un probl&egrave;me, mais que faire si vous avez besoin de stocker de multiples &eacute;l&eacute;ments de donn&eacute;es et de les manipuler &agrave; l'aide d'un pointeur? C'est peut &ecirc;tre un peu plus difficile &agrave; moins de comprendre comment les donn&eacute;es sont stock&eacute;es en m&eacute;moire.

Un emplacement m&eacute;moire dans un ordinateur a une longueur de 1 octet. Assez grand pour contenir un caract&egrave;re ANSI (par opposition aux caract&egrave;res Unicode, qui sont des caract&egrave;res larges et occupent deux octets. Nous ne discuterons pas de caract&egrave;res Unicode dans cet article.) Cependant, tous les types de donn&eacute;es n'ont pas un seul octet de longueur. Voici un programme simple qui affiche la longueur en octets de chaque type de donn&eacute;es.

##%%(freebasic)
dim a as byte
dim b as short
dim c as integer
dim d as longint
dim au as ubyte
dim bu as ushort
dim cu as uinteger
dim du as ulongint
dim e as single
dim f as double
dim g as integer ptr
dim h as byte ptr
dim s1 as string * 10 'fixed string
dim s2 as string      'variable length string
dim s3 as zstring ptr 'zstring


s1 = "Hello World!"
s2 = "Hello World from FreeBasic!"
s3 = allocate( len( s2 ) + 1 )
*s3 = s2

print "Byte: ";len(a)
print "Short: ";len(b)
print "Integer: ";len(c)
print "Longint: ";len(d)
print "UByte: ";len(au)
print "UShort: ";len(bu)
print "UInteger: ";len(cu)
print "ULongint: ";len(du)
print "Single: ";len(e)
print "Double: ";len(f)
print "Integer Pointer: ";len(g)
print "Byte Pointer: ";len(h)
print "Fixed String: ";len(s1)
print "Variable String: ";len(s2)
print "ZString: ";len(*s3)

deallocate s3

sleep
%%

##

Affiche &agrave; l'&eacute;cran:
##%%(freebasic)
Byte:  1
Short:  2
Integer:  4
LongInt:  8
UByte:  1
UShort:  2
UInteger:  4
ULongInt:  8
Single:  4
Double:  8
Integer Pointer:  4
Byte Pointer:  4
Fixed String:  10
Variable String:  27
ZString:  27

%%

##

Notez que la longueur d'un pointeur est toujours de 4 octets (la m&ecirc;me que celle d'un entier), ind&eacute;pendamment des donn&eacute;es point&eacute;es, puisque un pointeur contient une adresse m&eacute;moire et non les donn&eacute;es.
En regardant la longueur des diff&eacute;rents types de donn&eacute;es, vous voyez que pour [[KeyPgAllocate Allocate]] suffisamment d'espace pour 10 entiers, il faut 40 octets de m&eacute;moire. Chaque entier prend 4 octets. Donc la question est, comment acc&eacute;der &agrave; chaque valeur enti&egrave;re de la m&eacute;moire tampon? La r&eacute;ponse, l'arithm&eacute;tique des pointeurs. Jetez un oeil au programme suivant.

##%%(freebasic)
Option Explicit

Dim a As Integer
Dim aptr As Integer Ptr
'Allocate enough space for 2 integers
aptr = Allocate(Len(a) * 2)
'Load our first integer
*aptr = 1
Print "Int #1: ";*aptr
'Move the pointer to the next integer position
'aptr + 4

*(aptr + 4) = 2
Print "Int #2: ";*(aptr + 4)
Deallocate aptr
Sleep

End

%%

##

Dans ce programme nous dimensionnons deux variables, un [[KeyPgInteger Integer]] et un [[KeyPgInteger Integer]] [[KeyPgPointer Pointer]], aptr. Aptr pointera sur notre tampon m&eacute;moire qui contiendra deux entiers. La fonction [[KeyPgAllocate Allocate]] requiert la taille du tampon m&eacute;moire dont nous avons besoin, donc nous multiplions la taille d'un [[KeyPgInteger Integer]] par 2 pour r&eacute;server 8 octets de m&eacute;moire (chaque entier prendra 4 octets d'espace). 

Apr&egrave;s le processus d'allocation, aptr contient l'adresse du premier octet de notre tampon m&eacute;moire. Stocker le premier entier consiste tout simplement &agrave; utiliser la r&eacute;f&eacute;rence de l'op&eacute;rateur et de lui donner la valeur &agrave; 1. Pour afficher sa valeur, nous utilisons simplement *aptr.
Maintenant, laissez-moi vous poser une question: Comment le compilateur sait que la valeur 1 requiert 4 octets, et non pas 1 ou 2 octets? Parce que nous avons dimensionn&eacute; aptr comme un //integer ptr//. Le compilateur sait qu'un entier occupe 4 octets et donc il charge les donn&eacute;es dans quatre octets de m&eacute;moire. C'est pourquoi, lorsque nous affichons la valeur nous obtenons 1 et non pas un nombre &eacute;trange.
Pour charger la deuxi&egrave;me valeur dans notre tampon, nous utilisons:

##%%(freebasic)

*(aptr + 4) = 2

%%