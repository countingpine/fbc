{{fbdoc item="title" value="CONDCREATE"}}----
Crée une variable conditionnelle pour l'utiliser dans la synchronisation des "threads"

{{fbdoc item="syntax"}}##
	[[KeyPgDeclare declare]] [[KeyPgFunction function]] **Condcreate** ( ) [[KeyPgAs as]] [[KeyPgAny any]] [[KeyPgPtr ptr]]
##
{{fbdoc item="usage"}}##
	//result// = **Condcreate**
##
{{fbdoc item="ret"}}
	Un "handle" vers une nouvelle variable conditionnelle, ou le pointeur nul (0) en cas d'échec.

{{fbdoc item="desc"}}
	Une fois que le conditionnel est ##[[KeyPgCondCreate CondCreate]]## et les "threads" démarrés, l'un (ou plusieurs) d'entre eux peut être fixé à ##[[KeyPgCondWait Condwait]]## pour le conditionnel, ils seront arrêtés jusqu'à un autre "thread" ##[[KeyPgCondSignal Condsignal]]## que le "thread" en attente puisse redémarrer. ##[[KeyPgCondBroadcast Condbroadcast]]## peut être utilisé pour redémarrer tous les "threads" qui attendent le conditionnel. A la fin du programme ##[[KeyPgCondDestroy Conddestroy]]## doit être utilisé pour éviter les fuites de ressources dans le système d'exploitation.

{{fbdoc item="ex"}}
{{fbdoc item="filename" value="examples/manual/threads/condcreate.bas"}}%%(freebasic)
''
'' make newly-created threads wait until all threads are ready, then start them all at once
''

dim shared hcondstart as any ptr
dim shared hmutexstart as any ptr
dim shared start as integer = 0

dim shared threadcount as integer
dim shared hmutexready as any ptr
dim shared hcondready as any ptr

sub mythread(byval id_ptr as any ptr)
	dim id as integer = cast(integer, id_ptr)

	print "Thread #" & id & " is waiting..."

	'' signal that this thread is ready
	mutexlock hmutexready
	threadcount += 1
	condsignal hcondready
	mutexunlock hmutexready
	
	'' wait for the start signal
	Mutexlock hmutexstart
	do while start = 0	
		Condwait hcondstart, hmutexstart
	loop

	'' now this thread holds the lock on hmutexstart
	
	Mutexunlock hmutexstart

	'' print out the number of this thread
	for i as integer = 1 to 40
		print id;
	next i
end sub

dim threads(1 to 9) as any ptr

hcondstart = condcreate()
hmutexstart = mutexcreate()

hcondready = condcreate()
hmutexready = mutexcreate()

threadcount = 0


for i as integer = 1 to 9
	threads(i) = ThreadCreate(@mythread, cast(any ptr, i))
	if threads(i) = 0 then
		print "unable to create thread"
	end if
next i

print "Waiting until all threads are ready..."

mutexlock(hmutexready)
do until threadcount = 9
	condwait(hcondready, hmutexready)
loop
mutexunlock(hmutexready)

print "Go!"

mutexlock hmutexstart
start = 1
condbroadcast hcondstart
mutexunlock hmutexstart

'' wait for all threads to complete
for i as integer = 1 to 9
	if threads(i) <> 0 then
		threadwait threads(i)
	end if
next i

mutexdestroy hmutexready
conddestroy hcondready

mutexdestroy hmutexstart
conddestroy hcondstart
%%

{{fbdoc item="target"}}
	- **Condcreate** n'est pas utilisable avec la version/cible DOStarget de FreeBASIC, parce que le "multithreading" n'est pas supporté par le noyau DOS, ni l'extension utilisée.

{{fbdoc item="lang"}}
	- "Threading" n'est pas utilisable dans le dialecte //[[CompilerOptlang -lang qb]]//

{{fbdoc item="diff"}}
	- Nouveau pour ""FreeBASIC""

{{fbdoc item="see"}}
	- ##[[KeyPgCondBroadcast Condbroadcast]]##
	- ##[[KeyPgCondDestroy Conddestroy]]##
	- ##[[KeyPgCondSignal Condsignal]]##
	- ##[[KeyPgCondWait Condwait]]##
	- ##[[KeyPgMutexCreate Mutexcreate]]##
	- ##[[KeyPgMutexLock Mutexlock]]##
	- ##[[KeyPgMutexUnlock Mutexunlock]]##
	- ##[[KeyPgThreadCreate Threadcreate]]##

{{fbdoc item="back" value="CatPgThreading|Threading Support Functions"}}

