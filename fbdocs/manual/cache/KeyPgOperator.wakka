{{fbdoc item="title" value="OPERATOR"}}----
D&eacute;clare ou d&eacute;finit un op&eacute;rateur surcharg&eacute;.

{{fbdoc item="syntax"}}##
	{ [[KeyPgType Type]] | [[KeyPgClass Class]] | [[KeyPgUnion Union]] | [[KeyPgEnum Enum]] } //typename//
		[[KeyPgDeclare declare]] **Operator** [[KeyPgCast cast]] () [[KeyPgAs as]] [[DataType datatype]]
		[[KeyPgDeclare declare]] **Operator** //assignment_op// ( [ [[KeyPgByref byref]] | [[KeyPgByval byval]] ] //rhs// [[KeyPgAs as]] [[DataType datatype]] )
		[[KeyPgDeclare declare]] **Operator** [[KeyPgOpNew new]] ( //size// [[KeyPgAs as]] [[KeyPgUinteger uinteger]] ) [[KeyPgAs as]] [[KeyPgAny any]] [[KeyPgPtr ptr]]
		[[KeyPgDeclare declare]] [[KeyPgStaticMember static]] **Operator** [[KeyPgOpNew new]][] ( //size// [[KeyPgAs as]] [[KeyPgUinteger uinteger]] ) [[KeyPgAs as]] [[KeyPgAny any]] [[KeyPgPtr ptr]]
		[[KeyPgDeclare declare]] **Operator** [[KeyPgOpDelete delete]] ( //buf//  [[KeyPgAs as]] [[KeyPgAny any]] [[KeyPgPtr ptr]] )
		[[KeyPgDeclare declare]] [[KeyPgStaticMember static]] **Operator** [[KeyPgOpDelete delete]][] ( //buf//  [[KeyPgAs as]] [[KeyPgAny any]] [[KeyPgPtr ptr]] )
	End { [[KeyPgType Type]] | [[KeyPgClass Class]] | [[KeyPgUnion Union]] | [[KeyPgEnum Enum]] }

	{ [[KeyPgType Type]] | [[KeyPgClass Class]] | [[KeyPgUnion Union]] } //typename//
		[[KeyPgDeclare declare]] **Operator** [[KeyPgOpFor For]] ()
		[[KeyPgDeclare declare]] **Operator** [[KeyPgOpFor For]] ( [ [[KeyPgByref byref]] | [[KeyPgByval byval]] ] //stp// [[KeyPgAs as]] //typename// )
		[[KeyPgDeclare declare]] **Operator** [[KeyPgOpStep Step]] ()
		[[KeyPgDeclare declare]] **Operator** [[KeyPgOpStep Step]] ( [ [[KeyPgByref byref]] | [[KeyPgByval byval]] ] //stp// [[KeyPgAs as]] //typename// )
		[[KeyPgDeclare declare]] **Operator** [[KeyPgOpNext Next]] ( [ [[KeyPgByref byref]] | [[KeyPgByval byval]] ] //cond// [[KeyPgAs as]] //typename// ) [[KeyPgAs as]] [[KeyPgInteger Integer]]
		[[KeyPgDeclare declare]] **Operator** [[KeyPgOpNext Next]] ( [ [[KeyPgByref byref]] | [[KeyPgByval byval]] ] //cond// [[KeyPgAs as]] //typename//, [ [[KeyPgByref byref]] | [[KeyPgByval byval]] ] //stp// [[KeyPgAs as]] //typename// ) [[KeyPgAs as]] [[KeyPgInteger Integer]]
	End { [[KeyPgType Type]] | [[KeyPgClass Class]] | [[KeyPgUnion Union]] }

	[[KeyPgDeclare declare]] **Operator** //unary_op// ( [ [[KeyPgByref byref]] | [[KeyPgByval byval]] ] //rhs// [[KeyPgAs as]] [[DataType datatype]] ) [[KeyPgAs as]] [[DataType datatype]]
	[[KeyPgDeclare declare]] **Operator** //binary_op// ( [ [[KeyPgByref byref]] | [[KeyPgByval byval]] ] //lhs// [[KeyPgAs as]] [[DataType datatype]], [ [[KeyPgByref byref]] | [[KeyPgByval byval]] ] //rhs// [[KeyPgAs as]] [[DataType datatype]] ) [[KeyPgAs as]] [[DataType datatype]]

	**Operator** //typename//.[[KeyPgCast cast]] () [[KeyPgAs as]] [[DataType datatype]]
	**Operator** //typename//.//assignment_op// ( [ [[KeyPgByref byref]] | [[KeyPgByval byval]] ] //rhs// [[KeyPgAs as]] [[DataType datatype]] )
	**Operator** //unary_op// ( [ [[KeyPgByref byref]] | [[KeyPgByval byval]] ] //rhs// [[KeyPgAs as]] [[DataType datatype]] ) [[KeyPgAs as]] [[DataType datatype]]
	**Operator** //binary_op// ( [ [[KeyPgByref byref]] | [[KeyPgByval byval]] ] //lhs// [[KeyPgAs as]] [[DataType datatype]], [ [[KeyPgByref byref]] | [[KeyPgByval byval]] ] //rhs// [[KeyPgAs as]] [[DataType datatype]] ) [[KeyPgAs as]] [[DataType datatype]]
	**Operator** //typename//.[[KeyPgOpNew new]] ( //size// as uinteger ) [[KeyPgAs as]] [[KeyPgAny any]] [[KeyPgPtr ptr]]
	[[KeyPgStaticMember static]] **Operator** //typename//.[[KeyPgOpNew new]][] ( //size// [[KeyPgAs as]] [[KeyPgUinteger uinteger]] ) [[KeyPgAs as]] [[KeyPgAny any]] [[KeyPgPtr ptr]]
	**Operator** //typename//.[[KeyPgOpDelete delete]] ( //buf//  [[KeyPgAs as]] [[KeyPgAny any]] [[KeyPgPtr ptr]] )
	[[KeyPgStaticMember static]] **Operator** //typename//.[[KeyPgOpDelete delete]][] ( //buf//  [[KeyPgAs as]] [[KeyPgAny any]] [[KeyPgPtr ptr]] )
##
{{fbdoc item="param"}}
	##//typename//## 
		Nom de ##[[KeyPgType Type]]##, ##[[KeyPgClass Class]]##, ##[[KeyPgUnion Union]]## ou ##[[KeyPgEnum Enum]]##.
	##//assignment_op//## 
		##let += -= *= /= \= mod= shl= shr= and= or= xor= imp= eqv= ^=##
	##//unary_op//##
		##- not @ * -> abs sgn fix frac int exp log sin asin cos acos tan atn##
	##//binary_op//##
		##+ - * / \ mod shl shr and or xor imp eqv ^ = <> < > <= >= andalso orelse##

{{fbdoc item="desc"}}
	Les op&eacute;rateurs int&eacute;gr&eacute;s comme ##=##, ##+## et ##cast## ont des comportements pr&eacute;d&eacute;finis lorsqu'ils sont utilis&eacute;s dans des expressions.  Ces op&eacute;rateurs peuvent &ecirc;tre surcharg&eacute;s pour faire autre chose que ces op&eacute;rations pr&eacute;d&eacute;finies lorsqu'au moins l'un des arguments de l'op&eacute;rateur est un type de donn&eacute;es ##[[KeyPgType Type]]##, ##[[KeyPgClass Class]]##, ##[[KeyPgEnum Enum]]## ou ##[[KeyPgUnion Union]]##.

	Les op&eacute;rateurs sont juste des fonctions.  L'op&eacute;rateur '+' a les fonctionnalit&eacute;s de la fonction ##Function Plus( A as DataType, B as DataType ) as DataType##.  Voir //[[ProPgOperatorOverloading Surcharge d'op&eacute;rateur]]// pour plus d'informations.  Les op&eacute;rateurs peuvent &ecirc;tre surcharg&eacute;s  pour accepter diff&eacute;rents types de donn&eacute;es en tant que param&egrave;tres.  Seul l'op&eacute;rateur ##[[KeyPgCast Cast]]## peut &ecirc;tre surcharg&eacute; pour retourner diff&eacute;rents types.

	Les membres op&eacute;rateur non-statiques sont d&eacute;clar&eacute;s &agrave; l'int&eacute;rieur de ##[[KeyPgType Type]]## ou ##[[KeyPgClass Class]]##.  Les op&eacute;rateurs globaux sont d&eacute;clar&eacute;s en dehors.  Toutes les d&eacute;finitions de l'op&eacute;rateur (corps de proc&eacute;dure) doivent appara&icirc;tre en dehors.

	##**Let**##, ##**Cast**## et autres op&eacute;rateurs d'affectation doivent &ecirc;tre d&eacute;clar&eacute;s &agrave; l'int&eacute;rieur de ##[[KeyPgType Type]]## ou ##[[KeyPgClass Class]]##.  Ils transmettent un param&egrave;tre cach&eacute; ##[[KeyPgThis This]]## et ont une valeur de retour du m&ecirc;me type de donn&eacute;es que le ##[[KeyPgType Type]]## ou la ##[[KeyPgClass Class]]## o&ugrave; ils ont &eacute;t&eacute; d&eacute;clar&eacute;s.

	Les op&eacute;rateurs unaires doit &ecirc;tre d&eacute;clar&eacute;s en dehors de ##[[KeyPgType Type]]##, ##[[KeyPgClass Class]]## ou ##[[KeyPgEnum Enum]]## et ont un type de donn&eacute;es de retour d&eacute;clar&eacute; explicitement.  Les op&eacute;rateurs unaires peuvent &ecirc;tre surcharg&eacute;s pour retourner tout type valide de donn&eacute;es, sauf pour ##[[KeyPgOpPtrMemberAccess Operator -> (Pointeur vers Acc&egrave;s membre)]]## qui doit retourner un type de donn&eacute;es ##[[KeyPgType Type]]## ou ##[[KeyPgClass Class]]##.

	Les op&eacute;rateurs binaires doivent &ecirc;tre d&eacute;clar&eacute;s en dehors de ##[[KeyPgType Type]]##, ##[[KeyPgClass Class]]## ou ##[[KeyPgEnum Enum]]## et ont un type de donn&eacute;es de retour explicitement d&eacute;clar&eacute;.  Les op&eacute;rateurs binaires peuvent &ecirc;tre surcharg&eacute;s avec des types valides de donn&eacute;es, sauf pour les op&eacute;rateurs relationnels, qui doivent retourner ##[[KeyPgInteger Integer]]##.

	##[[KeyPgLet Let]]## se r&eacute;f&egrave;re &agrave; l'op&eacute;rateur d'affectation, comme dans ##LET a=b##. Le mot-cl&eacute; ##[[KeyPgLet Let]]## est omis dans la pratique courante et n'est pas autoris&eacute; en dialecte //[[CompilerOptlang -lang fb]]//.  Toutefois, ##[[KeyPgOpLetlist Let()]]## peut &ecirc;tre utilis&eacute; pour affecter des champs d'un type de donn&eacute;es utilisateur &agrave; des variables multiples.

	Voir ##[[KeyPgOpFor For]]##, ##[[KeyPgOpStep Step]]## et ##[[KeyPgOpNext Next]]## pour plus d'informations sur la surcharge de la d&eacute;claration ##[[KeyPgFornext For..Next]]## pour une utilisation avec des types d&eacute;finis par l'utilisateur.

{{fbdoc item="ex"}}
{{fbdoc item="filename" value="examples/manual/udt/operator.bas"}}%%(freebasic)
Type Vector2D
  As Single x, y

  '' Return a string containing the vector data.
  Declare Operator Cast() As String
End Type

'' Allow two vectors to be able to be added together.
Declare Operator + ( ByRef lhs As Vector2D, ByRef rhs As Vector2D ) As Vector2D

Operator Vector2D.cast () As String
  Return "(" + Str(x) + ", " + Str(y) + ")"
End Operator

Operator + ( ByRef lhs As Vector2D, ByRef rhs As Vector2D ) As Vector2D
  Return type<Vector2D>( lhs.x + rhs.x, lhs.y + rhs.y )
End Operator

Dim a As Vector2D = type<Vector2D>( 1.2, 3.4 )
Dim b As Vector2D = type<Vector2D>( 8.9, 6.7 )

Print "a = "; a
Print "b = "; b
Print "a + b = "; a + b
%%
{{fbdoc item="lang"}}
	- Disponible seulement dans le dialecte //[[CompilerOptlang -lang fb]]//.

{{fbdoc item="see"}}
	- ##[[KeyPgClass Class]]##
	- ##[[KeyPgClass Enum]]##
	- ##[[KeyPgType Type]]##

{{fbdoc item="back" value="CatPgUserDefTypes|User Defined Types"}}