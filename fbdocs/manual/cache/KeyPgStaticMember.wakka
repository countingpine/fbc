{{fbdoc item="title" value="STATIC (Member)"}}----
Spécificateur de déclaration de membre statique d'une procédure.

{{fbdoc item="syntax"}}##
	[[KeyPgType Type]] //typename//
		[[KeyPgDeclare declare]] **Static** //membertype// //membername// ...
	End Type
##
{{fbdoc item="param"}}
	##//typename//##
		nom d'un type de données défini par l'utilisateur			
	##//membertype//##
		##[[KeyPgMemberSub Sub]]## ou ##[[KeyPgMemberFunction Function]]##.
	##//membername// ...##
		Nom du membre à déclarer ou définir avec la liste de paramètres ou valeur de retour qui suit.

{{fbdoc item="desc"}}
	Lors de la déclaration d'un membre de procédure, ##**Static**## indique que le membre de la procédure n'a pas une instance d'argument implicite qui lui est passée, et par conséquent ne peut accéder qu'aux valeurs qui lui sont passées. Les membres statiques des procédures peuvent accéder aux membres "Private" ou "Protected" dans leur type, mais pour appeler les procédures vous devez passer l'Object comme un premier paramètre additionnel. Vous pouvez appeler une procédure membre statique n'importe où dans votre code, tout comme n'importe quelle autre procédure dans un type, à savoir //variable of the type//.//static procedure name//(//arguments//). L'adresse d'une fonction membre statique peut également être affectée à un pointeur de fonction en utilisant l'utilisation standard [[KeyPgOpProcptr ProcPtr()]] ou [[KeyPgOpAt @ Operator]]. 

{{fbdoc item="ex"}}
{{fbdoc item="filename" value="examples/manual/udt/static.bas"}}%%(freebasic)
'' Example showing how the actual procedure invoked by a member can be set at runtime.
'' using static member procedures.
type Object

  enum handlertype
	ht_default
	ht_A
	ht_B
  end enum

  declare constructor( byval ht as handlertype = ht_default)

  declare sub handler()

private:
  declare static sub handler_default( byref obj as Object )
  declare static sub handler_A( byref obj as Object )
  declare static sub handler_B( byref obj as Object )
  handler_func as sub( byref obj as Object )

end type

constructor Object( byval ht as handlertype )
  select case ht
  case ht_A
	handler_func = @Object.handler_A
  case ht_B
	handler_func = @Object.handler_B
  case else
	handler_func = @Object.handler_default
  end select
end constructor

sub Object.handler()
  handler_func(this)
end sub

sub Object.handler_default( byref obj as Object )
  print "Handling using default method"
end sub

sub Object.handler_A( byref obj as Object )
  print "Handling using method A"
end sub

sub Object.handler_B( byref obj as Object )
  print "Handling using method B"
end sub

dim objects(1 to 4) as Object => _
  { _
	Object.handlertype.ht_B, _
	Object.handlertype.ht_default, _
	Object.handlertype.ht_A _
  }
  '' 4th array item will be Object.handlertype.ht_default

for i as integer = 1 to 4
  print i,
  objects(i).handler()
next i
%%

{{fbdoc item="diff"}}
	- Nouveau pour ""FreeBASIC""

{{fbdoc item="see"}}
	- ##[[KeyPgClass Class]]##
	- ##[[KeyPgDeclare Declare]]##
	- ##[[KeyPgType Type]]##
	- ##[[KeyPgStatic Static]]##

{{fbdoc item="back" value="CatPgProcedures|Procedures"}}{{fbdoc item="back" value="CatPgUserDefTypes|User Defined Types"}}