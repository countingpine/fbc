{{fbdoc item="title" value="STATIC (Member)"}}----
Sp&eacute;cificateur de d&eacute;claration de membre statique d'une proc&eacute;dure.

{{fbdoc item="syntax"}}##
	[[KeyPgType Type]] //typename//
		[[KeyPgDeclare declare]] **Static** //membertype// //membername// ...
	End Type
##
{{fbdoc item="param"}}
	##//typename//##
		nom d'un type de donn&eacute;es d&eacute;fini par l'utilisateur
	##//membertype//##
		##[[KeyPgMemberSub Sub]]## ou ##[[KeyPgMemberFunction Function]]##.
	##//membername// ...##
		Nom du membre &agrave; d&eacute;clarer ou d&eacute;finir avec la liste de param&egrave;tres ou valeur de retour qui suit.

{{fbdoc item="desc"}}
	Lors de la d&eacute;claration d'un membre de proc&eacute;dure, ##**Static**## indique que le membre de la proc&eacute;dure n'a pas une instance d'argument implicite qui lui est pass&eacute;e, et par cons&eacute;quent ne peut acc&eacute;der qu'aux valeurs qui lui sont pass&eacute;es. Les membres statiques des proc&eacute;dures peuvent acc&eacute;der aux membres "Private" ou "Protected" dans leur type, mais pour appeler les proc&eacute;dures vous devez passer l'Object comme un premier param&egrave;tre additionnel. Vous pouvez appeler une proc&eacute;dure membre statique n'importe o&ugrave; dans votre code, tout comme n'importe quelle autre proc&eacute;dure dans un type, &agrave; savoir //variable of the type//.//static procedure name//(//arguments//). L'adresse d'une fonction membre statique peut &eacute;galement &ecirc;tre affect&eacute;e &agrave; un pointeur de fonction en utilisant l'utilisation standard [[KeyPgOpProcptr Procptr()]] ou [[KeyPgOpAt @ Operator]]. 

{{fbdoc item="ex"}}
{{fbdoc item="filename" value="examples/manual/udt/static.bas"}}%%(freebasic)
'' Example showing how the actual procedure invoked by a member can be set at runtime.
'' using static member procedures.
type Object

  enum handlertype
	ht_default
	ht_A
	ht_B
  end enum

  declare constructor( byval ht as handlertype = ht_default)

  declare sub handler()

private:
  declare static sub handler_default( byref obj as Object )
  declare static sub handler_A( byref obj as Object )
  declare static sub handler_B( byref obj as Object )
  handler_func as sub( byref obj as Object )

end type

constructor Object( byval ht as handlertype )
  select case ht
  case ht_A
	handler_func = @Object.handler_A
  case ht_B
	handler_func = @Object.handler_B
  case else
	handler_func = @Object.handler_default
  end select
end constructor

sub Object.handler()
  handler_func(this)
end sub

sub Object.handler_default( byref obj as Object )
  print "Handling using default method"
end sub

sub Object.handler_A( byref obj as Object )
  print "Handling using method A"
end sub

sub Object.handler_B( byref obj as Object )
  print "Handling using method B"
end sub

dim objects(1 to 4) as Object => _
  { _
	Object.handlertype.ht_B, _
	Object.handlertype.ht_default, _
	Object.handlertype.ht_A _
  }
  '' 4th array item will be Object.handlertype.ht_default

for i as integer = 1 to 4
  print i,
  objects(i).handler()
next i
%%

{{fbdoc item="diff"}}
	- Nouveau pour FreeBASIC

{{fbdoc item="see"}}
	- ##[[KeyPgClass Class]]##
	- ##[[KeyPgDeclare Declare]]##
	- ##[[KeyPgType Type]]##
	- ##[[KeyPgStatic Static]]##

{{fbdoc item="back" value="CatPgProcedures|Procedures"}}{{fbdoc item="back" value="CatPgUserDefTypes|User Defined Types"}}