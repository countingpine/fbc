{{fbdoc item="title" value="GET (File I/O)"}}----
Lit les donn&eacute;es d'un fichier vers un tampon

{{fbdoc item="syntax"}}##
	**Get** #//filenum// [[KeyPgAs As]] [[KeyPgInteger Integer]], [//position// [[KeyPgAs As]] [[KeyPgLongint longint]]], [[KeyPgByref ByRef]] //data// [[KeyPgAs As]] [[KeyPgAny Any]] [, [//amount// [[KeyPgAs As]] [[KeyPgInteger Integer]]] [, [[KeyPgByref ByRef]] //bytesread// [[KeyPgAs As]] [[KeyPgUinteger Uinteger]]] ]
	**Get** #//filenum// [[KeyPgAs As]] [[KeyPgInteger Integer]], [//position// [[KeyPgAs As]] [[KeyPgLongint longint]]], //data// [[KeyPgAs As]] [[KeyPgString String]] [, , [[KeyPgByref ByRef]] //bytesread// [[KeyPgAs As]] [[KeyPgUinteger Uinteger]] ]
	**Get** #//filenum// [[KeyPgAs As]] [[KeyPgInteger Integer]], [//position// [[KeyPgAs As]] [[KeyPgLongint longint]]], //data()// [[KeyPgAs As]] [[KeyPgAny Any]] [, , [[KeyPgByref ByRef]] //bytesread// [[KeyPgAs As]] [[KeyPgUinteger Uinteger]] ]
##
{{fbdoc item="usage"}}##
	**Get** #//filenum//, //position//, //data// [, [//amount//] [, //bytesread// ] ]
	varres = **Get** (#//filenum//, //position//, //data// [, [//amount//] [, //bytesread// ] ] )
##
{{fbdoc item="param"}}
	##//filenum//##
		La valeur pass&eacute;e &agrave; ##[[KeyPgOpen Open]]## quand le fichier a &eacute;t&eacute; ouvert.
	##//position//##
		La position o&ugrave; la lecture doit commencer. Si le fichier a &eacute;t&eacute; ouvert ##[[KeyPgRandom For Random]]##, la position est en enregistrements; autrement, elle est en octets. Si omise, la lecture commence &agrave; la position actuelle du pointeur.  La position est bas&eacute;e sur 1: c'est &agrave; dire que le premier enregistrement ou octet est &agrave; la position ##1##.
		Si ##//position//## est omise ou z&eacute;ro (##0##), la lecture du fichier commencera &agrave; la position courante dans le fichier.
	##//data//##
		Le tampon o&ugrave; les donn&eacute;es sont &eacute;crites. Il peut &ecirc;tre une variable num&eacute;rique, une cha&icirc;ne, un tableau, un type d&eacute;fini par l'utilisateur ou un pointeur d&eacute;r&eacute;f&eacute;renc&eacute;. L'op&eacute;ration de lecture va essayer de remplir compl&egrave;tement la variable, &agrave; moins que ##[[KeyPgEof EOF]]## ne soit atteint.
		Lors de l'utilisation de tableaux, ##//data//## doit &ecirc;tre suivi par une paire de parenth&egrave;ses vides: "##()##".  ##**Get**## lira les donn&eacute;es pour toutes les valeurs dans le tableau.  ##//amount//## (quantit&eacute;) n'est pas autoris&eacute;.
		Lors de l'utilisation de ##[[KeyPgString String]]##s, le nombre d'octets lus est le m&ecirc;me que le nombre d'octets dans les donn&eacute;es de cha&icirc;ne. ##//amount//## (quantit&eacute;) n'est pas autoris&eacute;.
		Note: Si vous voulez lire des valeurs dans une m&eacute;moire tampon, vous NE devez PAS passer un pointeur vers la m&eacute;moire tampon; au lieu de cela vous devez passer la premi&egrave;re variable dans la m&eacute;moire tampon.  (Cela peut &ecirc;tre fait par le d&eacute;r&eacute;f&eacute;rencement du pointeur avec ##[[KeyPgOpValueOf Operator * (Value Of)]]##.)  ##**Get**##  comprendra automatiquement que le reste de la m&eacute;moire tampon se poursuit apr&egrave;s la premi&egrave;re variable..  Si vous passez un pointeur directement, alors ##**Get**## &eacute;crira sur la variable et non &agrave; l'emplacement m&eacute;moire vers lequel elle pointe.
	##//amount//##
		##**Get**## lit ##//amount//## variables cons&eacute;cutives du fichier vers la m&eacute;moire, c'est &agrave; dire qu'il lit ##(//amount// * [[KeyPgSizeof SizeOf]](//data//) )## octets ou donn&eacute;es depuis le fichier vers la m&eacute;moire commen&ccedil;ant &agrave; la position ##//data//##.  Si ##//amount//## est omis il sera de ##1## par d&eacute;faut, ce qui signifie que ##**Get**## ne lira qu'une seule variable.
	##//bytesread//##
		Une variable enti&egrave;re non sign&eacute;e qui contiendra le nombre d'octets lus avec succ&egrave;s &agrave; partir du fichier.

{{fbdoc item="section" value="Valeur retourn&eacute;e
	Z&eacute;ro (##0##) si succ&egrave;s; non-z&eacute;ro si erreur. Note: Si ##[[KeyPgEof EOF]]## (End Of File) est atteint pendant la lecture, ##**Get**## retournera "succ&egrave;s".  La quantit&eacute; d'octets r&eacute;ellement lus peut &ecirc;tre v&eacute;rifi&eacute;e en passant une variable ##//bytesread//##.

{{fbdoc item="desc"}}
	Lit les donn&eacute;es binaires &agrave; partir d'un fichier vers une variable tampon

	##**Get**## peut &ecirc;tre utilis&eacute; comme une fonction, et retournera ##0## si succ&egrave;s ou un code d'erreur si &eacute;chec.

	Pour les fichiers ouverts en mode ##[[KeyPgRandom Random]]##, la taille en octets des donn&eacute;es &agrave; lire doit correspondre &agrave; la taille d'enregistrement sp&eacute;cifi&eacute;e.

{{fbdoc item="ex"}}
{{fbdoc item="filename" value="examples/manual/fileio/get.bas"}}%%(freebasic)
dim shared f as integer

sub get_integer()

	dim buffer as integer ' Integer variable

	' Read an Integer (4 bytes) from the file into buffer, using file number "f".
	get #f, , buffer

	' print out result
	print buffer
	print

end sub

sub get_array()

	dim an_array(0 to 10-1) as integer ' array of Integers

	' Read 10 Integers (10 * 4 = 40 bytes) from the file into an_array, using file number "f".
	get #f, , an_array()

	' print out result
	for i as integer = 0 to 10-1
	    print an_array(i)
	next
	print

end sub

sub get_mem

	dim pmem as integer ptr

	' allocate memory for 5 Integers
	pmem = allocate(5 * sizeof(integer))

	' Read 5 integers (5 * 4 = 20 bytes) from the file into allocated memory
	get #f, , *pmem, 5 ' Note pmem must be dereferenced (*pmem, or pmem[0])

	' print out result using [] Pointer Indexing
	for i as integer = 0 to 5-1
	    print pmem[i]
	next
	print

	' free pointer memory to prevent memory leak
	deallocate pmem

end sub

' Find the first free file file number.
f = freefile

' Open the file "file.ext" for binary usage, using the file number "f".
open "file.ext" for binary as #f

  get_integer()

  get_array()

  get_mem()

' Close the file.  
close #f
%%

{{fbdoc item="filename" value="examples/manual/fileio/get-file.bas"}}%%(freebasic)
' Load a small text file to a string

Function LoadFile(byref filename As string) As String
	
	Dim h As Integer
	Dim txt As String
	
	h = FreeFile
	
	if Open( filename For Binary Access Read As #h ) <> 0 then return ""
	
	If Lof(h) > 0 Then
	    
	    txt = String(Lof(h), 0)
	    if Get( #h, ,txt ) <> 0 then txt = ""
	    
	End If
	
	Close #h
	
	Return txt
	
End Function

Dim ExampleStr As String
ExampleStr = LoadFile("smallfile.txt")
Print ExampleStr
%%

{{fbdoc item="diff"}}
	<li>Dans FB, ##**Get**## peut lire des tableaux pleins comme dans VB ou, alternativement, lire un multiple de la taille des donn&eacute;es dans la m&eacute;moire.
	- ##**Get**## peut &ecirc;tre utilis&eacute; comme une fonction dans FB, pour obtenir le code succ&egrave;s/erreur renvoy&eacute; sans avoir &agrave; utiliser les proc&eacute;dures de gestion des erreurs.
	- FB permet le param&egrave;tre ##//bytesread//##, pour v&eacute;rifier combien d'octets ont &eacute;t&eacute; lus avec succ&egrave;s.

{{fbdoc item="see"}}
	- ##[[KeyPgGetgraphics Get (Graphiques)]]## utilisation diff&eacute;rente du m&ecirc;me mot-cl&eacute; 
	- ##[[KeyPgPutfileio Put (Entr&eacute;e/sortie fichiers)]]##
	- ##[[KeyPgOpen Open]]##
	- ##[[KeyPgClose Close]]##
	- ##[[KeyPgBinary Binary]]##
	- ##[[KeyPgRandom Random]]##
	- ##[[KeyPgFreefile Freefile]]##
	- ##[[ProPgFileIO Comparaison des m&eacute;thodes d'entr&eacute;e/sortie des fichiers]]##

{{fbdoc item="back" value="CatPgFile|File I/O Functions"}}