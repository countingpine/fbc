{{fbdoc item="title" value="Op&eacute;rateur Overloading"}}----
Changer la mani&egrave;re dont les types d&eacute;finis par l'utilisateur travaillent avec les op&eacute;rateurs internes.

[[#OVERVIEW">Vue d'ensemble]]
[[#GLOBAL">Op&eacute;rateurs globaux]]
[[#MEMBER">Op&eacute;rateurs membres de d&eacute;claration]]

<a name="OVERVIEW"></a>{{fbdoc item="section" value="Vue d'ensemble
	Simplement, les op&eacute;rateurs sont des proc&eacute;dures et leurs arguments sont appel&eacute;s //op&eacute;randes//. Les op&eacute;rateurs qui prennent un seul op&eacute;rande (##[[KeyPgOpNot Op&eacute;rateur Not]]##) sont appel&eacute;s //op&eacute;rateurs unaires//, les op&eacute;rateurs qui prennent deux op&eacute;randes (##[[KeyPgOpAdd Op&eacute;rateur +]]##) sont appel&eacute;s //op&eacute;rateurs binaires// et les op&eacute;rateurs qui prennent trois op&eacute;randes (##[[KeyPgIif Op&eacute;rateur Iif]]##) sont appel&eacute;s //op&eacute;rateurs ternaires//.

	La plupart des op&eacute;rateurs ne sont pas appel&eacute;s, comme les proc&eacute;dures. Au lieu de cela, leur symbole d'op&eacute;rateur est plac&eacute; &agrave; c&ocirc;t&eacute; de leurs op&eacute;randes. Pour les op&eacute;rateurs unaires, leur op&eacute;rande unique est plac&eacute; &agrave; la droite du symbole. Pour les op&eacute;rateurs binaires, leurs op&eacute;randes - d&eacute;nomm&eacute;s op&eacute;rande de gauche et op&eacute;rande de droite - sont plac&eacute;s &agrave; gauche et &agrave; droite du symbole d'op&eacute;rateur. FreeBasic a un op&eacute;rateur ternaire, ##[[KeyPgIif Op&eacute;rateur Iif]]##, et il est appel&eacute; comme une proc&eacute;dure, avec ses op&eacute;randes s&eacute;par&eacute;s par des virgules et entour&eacute; de parenth&egrave;ses. Par exemple, le code suivant appelle ##[[KeyPgIif Op&eacute;rateur Iif]]## pour d&eacute;terminer si un pointeur est valide. S'il l'est, ##[[KeyPgOpValueOf Op&eacute;rateur * (Valeur de)]]## est appel&eacute; pour d&eacute;r&eacute;f&eacute;rencer le pointeur, et s'il ne l'est pas, ##[[KeyPgOpDivide Op&eacute;rateur / (Division)]]## est appel&eacute; pour trouver la valeur de vingt divis&eacute; par quatre.

{{fbdoc item="filename" value="examples/manual/proguide/opovld/iif.bas"}}%%(freebasic)
Dim i As Integer = 420
Dim p As Integer Ptr = @i

Dim result As Integer = IIf( p, *p, cint( 20 / 4 ) )
%%
	Notez que l'appel de ##[[KeyPgIif Op&eacute;rateur Iif]]## est similaire &agrave; un appel de proc&eacute;dure, tandis que les appels &agrave; ##[[KeyPgOpValueOf Op&eacute;rateur * (Valeur de)]]## et ##[[KeyPgOpDivide Op&eacute;rateur / (Division)]]## ne le sont pas. Dans l'exemple, ##//p//## est l'op&eacute;rande de ##[[KeyPgOpValueOf Op&eacute;rateur * (Valeur de)]]##, et ##//20//## et ##//4//## sont, respectivement, les op&eacute;randes de gauche et de droite de ##[[KeyPgOpDivide Op&eacute;rateur / (Division)]]##.

	Tous les op&eacute;rateurs, en FreeBasic, sont pr&eacute;d&eacute;finis pour prendre des op&eacute;randes de types de donn&eacute;es standard, comme ##[[KeyPgInteger Integer]]## et ##[[KeyPgSingle Single]]##, mais ils peuvent &eacute;galement &ecirc;tre surcharg&eacute;s pour des types d&eacute;finis par l'utilisateur; c'est &agrave; dire qu'ils peuvent &ecirc;tre d&eacute;finis pour accepter, aussi, des op&eacute;randes qui sont des objets. Il existe deux types d'op&eacute;rateurs peuvent &ecirc;tre surcharg&eacute;s, les //op&eacute;rateurs globaux// et les //op&eacute;rateurs membres//.

<a name="GLOBAL"></a>
	{{fbdoc item="section" value="Les Op&eacute;rateurs globaux

	Les Op&eacute;rateurs globaux sont ceux qui sont d&eacute;clar&eacute;s dans la port&eacute;e au niveau du module (globalement). Ce sont les op&eacute;rateurs ##[[KeyPgOpNegate - (N&eacute;gation)]]##, ##[[KeyPgOpNot Not (Compl&eacute;ment de bits)]]##, ##[[KeyPgOpPtrMemberAccess -> (Acc&egrave;s membre par pointeur)]]##, ##[[KeyPgOpValueOf * (Valeur de)]]##, ##[[KeyPgOpAdd + (Addition)]]##, ##[[KeyPgOpSubtract - (Soustraction)]]##, ##[[KeyPgOpMultiply * (Multiplication)]]##, ##[[KeyPgOpDivide / (Division)]]##, ##[[KeyPgOpIntegerDivide \ (Division enti&egrave;re)]]##, ##[[KeyPgOpConcatConvert & (Concat&eacute;nation)]]##, ##[[KeyPgOpModulus Mod (Modulo)]]##, ##[[KeyPgOpShiftLeft Shl (D&eacute;calage &agrave; gauche)]]##, ##[[KeyPgOpShiftRight Shr (D&eacute;calage &agrave; droite)]]##, ##[[KeyPgOpAnd And (And de bits)]]##, ##[[KeyPgOpOr Or (Or de bits)]]##, ##[[KeyPgOpXor Xor (Xor de bits)]]##, ##[[KeyPgOpImp Imp (Imp de bits)]]##, ##[[KeyPgOpEqv Eqv (Eqv de bits)]]##, ##[[KeyPgOpExponentiate ^ (Puissance)]]##, ##[[KeyPgOpEqual = (Egal)]]##, ##[[KeyPgOpNotEqual <> (Diff&eacute;rent)]]##, ##[[KeyPgOpLessThan < (Inf&eacute;rieur)]]##, ##[[KeyPgOpGreaterThan > (Sup&eacute;rieur)]]##, ##[[KeyPgOpLessThanOrEqual <= (Inf&eacute;rieur ou &eacute;gal)]]## et ##[[KeyPgOpGreaterThanOrEqual >= (Sup&eacute;rieur ou &eacute;gal)]]##.

	D&eacute;clarer un op&eacute;rateur global personnalis&eacute; est similaire &agrave; d&eacute;clarer une proc&eacute;dure. Le mot-clef ##[[KeyPgDeclare Declare]]## est utilis&eacute; avec le mot-clef ##[[KeyPgOperator Operator]]##. Le symbole de l'op&eacute;rateur est plac&eacute; &agrave; c&ocirc;t&eacute;, suivi de la liste, entre parenth&egrave;ses, des param&egrave;tres s&eacute;par&eacute;s par des virgules qui repr&eacute;sentent les op&eacute;randes transmis &agrave; l'op&eacute;rateur. Contrairement aux proc&eacute;dures, les op&eacute;rateurs peuvent &ecirc;tre surcharg&eacute;s par d&eacute;faut, de sorte que le mot-cl&eacute; ##[[KeyPgOverload Overload]]## n'est pas n&eacute;cessaire lors de la d&eacute;claration des op&eacute;rateurs personnalis&eacute;s. Au moins un des param&egrave;tres de l'op&eacute;rateur doit &ecirc;tre de type d&eacute;fini par l'utilisateur (apr&egrave;s tout, les op&eacute;rateurs avec des param&egrave;tres de types int&eacute;gr&eacute;s sont d&eacute;j&agrave; d&eacute;finis).

L'exemple suivant d&eacute;clare les op&eacute;rateurs globaux ##[[KeyPgOpNegate - (N&eacute;gation)]]## et ##[[KeyPgOpMultiply * (Multiplication)]]## &agrave; accepter des op&eacute;randes d'un type d&eacute;fini par l'utilisateur.
type Rational
	Type Rational
As Integer numerator, denominator

End Type
	Op&eacute;rateur - (ByRef rhs As Rational) As Rational
Return Type(-rhs.numerator, rhs.denominator)

End Op&eacute;rateur
	Op&eacute;rateur * (ByRef lhs As Rational, ByRef rhs As Rational) As Rational
		Return Type(lhs.numerator * rhs.numerator, _
lhs.denominator * rhs.denominator)

End Op&eacute;rateur
Dim As Rational r1 = (2, 3), r2 = (3, 4)
Dim As Rational r3 = -(r1 * r2)
Print r3.numerator & "/" & r3.denominator
	%%

Ici les op&eacute;rateurs globaux sont d&eacute;finis pour le type ##//Rational//##, et sont utilis&eacute;s dans l'expression d'initialisation pour ##//r3//##. L'affichage est ##//-6/12//##.
	<a name="MEMBER"></a>

	{{fbdoc item="section" value="Op&eacute;rateurs membres de d&eacute;clarations

	Les op&eacute;rateurs membres sont d&eacute;clar&eacute;s dans la d&eacute;finition d'un ##[[KeyPgType Type]]## ou d'une ##[[KeyPgClass Class]]##, comme les membres de proc&eacute;dures et ils sont les op&eacute;rateurs de conversion et d' assignation ##[[KeyPgOpAssignment Let (Assign)]]##, ##[[KeyPgCast Cast (Cast)]]##, ##[[KeyPgOpCombineAdd += (Add And Assign)]]##, ##[[KeyPgOpCombineSub -= (Subtract And Assign)]]##, ##[[KeyPgOpCombineMultiply *= (Multiply And Assign)]]##, ##[[KeyPgOpCombineDivide /= (Divide And Assign)]]##, ##[[KeyPgOpCombineIntegerDivide \= (Integer Divide And Assign)]]##, ##[[KeyPgOpCombineExponentiate ^= (Exponentiate And Assign)]]##, ##[[KeyPgOpCombineConcat &= (Concat And Assign)]]##, ##[[KeyPgOpCombineModulus Mod= (Modulus And Assign)]]##, ##[[KeyPgOpCombineShiftLeft Shl= (Shift Left And Assign)]]##, ##[[KeyPgOpCombineShiftRight Shr= (Shift Right And Assign)]]##, ##[[KeyPgOpCombineAnd And= (Conjunction And Assign)]]##, ##[[KeyPgOpCombineOr Or= (Inclusive Disjunction And Assign)]]##, ##[[KeyPgOpCombineXor Xor= (Exclusive Disjunction And Assign)]]##, ##[[KeyPgOpCombineImp Imp= (Implication And Assign)]]## et ##[[KeyPgOpCombineEqv Eqv= (Equivalence And Assign)]]##.

Lors de la d&eacute;claration des op&eacute;rateurs membres, les mots-clefs ##[[KeyPgDeclare Declare]]## et ##[[KeyPgOp&eacute;rateur Op&eacute;rateur]]## sont utilis&eacute;s suivis par le symbole de l'op&eacute;rateur et de sa liste de param&egrave;tres. Comme les membres de proc&eacute;dures, les op&eacute;rateurs membres sont d&eacute;finis en dehors de la d&eacute;finition du ##[[KeyPgType Type]]## ou de la ##[[KeyPgClass Class]]## et le nom du symbole est pr&eacute;fix&eacute; par le nom du ##[[KeyPgType Type]]## ou de la ##[[KeyPgClass Class]]##.
L'exemple suivant surcharge les op&eacute;rateurs membres ##[[KeyPgCast Cast (Conversion)]]## et ##[[KeyPgOpCombineMultiply *= (Multiplication et affectation)]]## pour des objets d'un type d&eacute;fini par l'utilisateur.
	%%(freebasic)
	
	Type Rational
	As Integer numerator, denominator
	Declare Op&eacute;rateur Cast () As Double
Declare Op&eacute;rateur Cast () As String

Declare Op&eacute;rateur *= (ByRef rhs As Rational)
	End Type
Op&eacute;rateur Rational.cast () As Double

Return numerator / denominator
	End Op&eacute;rateur
Op&eacute;rateur Rational.cast () As String

Return numerator & "/" & denominator
	End Op&eacute;rateur
	Op&eacute;rateur Rational.*= (ByRef rhs As Rational)
numerator *= rhs.numerator

denominator *= rhs.denominator
End Op&eacute;rateur
Dim As Rational r1 = (2, 3), r2 = (3, 4)
r1 *= r2
Dim As Double d = r1
	Print r1, d

%%