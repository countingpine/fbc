{{fbdoc item="title" value="Opérateur Overloading"}}----
Changer la manière dont les types définis par l'utilisateur travaillent avec les opérateurs internes.

{{anchor name="OVERVIEW|Vue d'ensemble"}}
{{anchor name="GLOBAL|Opérateurs globaux"}}
{{anchor name="MEMBER|Opérateurs membres de déclaration"}}

{{anchor name="OVERVIEW"}}{{fbdoc item="section" value="Vue d'ensemble"}}
	Simplement, les opérateurs sont des procédures et leurs arguments sont appelés //opérandes//. Les opérateurs qui prennent un seul opérande (##[[KeyPgOpNot Opérateur Not]]##) sont appelés //opérateurs unaires//, les opérateurs qui prennent deux opérandes (##[[KeyPgOpAdd Opérateur +]]##) sont appelés //opérateurs binaires// et les opérateurs qui prennent trois opérandes (##[[KeyPgIif Opérateur Iif]]##) sont appelés //opérateurs ternaires//.

	La plupart des opérateurs ne sont pas appelés, comme les procédures. Au lieu de cela, leur symbole d'opérateur est placé à côté de leurs opérandes. Pour les opérateurs unaires, leur opérande unique est placé à la droite du symbole. Pour les opérateurs binaires, leurs opérandes - dénommés opérande de gauche et opérande de droite - sont placés à gauche et à droite du symbole d'opérateur. FreeBASIC a un opérateur ternaire, ##[[KeyPgIif Opérateur Iif]]##, et il est appelé comme une procédure, avec ses opérandes séparés par des virgules et entouré de parenthèses. Par exemple, le code suivant appelle ##[[KeyPgIif Opérateur Iif]]## pour déterminer si un pointeur est valide. S'il l'est, ##[[KeyPgOpValueOf Opérateur * (Valeur de)]]## est appelé pour déréférencer le pointeur, et s'il ne l'est pas, ##[[KeyPgOpDivide Opérateur / (Division)]]## est appelé pour trouver la valeur de vingt divisé par quatre.

{{fbdoc item="filename" value="examples/manual/proguide/opovld/iif.bas"}}%%(freebasic)
Dim i As Integer = 420
Dim p As Integer Ptr = @i

Dim result As Integer = IIf( p, *p, cint( 20 / 4 ) )
%%
	Notez que l'appel de ##[[KeyPgIif Opérateur Iif]]## est similaire à un appel de procédure, tandis que les appels à ##[[KeyPgOpValueOf Opérateur * (Valeur de)]]## et ##[[KeyPgOpDivide Opérateur / (Division)]]## ne le sont pas. Dans l'exemple, ##//p//## est l'opérande de ##[[KeyPgOpValueOf Opérateur * (Valeur de)]]##, et ##//20//## et ##//4//## sont, respectivement, les opérandes de gauche et de droite de ##[[KeyPgOpDivide Opérateur / (Division)]]##.

	Tous les opérateurs, en FreeBASIC, sont prédéfinis pour prendre des opérandes de types de données standard, comme ##[[KeyPgInteger Integer]]## et ##[[KeyPgSingle Single]]##, mais ils peuvent également être surchargés pour des types définis par l'utilisateur; c'est à dire qu'ils peuvent être définis pour accepter, aussi, des opérandes qui sont des objets. Il existe deux types d'opérateurs peuvent être surchargés, les //opérateurs globaux// et les //opérateurs membres//.

{{anchor name="GLOBAL"}}{{fbdoc item="section" value="Les Opérateurs globaux"}}
	Les Opérateurs globaux sont ceux qui sont déclarés dans la portée au niveau du module (globalement). Ce sont les opérateurs ##[[KeyPgOpNegate - (Négation)]]##, ##[[KeyPgOpNot Not (Complément de bits)]]##, ##[[KeyPgOpPtrMemberAccess -> (Accès membre par pointeur)]]##, ##[[KeyPgOpValueOf * (Valeur de)]]##, ##[[KeyPgOpAdd + (Addition)]]##, ##[[KeyPgOpSubtract - (Soustraction)]]##, ##[[KeyPgOpMultiply * (Multiplication)]]##, ##[[KeyPgOpDivide / (Division)]]##, ##[[KeyPgOpIntegerDivide \ (Division entière)]]##, ##[[KeyPgOpConcatConvert & (Concaténation)]]##, ##[[KeyPgOpModulus Mod (Modulo)]]##, ##[[KeyPgOpShiftLeft Shl (Décalage à gauche)]]##, ##[[KeyPgOpShiftRight Shr (Décalage à droite)]]##, ##[[KeyPgOpAnd And (And de bits)]]##, ##[[KeyPgOpOr Or (Or de bits)]]##, ##[[KeyPgOpXor Xor (Xor de bits)]]##, ##[[KeyPgOpImp Imp (Imp de bits)]]##, ##[[KeyPgOpEqv Eqv (Eqv de bits)]]##, ##[[KeyPgOpExponentiate ^ (Puissance)]]##, ##[[KeyPgOpEqual = (Egal)]]##, ##[[KeyPgOpNotEqual <> (Différent)]]##, ##[[KeyPgOpLessThan < (Inférieur)]]##, ##[[KeyPgOpGreaterThan > (Supérieur)]]##, ##[[KeyPgOpLessThanOrEqual <= (Inférieur ou égal)]]## et ##[[KeyPgOpGreaterThanOrEqual >= (Supérieur ou égal)]]##.

	Déclarer un opérateur global personnalisé est similaire à déclarer une procédure. Le mot-clef ##[[KeyPgDeclare Declare]]## est utilisé avec le mot-clef ##[[KeyPgOperator Operator]]##. Le symbole de l'opérateur est placé à côté, suivi de la liste, entre parenthèses, des paramètres séparés par des virgules qui représentent les opérandes transmis à l'opérateur. Contrairement aux procédures, les opérateurs peuvent être surchargés par défaut, de sorte que le mot-clé ##[[KeyPgOverload Overload]]## n'est pas nécessaire lors de la déclaration des opérateurs personnalisés. Au moins un des paramètres de l'opérateur doit être de type défini par l'utilisateur (après tout, les opérateurs avec des paramètres de types intégrés sont déjà définis).

	L'exemple suivant déclare les opérateurs globaux ##[[KeyPgOpNegate - (Négation)]]## et ##[[KeyPgOpMultiply * (Multiplication)]]## à accepter des opérandes d'un type défini par l'utilisateur.

{{fbdoc item="filename" value="examples/manual/proguide/opovld/global-ops.bas"}}%%(freebasic)
type Rational
	as integer numerator, denominator
end type

operator - (byref rhs as Rational) as Rational
	return type(-rhs.numerator, rhs.denominator)
end operator

operator * (byref lhs as Rational, byref rhs as Rational) as Rational
	return type(lhs.numerator * rhs.numerator, _
		lhs.denominator * rhs.denominator)
end operator

dim as Rational r1 = (2, 3), r2 = (3, 4)
dim as Rational r3 = -(r1 * r2)
print r3.numerator & "/" & r3.denominator
%%
	Ici les opérateurs globaux sont définis pour le type ##//Rational//##, et sont utilisés dans l'expression d'initialisation pour ##//r3//##. L'affichage est ##//-6/12//##.

{{anchor name="MEMBER"}}{{fbdoc item="section" value="Opérateurs membres de déclarations"}}
	Les opérateurs membres sont déclarés dans la définition d'un ##[[KeyPgType Type]]## ou d'une ##[[KeyPgClass Class]]##, comme les membres de procédures et ils sont les opérateurs de conversion et d' assignation ##[[KeyPgOpAssignment Let (Assign)]]##, ##[[KeyPgCast Cast (Cast)]]##, ##[[KeyPgOpCombineAdd += (Add and assign)]]##, ##[[KeyPgOpCombineSub -= (Subtract and assign)]]##, ##[[KeyPgOpCombineMultiply *= (Multiply and assign)]]##, ##[[KeyPgOpCombineDivide /= (Divide and assign)]]##, ##[[KeyPgOpCombineIntegerDivide \= (Integer divide and assign)]]##, ##[[KeyPgOpCombineExponentiate ^= (Exponentiate and assign)]]##, ##[[KeyPgOpCombineConcat &= (Concat and assign)]]##, ##[[KeyPgOpCombineModulus Mod= (Modulus and assign)]]##, ##[[KeyPgOpCombineShiftLeft Shl= (Shift left and assign)]]##, ##[[KeyPgOpCombineShiftRight Shr= (Shift right and assign)]]##, ##[[KeyPgOpCombineAnd And= (Conjunction and assign)]]##, ##[[KeyPgOpCombineOr Or= (Inclusive disjunction and assign)]]##, ##[[KeyPgOpCombineXor Xor= (Exclusive disjunction and assign)]]##, ##[[KeyPgOpCombineImp Imp= (Implication and assign)]]## et ##[[KeyPgOpCombineEqv Eqv= (Equivalence and assign)]]##.

	Lors de la déclaration des opérateurs membres, les mots-clefs ##[[KeyPgDeclare Declare]]## et ##[[KeyPgOpérateur Opérateur]]## sont utilisés suivis par le symbole de l'opérateur et de sa liste de paramètres. Comme les membres de procédures, les opérateurs membres sont définis en dehors de la définition du ##[[KeyPgType Type]]## ou de la ##[[KeyPgClass Class]]## et le nom du symbole est préfixé par le nom du ##[[KeyPgType Type]]## ou de la ##[[KeyPgClass Class]]##.

	L'exemple suivant surcharge les opérateurs membres ##[[KeyPgCast Cast (Conversion)]]## et ##[[KeyPgOpCombineMultiply *= (Multiplication et affectation)]]## pour des objets d'un type défini par l'utilisateur.

{{fbdoc item="filename" value="examples/manual/proguide/opovld/member-ops.bas"}}%%(freebasic)
type Rational
	as integer numerator, denominator
	
	declare operator cast () as double
	declare operator cast () as string
	declare operator *= (byref rhs as Rational)
end type

operator Rational.cast () as double
	return numerator / denominator
end operator

operator Rational.cast () as string
	return numerator & "/" & denominator
end operator

operator Rational.*= (byref rhs as Rational)
	numerator *= rhs.numerator
	denominator *= rhs.denominator
end operator

dim as Rational r1 = (2, 3), r2 = (3, 4)
r1 *= r2
dim as double d = r1
print r1, d
%%
	Notez que l'opérateur membre ##[[KeyPgCast Cast (Conversion)]]## est déclaré deux fois, une fois pour la conversion en ##[[KeyPgDouble Double]]## et une fois pour la conversion en ##[[KeyPgString String]]##. C'est le seul opérateur (ou procédure) qui peut être déclaré plusieurs fois quand seulement le type de retour est différent. Le compilateur décide quelle surcharge de "cast" appeler en se basant sur l'utilisation de l'objet (dans l'initialisation de ##[[KeyPgDouble Double]]## ##//d//##, ##//Rational.Cast as double//## est appelé et dans la déclaration de ##[[KeyPgPrint Print]]##, ##//Rational.Cast as string//## est utilisé à la place).

{{fbdoc item="back" value="CatPgProgrammer|Programmer's Guide"}}