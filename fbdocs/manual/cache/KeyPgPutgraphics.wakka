<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">{{fbdoc item="title" value="Put (Graphics)"}}----<div id="fb_tab_r"> <img src="images/fblogo_mini.gif">
Copie une image sur une autre image ou sur l&apos;&eacute;cran<br \=""><br \="">{{fbdoc item="syntax"}}##<br \="">**Put** [ //target//, ] [ STEP ] ( //x//,//y// ), //source// [ ,( //x1//,//y1// )-[ STEP ]( //x2//,//y2// ) ] [ ,//method// [ ,( //alphaval//|//value//|//blender// [ ,//param//]) ] ]<br \="">##<br \="">

{{fbdoc item="param"}}<br \="">##//target//##<br \="">		est l&apos;adresse du tampon o&ugrave; l&apos;image doit &ecirc;tredessin&eacute;e (destination). Si omis, l&apos;image est "blitt&eacute;e" (affich&eacute;e) &agrave;l&apos;&eacute;cran. Voir ci-dessous.<br \="">
	##STEP##<br \="">		indique que les coordonn&eacute;es ##(//x//,  //y//)## sont relatives &agrave;  la position courante du curseur graphique.	<br \="">
##(//x//,  //y//)##<br \="">		indique les coordonn&eacute;es par rapport au coin en haut &agrave; gauche du tampon destination ou de l&apos;&eacute;cran, sur lequel l&apos;image est dessin&eacute;e. <br \="">
##//source//##<br \="">		est l&apos;adresse du tampon image sur lequel dessiner. Voir ci-dessous.<br \="">
	##(//x1//, //y1//)-[ STEP ](//x2//, //y2//)##<br \="">		une zone rectangulaire dans le tampon source, utilis&eacute;e pour le dessin. Si omise, le tampon entier est utilis&eacute; pour le dessin. ##STEP## indique que ##//x2//## et ##//y2//## sont relatifs respectivement &agrave; ##//x1//## et ##//y1//##.<br \="">
		##//method//##<br \="">		sp&eacute;cifie la m&eacute;thode utilis&eacute;e pour dessiner l&apos;image sur le tampon destination et peut &ecirc;tre une des m&eacute;thodes suivantes (##XOR## est la m&eacute;thode par d&eacute;faut):<br \=""><br \="">M&eacute;thodes ind&eacute;pendantes de l&apos;arri&egrave;re-plan<br \="">		##[[KeyPgPsetGfx PSet]]## : Les valeurs pixel sont copi&eacute;es sans modification.<br \="">##PRESET## : Les valeurs pixel source sont compl&eacute;ment&eacute;es &agrave;  1 n&eacute;gativement (1&apos;s-complement negated) avant la copie.<br \="">##[[KeyPgTransGfx Trans]]## : Les valeurs pixel source sont copi&eacute;es sans modification. Ne dessine pas les pixels source du masque de couleur. Voir ci-dessous.<br \="">
	M&eacute;thodes d&eacute;pendant de l&apos;arri&egrave;re-plan<br \="">		##[[KeyPgAndGfx And]]## : Les pixels destination subissent un AND avec les pixels source (dest AND source). Voir ci-dessous.<br \="">##[[KeyPgOrGfx Or]]## : Les pixels destination subissent un OR avec les pixels source (dest OR source). Voir ci-dessous.<br \="">##[[KeyPgXorGfx Xor]]## : Les pixels destination subissent un XOR avec les pixels source (dest XOR source). Voir ci-dessous.<br \="">##[[KeyPgAlphaGfx Alpha]]## : Source est m&eacute;lang&eacute;e avec un facteur de transparence sp&eacute;cifi&eacute; soit par le param&egrave;tre ##//value//##, soit dans les pixels individuels de l&apos;image.  Voir ci-dessous.<br \="">##[[KeyPgAddGfx Add]]##: Source est multipli&eacute; par une valeur et ajout&eacute;e avec saturation &agrave;  la destination. Voir ci-dessous.<br \="">##[[KeyPgCustomgfx Custom]]## : Utilise une fonction d&eacute;finie par l&apos;utilisateur pour effectuer le m&eacute;lange de la source avec la destination. Voir ci-dessous.<br \=""><br \="">
		##//value//##<br \="">		est une valeur de ##0 &agrave; 255## sp&eacute;cifiant la valeur de la transparence pour l&apos;une des m&eacute;thodes de transformation ##ADD## ou ##ALPHA##.<br \="">
	##//blender//## <br \="">		sp&eacute;cifie l&apos;adresse de la fonction utilisateur &agrave; appeler pour la m&eacute;thode de transformation ##CUSTOM##. Voir ci-dessous.<br \="">
		##//param//## <br \="">		indique le param&egrave;tre &agrave; passer &agrave; la fonction de transformation utilisateur.<br \=""><br \="">
	{{fbdoc item="desc"}}<br \="">##**Put**## peut &ecirc;tre utilis&eacute; pour dessiner une image sur une autre image. Les coordonn&eacute;es ##//x//## et ##//y//## sont affect&eacute;es par le dernier appel &agrave;  ##[[KeyPgViewgraphics View]]## et ##[[KeyPgWindow Window]]##, et l&apos;image plac&eacute;e respecte la r&eacute;gion de d&eacute;coupage courante valid&eacute;e par le dernier appel &agrave;  ##[[KeyPgViewgraphics View]]##. L&apos;image est tronqu&eacute;e si elle est dessin&eacute;e en-dehors du tampon destination.<br \=""><br \="">**Tampons Image Valides**<br \="">		Les tampons image ##//source//## et ##//target//## doivent &ecirc;tre des tampons image valides. Des tampons image valides sont cr&eacute;&eacute;s par ##[[KeyPgGetgraphics Get]]## ou ##[[KeyPgImagecreate ImageCreate]]##. Des tampons image valides peuvent &ecirc;tre sp&eacute;cifi&eacute;s dans ##**Put**## utilisant un tableau avec un index optionnel ou un pointeur avec un index optionnel.<br \=""><br \="">
		**M&eacute;thodes de dessin**<br \="">		D&eacute;pendant de la m&eacute;thode utilis&eacute;e, les valeurs pixel dans le tampon destination sont utilis&eacute;es pour calculer les valeurs pixel qui seront dessin&eacute;es. Les m&eacute;thodes ##PSET##, ##PRESET## et ##TRANS## n&apos;utilisent pas le tampon destination pour calculer les valeurs finales, au contraire des m&eacute;thodes ##AND##, ##OR##, ##XOR##, ##ALPHA## et ##ADD##. Les images qui sont dessin&eacute;es par ces derni&egrave;res m&eacute;thodes seront diff&eacute;rentes en fonction du contenu du tampon destination.<br \=""><br \="">
	**Diff&eacute;rent formats de pixel**<br \="">		Le format de pixel d&apos;un tampon image doit &ecirc;tre compatible avec la profondeur de couleur du mode de graphique courant; autrement dit, si vous faites l&apos;acquisition d&apos;une image en utilisant ##[[KeyPgGetgraphics Get]]## et que plus tard vous changez de mode &eacute;cran avec ##[[KeyPgScreengraphics Screen]]##, les donn&eacute;es image ne seront peut &ecirc;tre pas valides dans ce nouveau mode graphique, et vous ne pourrez peut &ecirc;tre pas l&apos;afficher &agrave;  l&apos;&eacute;cran. Vous noterez cependant que vous pourrez toujours dessiner un tampon image sur un autre tampon image via ##**Put**## tant que ces tampons auront &eacute;t&eacute; cr&eacute;&eacute;s avec la m&ecirc;me profondeur.<br \=""><br \="">Les m&eacute;thodes ##AND##, ##OR## et ##XOR## donnent des r&eacute;sultats diff&eacute;rents en fonction de la pofondeur de couleur courante, car les pixels sont stock&eacute;s dans diff&eacute;rents formats; voir [[GfxInternalFormats Formats internes des pixels]] pour des d&eacute;tails. <br \=""><br \="">
		**Masque de couleur**<br \="">		Les m&eacute;thodes ##TRANS##, ##ALPHA## et ##ADD## ne dessinent pas les pixels de l'image source qui utilisent le masque de couleur. Le masque de couleur d&eacute;pend de la profondeur de la cible (un tampon image ou l&apos;&eacute;cran): pour des profondeurs jusqu&apos;&agrave;  8 bpp (modes avec palette) c&apos;est la couleur d&apos;indice ##0##, alors qu&apos;en profondeur &apos;hi/truecolor&apos; (16 et 32 bpp) il correspond &agrave;  magenta, c&apos;est &agrave;  dire ##[[KeyPgRgb RGB]](255, 0, 255)##. Notez que dans les modes 32 bpp la valeur alpha d&apos;une couleur n&apos;affecte pas l&apos;identification de la couleur transparente; seuls les 24 bits de poids faibles sont utilis&eacute;s pour l&apos;identifier. Voir [[GfxInternalFormats Formats internes des pixels ]] pour plus de d&eacute;tails. <br \=""><br \="">
	**Dessin de la transparence (Alpha drawing)**		La m&eacute;thode ##ALPHA## est utilisable dans deux modes. Si le param&egrave;tre ##//value//## est sp&eacute;cifi&eacute;, il est utilis&eacute; pour sp&eacute;cifier le niveau de transparence pour l&apos;image enti&egrave;re &agrave;  dessiner; une valeur de 0 dessinera une image compl&egrave;tement transparente, alors qu&apos;une valeur de 255 en dessinera une sans aucune transparence. Ce mode ne fonctionne qu&apos;avec des cibles &apos;hi/truecolor&apos; (16 et 32 bpp).<br \="">Si le param&egrave;tre ##//value//## est omis, la m&eacute;thode ##ALPHA## prendra la valeur du niveau alpha sur une base par-pixel, permettant de dessiner des images avec un canal alpha (certaines parties de l&apos;image pourront &eacute;tre plus ou moins transparentes que d&apos;autres). Ce mode ne fonctionne qu&apos;avec des tampons image de 32 bpp, car c&apos;est la seule profondeur de couleur permettant d&apos;inclure la valeur alpha dans chaque pixel.<br \=""><br \="">
		**Jouer avec le canal "alpha"**		Normalement ##**Put**## ne permet d&apos;&eacute;crire des tampons image que sur des cibles de m&ecirc;me profondeur, mais il y a une exception. Quand vous dessinez un tampon image de 8 bpp sur une cible de 32 bpp et que la m&eacute;thode ##ALPHA## est utilis&eacute;e, l&apos;image source de 8 bpp est dessin&eacute;e dans le canal alpha de la cible 32 bpp. Cela permet de valider facilement la totalit&eacute; du canal alpha d&apos;une image sans &eacute;tre oblig&eacute; de manier individuellement ses donn&eacute;es pixels.<br \=""><br \="">

		**M&eacute;thode CUSTOM de Modification des pixels**		La m&eacute;thode ##CUSTOM## utilise une fonction d&eacute;finie par l&apos;utilisateur pour calculer les valeurs finales des pixels &agrave; dessiner dans le tampon destination. Cette fonction sera appel&eacute;e pour chaque pixel de l&apos;image source, et recevra les valeurs des pixels source et destination et un pointeur de donn&eacute;es pass&eacute; par la fonction ##**Put**##. La valeur du pixel renvoy&eacute;e sera celle utilis&eacute;e pour dessiner sur le tampon destination. La fonction est de la forme:<br \=""><br \="">##[[KeyPgDeclare Declare]] [[KeyPgFunction Function]] //identifier// ( [[KeyPgByval ByVal]] //source_pixel// [[KeyPgAs As]] [[KeyPgUinteger UInteger]], [[KeyPgByval ByVal]] //destination_pixel// [[KeyPgAs As]] [[KeyPgUinteger UInteger]], [[KeyPgByval ByVal]] //parameter// [[KeyPgAs As]] [[KeyPgAny Any]] [[KeyPgPtr Ptr]]) [[KeyPgAs As]] [[KeyPgUinteger UInteger]]##<br \=""><br \="">		##//identifier//## est le nom de la fonction. Selon vos d&eacute;sirs.<br \="">##//source_pixel//## est la valeur du pixel courant de l&apos;image source.<br \="">##//destination_pixel//## est la valeur du pixel courant de l&apos;image destination.<br \="">##//parameter//## c&apos;est le param&egrave;tre pass&eacute; par la commande ##**Put**##. Ce doit &ecirc;tre un ##[[KeyPgPtr Pointeur]]## de donn&eacute;es.  S&apos;il est omis, sa valeur sera z&eacute;ro.<br \=""><br \="">
			{{fbdoc item="ex"}}<br \="">Le programme ci-dessous donne un exemple simple de la fa&ccedil;on d&apos;utiliser ##**Put**## pour placer une image &agrave; l&apos;&eacute;cran, incluant la cr&eacute;ation d&apos;un tampon image et la lib&eacute;ration de la m&eacute;moire apr&eacute;s utilisation.<br \="">%%(freebasic)
			&apos;&apos; Valide ecran et remplit avec couleur arriere-plan<br>ScreenRes 320, 200, 32<br>Paint (0, 0), RGB(64, 128, 255)<br><br>&apos;&apos; Valide une image et dessine quelque chose dedans<br>Dim img As Any Ptr = ImageCreate( 32, 32, RGB(255, 0, 255) )<br>Circle img, (16, 16), 15, RGB(255, 255, 0),     ,     , 1, f<br>Circle img, (10, 10), 3,  RGB(  0,   0, 0),     ,     , 2, f<br>Circle img, (23, 10), 3,  RGB(  0,   0, 0),     ,     , 2, f<br>Circle img, (16, 18), 10, RGB(  0,   0, 0), 3.14, 6.28<br><br>&apos;&apos; PUT image au centre ecran<br>Put (160 - 16, 100 - 16), img, Trans<br><br>&apos;&apos; Libere memoire image<br>ImageDestroy img<br><br>&apos;&apos; Attend touche appuyee<br>Sleep<br>
			##<br><br \=""><div class="fb_img"><img src="images/putgfx1.png">
		<br \=""><br \="">L&apos;exemple ci-dessous montre comment allouer de la m&eacute;moire pour une image, puis dessiner celle-ci en utilisant diff&eacute;rentes m&eacute;thodes, y compris en utilisant une fonction personnelle, puis comment lib&eacute;rer la m&eacute;moire utilis&eacute;e:<br \="">%%(freebasic)
			Declare Function checkered_blend( ByVal src As UInteger, ByVal dest As UInteger, ByVal param As Any Ptr ) As UInteger<br><br>   Screen 14, 32                                   &apos;&apos; valide 320*240*32 mode gfx<br>   <br>   Dim As Any Ptr sprite<br>   Dim As Integer counter = 0<br>   <br>   sprite = ImageCreate( 32, 32 )                  &apos;&apos; alloue memoire pour sprite 32x32<br>   <br>   Line sprite, ( 0, 0 )-( 31, 31 ), RGBA(255, 0, 0, 64), bf  &apos;&apos; dessine un sprite ...<br>   Line sprite, ( 4, 4 )-( 27, 27 ), RGBA(255, 0, 0, 192), bf<br>   Line sprite, ( 0, 0 )-( 31, 31 ), RGB(0, 255, 0), b<br>   Line sprite, ( 8, 8 )-( 23, 23 ), RGBA(255, 0, 255, 64), bf<br>   Line sprite, ( 1, 1 )-( 30, 30 ), RGBA(0, 0, 255, 192)<br>   Line sprite, ( 30, 1 )-( 1, 30 ), RGBA(0, 0, 255, 192)<br>   <br>   Cls<br>   Dim As Integer i : For i = 0 To 63              &apos;&apos; draw l' arriere-plan<br>      Line( i,0 )-( i,240 ), RGB( i * 4, i * 4, i * 4 )<br>   Next i<br>   <br>   &apos;&apos; Demonstration toutes methodes dessin ...<br>   Put( 8,14 ), sprite, PSet<br>   Put Step( 16,20 ), sprite, PReset<br>   Put Step( -16,20 ), sprite, And<br>   Put Step( 16,20 ), sprite, Or<br>   Put Step( -16,20 ), sprite, Xor<br>   Put Step( 16,20 ), sprite, Trans<br>   Put Step( -16,20 ), sprite, Alpha, 96<br>   Put Step( 16,20 ), sprite, Alpha<br>   Put Step( -16,20 ), sprite, add, 192<br>   Put Step( 16,20 ), sprite, Custom, @checkered_blend, @counter<br>   <br>   &apos;&apos; Affiche une description a cote chaque demo<br>   Draw String (100, 26), "<- pset"<br>   Draw String Step (0, 20), "<- preset"<br>   Draw String Step (0, 20), "<- and"<br>   Draw String Step (0, 20), "<- or"<br>   Draw String Step (0, 20), "<- xor"<br>   Draw String Step (0, 20), "<- trans"<br>   Draw String Step (0, 20), "<- alpha (uniform)"<br>   Draw String Step (0, 20), "<- alpha (per pixel)"<br>   Draw String Step (0, 20), "<- add"<br>   Draw String Step (0, 20), "<- custom"<br>   <br>   ImageDestroy( sprite )                          &apos;&apos; libere memoire sprite<br>   Sleep : End 0<br><br>&apos;&apos; Fonction blender perso/span><br>Function checkered_blend( ByVal src As UInteger, ByVal dest As UInteger, ByVal param As Any Ptr ) As UInteger<br>   Dim As Integer Ptr counter<br>   Dim As UInteger pixel<br>   <br>   counter = Cast(Integer Ptr, param)<br>   pixel = IIf(((*counter And 4) Shr 2) Xor ((*counter And 128) Shr 7), src, dest)<br>   *counter += 1<br>   Return pixel<br>End Function<br>
			##<br><br \=""><div class="fb_img"><img src="images/putgfx2.png">
			<br \=""><br \="">
			{{fbdoc item="diff"}}<br \="">  	- ##//target//## est nouveau pour FreeBASIC
			- Les m&eacute;thodes ##TRANS##, ##ALPHA##, ##ADD## et ##CUSTOM## sont nouvelles pour FreeBASIC.<br \="">  </li>  	- Dans QB, la destination est toujours l&apos;&eacute;cran.<br \="">  </li>  	- QB produit une erreur de fonctionnement en cas d&apos;&eacute;criture en dehors des limites de l&apos;image.<br \="">  </li>  	- Dans QB, seuls des tableaux (arrays) peuvent &ecirc;tre sp&eacute;cifi&eacute;s comme images source.<br \=""><br \="">  </li>
			{{fbdoc item="see"}}<br \="">	- ##[[KeyPgPutfileio Put (File Entr&eacute;/Sortie)]]##<br \=""></li>	- ##[[KeyPgGetgraphics Get (Graphique)]]##<br \=""></li>	- ##[[KeyPgImagecreate ImageCreate]]##<br \=""></li>	- ##[[KeyPgAlphaGfx Alpha]]##<br \=""></li>	- [[GfxInternalFormats Formats graphiques internes]]<br \=""><br \=""></li>

	##//value//##
		is a ##0..255## value specifying the transparency value for an ##ADD## or ##ALPHA## method blit.
	##//blender//## 
		specifies the address of a user-defined function to be called in a ##CUSTOM## method blit. See below.
	##//param//## 
		specifies a parameter to pass to the custom blender.

{{fbdoc item="desc"}}
	The ##**Put**## statement can be used to draw an image onto another image. The ##//x//## and ##//y//## coordinates are affected by the last call to the ##[[KeyPgViewgraphics View]]## and ##[[KeyPgWindow Window]]## statements, and plotted image respects the current clipping region set by last call to the ##[[KeyPgViewgraphics View]]## statement. The source image is clipped if it is drawn outside the destination buffer.

	**Valid Image Buffers**
		The ##//source//## and ##//target//## image buffers must be valid image buffers. Valid image buffers are created using the ##[[KeyPgGetgraphics Get]]## or ##[[KeyPgImagecreate ImageCreate]]## statements. Valid image buffers can be specified in a ##**Put**## statement using an array name with optional index, or a pointer with optional index.

	**Drawing methods**
		Depending on the method used, the existing pixel values in the destination buffer are used to calculate the pixel values that are actually drawn. The ##PSET##, ##PRESET## and ##TRANS## methods do not use the destination buffer for calculating final pixel values, while the ##AND##, ##OR##, ##XOR##, ##ALPHA## and ##ADD## methods do. Images that are drawn with these latter methods will look differently depending on the content of the destination buffer.

	**Different pixel formats**
		The pixel format of an image buffer must be compatible with the current graphics mode color depth; that is, if you acquire an image using ##[[KeyPgGetgraphics Get]]## and you later change screen mode via the ##[[KeyPgScreengraphics Screen]]## statement, the image data may not be valid in the new graphics mode, and you may not be able to draw it on the screen. You should note however that you will always be able to draw image buffers onto other image buffers via ##**Put**## as long as these buffers were created with the same depth.

		The ##AND##, ##OR## and ##XOR## methods produce different results depending on the current color depth, as pixels are stored in different formats; see [[GfxInternalFormats Internal pixel formats]] for details. 

	**Mask Color**
		The ##TRANS##, ##ALPHA## and ##ADD## methods do not draw pixels in the source image that use the mask color. The mask color depends on target (being it an image buffer or the screen) depth: in depths up to 8 bpp (paletted modes) it is equal to color index ##0##, while in hi/truecolor depths (16 and 32 bpp) it is equal to magenta, which is ##[[KeyPgRgb RGB]](255, 0, 255)##. Note that in 32 bpp modes the alpha value of a color does not affect the identification of the transparent color; only the lower 24 bits are used to identify it. See [[GfxInternalFormats Internal pixel formats]] for details. 

	**Alpha drawing**
		The ##ALPHA## method can be used in two modes. If the ##//value//## parameter is specified, this is used to specify the level of transparency for the whole image to be drawn; a value of 0 will draw a completely transparent image, whereas a value of 255 will draw a completely solid one. This mode works only when drawing onto hi/truecolor targets (16 and 32 bpp).
		If the ##//value//## parameter is omitted, the ##ALPHA## method will take the alpha level value on a per-pixel basis, allowing to draw images with an alpha channel (certain parts of the image can be made more or less transparent than others). This mode works only with 32 bpp image buffers, as this is the only color depth that allows for an embedded alpha value in each pixel.

	**Dealing with the alpha channel**
		Normally ##**Put**## only allows to draw image buffers onto targets with the same depth, but there is an exception. When drawing an 8 bpp image buffer onto a 32 bpp target and the ##ALPHA## method is used, the 8 bpp source image is drawn into the alpha channel of the 32 bpp target. This allows to easily set the whole alpha channel of an image without having to deal with low level access of its pixel data.

	**Custom Blend Function**
		The ##CUSTOM## method uses a user-defined function to calculate the final pixel values to be drawn to the destination buffer. This function will be called once for every pixel of the source image, and will receive the source and destination pixel values, and a data pointer passed by the ##**Put**## function. The pixel value returned will be the value used to draw to the destination buffer. The function has the form:

		##[[KeyPgDeclare declare]] [[KeyPgFunction function]] //identifier// ( [[KeyPgByval byval]] //source_pixel// [[KeyPgAs as]] [[KeyPgUinteger uinteger]], [[KeyPgByval byval]] //destination_pixel// [[KeyPgAs as]] [[KeyPgUinteger uinteger]], [[KeyPgByval byval]] //parameter// [[KeyPgAs as]] [[KeyPgAny any]] [[KeyPgPtr ptr]]) [[KeyPgAs as]] [[KeyPgUinteger uinteger]]##

			##//identifier//## is the name of the function. Can be anything.
			##//source_pixel//## is the current pixel value of the source image.
			##//destination_pixel//## is the current pixel value of the destination image.
			##//parameter//## is the parameter that is passed by the ##**Put**## command.  It should be a data ##[[KeyPgPtr Pointer]]##.  If omitted, its value will be zero.

{{fbdoc item="ex"}}
	The following program gives a simple example of how to ##**Put**## an image to the screen, including setting up an image buffer, and freeing its memory after.
	{{fbdoc item="filename" value="examples/manual/gfx/put.bas"}}%%(freebasic)
'' set up the screen and fill the background with a color
screenres 320, 200, 32
paint (0, 0), rgb(64, 128, 255)

'' set up an image and draw something in it
dim img as any ptr = imagecreate( 32, 32, rgb(255, 0, 255) )
circle img, (16, 16), 15, rgb(255, 255, 0),     ,     , 1, f
circle img, (10, 10), 3,  rgb(  0,   0, 0),     ,     , 2, f
circle img, (23, 10), 3,  rgb(  0,   0, 0),     ,     , 2, f
circle img, (16, 18), 10, rgb(  0,   0, 0), 3.14, 6.28

'' PUT the image in the center of the screen
put (160 - 16, 100 - 16), img, trans

'' free the image memory
imagedestroy img

'' wait for a keypress
sleep
%%

{{image class="center" title="Simple Put example output" url="/images/putgfx1.png"}}

	The following example shows how to allocate memory for an image, draw that image using various methods, including a custom blender, and free the memory for the image:
	{{fbdoc item="filename" value="examples/manual/gfx/put-all.bas"}}%%(freebasic)
declare function checkered_blend( byval src as uinteger, byval dest as uinteger, byval param as any ptr ) as uinteger

   screen 14, 32                                   '' set 320*240*32 gfx mode
   
   dim as any ptr sprite
   dim as integer counter = 0
   
   sprite = ImageCreate( 32, 32 )                  '' allocate memory for 32x32 sprite
   
   line sprite, ( 0, 0 )-( 31, 31 ), rgba(255, 0, 0, 64), bf  '' draw a sprite ...
   line sprite, ( 4, 4 )-( 27, 27 ), rgba(255, 0, 0, 192), bf
   line sprite, ( 0, 0 )-( 31, 31 ), rgb(0, 255, 0), b
   line sprite, ( 8, 8 )-( 23, 23 ), rgba(255, 0, 255, 64), bf
   line sprite, ( 1, 1 )-( 30, 30 ), rgba(0, 0, 255, 192)
   line sprite, ( 30, 1 )-( 1, 30 ), rgba(0, 0, 255, 192)
   
   cls
   dim as integer i : for i = 0 to 63              '' draw the background
	  line( i,0 )-( i,240 ), rgb( i * 4, i * 4, i * 4 )
   next i
   
   '' demonstrate all drawing methods ...
   put( 8,14 ), sprite, pset
   put step( 16,20 ), sprite, preset
   put step( -16,20 ), sprite, and
   put step( 16,20 ), sprite, or
   put step( -16,20 ), sprite, xor
   put step( 16,20 ), sprite, trans
   put step( -16,20 ), sprite, alpha, 96
   put step( 16,20 ), sprite, alpha
   put step( -16,20 ), sprite, add, 192
   put step( 16,20 ), sprite, custom, @checkered_blend, @counter
   
   '' print a description near each demo
   draw string (100, 26), "<- pset"
   draw string step (0, 20), "<- preset"
   draw string step (0, 20), "<- and"
   draw string step (0, 20), "<- or"
   draw string step (0, 20), "<- xor"
   draw string step (0, 20), "<- trans"
   draw string step (0, 20), "<- alpha (uniform)"
   draw string step (0, 20), "<- alpha (per pixel)"
   draw string step (0, 20), "<- add"
   draw string step (0, 20), "<- custom"
   
   ImageDestroy( sprite )                          '' free allocated memory for sprite
   sleep : end 0

'' custom blender function: chequered put
function checkered_blend( byval src as uinteger, byval dest as uinteger, byval param as any ptr ) as uinteger
   dim as integer ptr counter
   dim as uinteger pixel
   
   counter = cast(integer ptr, param)
   pixel = iif(((*counter and 4) shr 2) xor ((*counter and 128) shr 7), src, dest)
   *counter += 1
   return pixel
end function
%%

{{image class="center" title="Put example output" url="/images/putgfx2.png"}}

{{fbdoc item="diff"}}
	- ##//target//## is new to ""FreeBASIC""
	- The ##TRANS##, ##ALPHA##, ##ADD## and ##CUSTOM## methods are new to ""FreeBASIC""
	- FB uses a different image format internally, which is unsupported by QB
	- QB throws a run-time error instead of clipping out-of-bounds images
	- In QB, only arrays can be specified as source images

{{fbdoc item="see"}}
	- ##[[KeyPgPutfileio Put (File I/O)]]##
	- ##[[KeyPgGetgraphics Get (Graphics)]]##
	- ##[[KeyPgImagecreate ImageCreate]]##
	- ##[[KeyPgAlphaGfx Alpha]]##
	- [[GfxInternalFormats Internal pixel formats]]

{{fbdoc item="back" value="CatPgGfx2D|2D Drawing Functions"}}