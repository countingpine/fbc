{{fbdoc item="title" value="Introduction To Arrays"}}----
//Ecrit par [[WikiRick rdc]]//

Les tableaux sont sans doute la seule construction de programmation la plus utile qui est à votre disposition dans FreeBASIC. Beaucoup de problèmes que vous allez essayer de résoudre avec une solution de programmation portent sur des données organisées dans un format tabulaire, et les tableaux sont parfaits pour la gestion de ce type de données. Comprendre les tableaux est une compétence essentielle pour devenir un programmeur compétent.

Les tableaux sont des segments de mémoire contigus d'un seul type ou de données composites. Vous pouvez penser un tableau comme une table, avec des lignes et des colonnes de données. Un tableau peut avoir une ou plusieurs lignes, et chaque ligne peut avoir une ou plusieurs colonnes. Le nombre de lignes et de colonnes définissent les dimensions du tableau. FreeBASIC utilise le schéma de "ligne-majeur" pour les tableaux, ce qui signifie que la première référence de dimension, est la ligne, dans un tableau qui a plus d'une dimension. FreeBASIC prend en charge jusqu'à huit dimensions dans un tableau.

=== Tableaux uni-dimensionnels ===

Un tableau avec une seule ligne est appelé tableau uni-dimensionnel. Si un tableau est uni-dimensionnel, alors la ligne n'est pas définie dans la déclaration, seulement le nombre de colonnes dans la ligne. Comme un tableau nécessite un minimum d'une ligne, la ligne est présumée exister dans ce cas. Les extraits de code suivants créent un tableau d'entiers à une seule dimension en utilisant les différents systèmes de définition d'un tableau disponibles dans FreeBASIC.

%%(freebasic)
Dim myArray(10) as Integer

Dim myArray(1 To 10) as Integer
%%

La première méthode définira un tableau avec une seule rangée et 11 colonnes, avec des indices de colonne (numéros) allant de 0 à 10. La seconde méthode définit les limites inférieure et supérieure en utilisant le mot-clé ##**To**##. Ici les indices varieront de 1 à 10.

=== Les indices des tableaux uni-dimensionnels ===

Vous pouvez accéder à chaque élément d'un tableau en utilisant une valeur d'indice. Dans le cas d'un tableau à une dimension, l'indice se réfère à un numéro de colonne dans la ligne par défaut. Le format est d'utiliser le nom de la variable tableau suivi de l'indice entre parenthèses.

%%(freebasic)
myArray(5) = 7
%%

Cela mettra la colonne 5 du tableau à 7.

%%(freebasic)
myInt = myArray(5)
%%

##**myInt**## sera affectée avec la valeur courante de la colonne 5 de ##**myArray**##.

=== Les tableaux bi-dimensionnels ===

Un tableau bi-dimensionnel est un tableau qui a plus d'une rangée, avec des colonnes définies. Un tableau bi-dimensionnel est comme une table, avec un nombre défini de lignes, où chacune a un nombre défini de colonnes. L'extrait de code suivant définit un tableau en utilisant la méthode par défaut.

%%(freebasic)
Dim myArray(2, 10) as Integer
%%

La première dimension définit le nombre de lignes du tableau, alors que la deuxième définit le nombre de colonnes de chaque ligne. Dans cet exemple, le tableau a 3 lignes, numérotées de 0 à 2 et chaque ligne a 11 colonnes, numérotées de 0 à 10.

Vous pouvez aussi définir les bornes inférieure et supérieure d'un tableau.

%%(freebasic)
Dim myArray(1 to 2, 1 to 10) as Integer
%%

Cette définition positionne le nombre de lignes à 2, numérotées de 1 à 2 et le nombre de colonnes à 10, numérotées de 1 à 10.

=== Les indices des tableaux bi-dimensionnels ===

Pour accéder aux éléments d'un tableau bi-dimensionnel, vous devez utiliser deux index. Le premier sélectionne la ligne et le second la colonne de cette ligne.

%%(freebasic)
myArray(1, 5) = 7
%%

Ce code met à 7 la colonne 5 de la ligne 1.

%%(freebasic)
myInt = myArray(1, 5)
%%

##**myInt**## sera affecté avec la valeur courante contenue dans la colonne 5 de la ligne 1 du tableau.

=== Tableaux multi-dimensionnels ===

Pour les tableaux de trois dimensions ou plus, vous devez utiliser le même format que ci-dessus, en tenant compte de la progression des dimensions de tableau. Pour un tableau à trois dimensions, la première dimension serait la ligne, la deuxième la colonne, la troisième serait l'ordre-z, ou la profondeur, pour chaque colonne. 

Par exemple, pour définir un cube dans l'espace, vous devez utiliser les formats y, x, z, où y définit l'axe vertical, x l'axe horizontal et z l'axe de la profondeur. Pour créer un tableau dans ce format, vous pouvez définir le tableau ainsi: 

%%(freebasic)
Dim myCube(y, x, z) as Integer. 
%%

##**MyCube(10, 10, 10)**## créera un cube de 11 unités verticalement, 0 à 10, 11  unités horizontalement, 0 à 10 et 10 unités en profondeur, 0 à 10. Pour accéder au centre du cube, vous pouvez utiliser ##**iCenter = myCube(5, 5, 5)**##. 

Vous n'aurez probablement jamais besoin d'utiliser des tableaux de plus de trois dimensions, à moins que vous accomplissiez des calculs mathématiques avancés. Toutefois, si vous avez besoin d'utiliser des tableaux de dimensions supérieures, les mêmes principes s'appliquent.

=== Les tableaux dynamiques ===

Les tableaux décrits ci-dessus sont des tableaux statiques; la taille du tableau ne peut pas changer au cours de l'exécution du programme. Vous pouvez également créer des tableaux dynamiques qui peuvent changer de taille au cours de l'exécution. Les tableaux dynamiques sont utiles pour créer des structures de données telles que les piles ou les files d'attente.

Les tableaux statiques, ceux décrits ci-dessus, sont conservés sur le tas (heap), alors que les tableaux dynamiques sont attribuées partir du stock (pool) de mémoire de l'ordinateur. Le compilateur alloue dynamiquement la mémoire pour le tableau sur la base des dimensions demandées par le tableau.

Vous spécifiez un tableau dynamique en utilisant le mot-clef ##**ReDim**##.

%%(freebasic)
Redim myArray(1 to 5, 1 to 5) as Integer
%%

Si vous ne connaissez pas les limites du tableau nécessaires au début de l'exécution du programme, vous pouvez définir un tableau avec des des indices vides.

%%(freebasic)
Dim myArray() as Integer
%%

Dans ce cas, le compilateur définit une valeur par défaut de 0 pour la taille du tableau. Vous pouvez ensuite utiliser le mot-clef ##**ReDim**## à un moment donné dans le programme pour définir les limites de tableau.

=== ReDim et ReDim Preserve ===

Les tableaux dynamiques peuvent changer de taille pendant l'exécution. ##**ReDim**## efface le contenu du tableau avec les valeurs par défaut du type de données, alors que ##**ReDim Preserve**## conservera intact le contenu existant, à moins que la taille du tableau ne soit plus petite que la taille précédente.

=== Fonctions sur les tableaux ===

Il ya un certain nombre de [[CatPgArray fonctions]] que vous pouvez utiliser avec des tableaux.

=== Tableaux de Types composites ===

Les définitions de ##**Type**## vous permettent de regrouper des données liées en une seule entité, et souvent vous aurez besoin de plus d'une instance d'un ##**Type**## pour exprimer pleinement vos données. Des tableaux de ##**Type**## vous permettent de créer plusieurs instances d'une définition de ##**Type**## qui peuvent être facilement gérées à l'aide des fonctions tableaux. Un exemple de cet usage peut être un système d'inventaire pour votre RPG (Role Playing Game = Jeu de rôles), une série de descriptions de documents dans un éditeur et un ensemble de fiches d'employés d'une base de données à accès aléatoire.

Vous créez des tableaux de ##**Type**##s comme vous le feriez avec n'importe quel type de données intrinsèques. L'extrait de code suivant illustre la syntaxe.

%%(freebasic)
Type myPoint
	row As Integer
	col As Integer
End Type

Type myLine
	p1 As myPoint
	p2 As myPoint
	char As String * 1
End Type

Dim myLineSet (1 to 3) as myLine
%%

Le code définit un ensemble de 3 lignes, avec les points d'extrémités ##**p1**## et ##**p2**##, où chaque point d'extrémité se situe à ##**row**## et ##**col**##. Vous pouvez accéder aux éléments du tableau en utilisant une combinaison d'indice de tableau et d'opérateur point.

%%(freebasic)
myLineSet(1).p1.row = 1
myLineSet(1).p1.col = 1
myLineSet(1).p2.row = 10
myLineSet(1).p2.col = 10
myLineSet(1).char = chr(219)
%%

=== Les tableaux dans les ##**Type**##s ===

Non seulement vous pouvez créer un tableau de ##**Type**## composite, vous pouvez avoir un tableau comme champ dans un ##**Type**## composite. L'exemple ci-dessus peut être écrit de manière plus efficace en remplaçant ##**p1**## et ##**p2**## avec un tableau.

%%(freebasic)
Type myPoint
	row As Integer
	col As Integer
End Type

Type myLine
	pts(1 to 2) As myPoint
	char As String * 1
End Type

Dim myLineSet (1 to 3) as myLine
%%

Ici ##**pts**## est un tableau de ##**myPoint**##. Pour accéder à cette structure vous pouvez utiliser une combinaison d'indices et d'opérateurs points.

%%(freebasic)
myLineSet(1).pts(1).row = 1
myLineSet(1).pts(1).col = 1
myLineSet(1).pts(2).row = 10
myLineSet(1).pts(2).col = 10
myLineSet(1).char = chr(219)
%%

##**myLineSet**## est un tableau, donc vous utilisez une valeur d'indice. ##**pts**## est un élément du ##**Type**##, donc vous devez le qualifier avec l'opérateur point. Cependant, ##**pts**## est aussi un tableau, donc vous devez utiliser un indice pour sélectionner chaque élément ##**pts**## du tableau. ##**Row**## et ##**col**## sont des éléments du ##**Type**## "##**myPoint**##" et sont accessibles avec l'opérateur point.

Utiliser un tableau pour les points de terminaison vous permet d'étendre facilement la définition de la ligne pour supporter autre chose que des lignes, par exemple des triangles et des carrés. L'extrait de code suivant montre une définition possible.

%%(freebasic)
Type myObj
	objid As Integer
	Union
			myLine(1 To 2) As myPoint
		myTriangle(1 To 3) As myPoint
		mySquare(1 To 4) As myPoint
	End Union
	char As String * 1
End Type
%%

Le champ ##**objid**## indique quel ##**Type**## d'objet est contenu dans la définition de l'##**Union**##. C'est à dire qu' un 1 peut indiquer une ligne, un 2 un triangle et un 3 un carré. Puisque la définition définit un objet unique, une ##**Union**## est utilisée pour inclure les tableaux des points d'extrémités pour maximiser l'utilisation de la mémoire. 

Pour afficher l'objet à l'écran, examiner ##**objid**## puis utiliser ##**objid**## et ##**Ubound**## de la définition appropriée du tableau des points-extrémités, afficher le nombre de lignes qui correspondent au type d'objet. 

L'une des améliorations supplémentaires que vous pouvez apporter à ce programme est d'ajouter un pointeur de fonction vers la définition de type puis écrire des routines d'affichage qui correspondent au type d'objet affiché. Cette technique vous permettra d'étendre encore l'utilité du code en simplifiant le processus d'ajout de nouveaux objets à la définition de type. 

Par exemple, si vous avez besoin de décrire un cube, vous pouvez tout simplement ajouter un nouveau tableau à l'##**Union**##, ajouter une fonction d'affichage de cube, et la définition du type serait en mesure d'afficher un cube en ajoutant simplement quelques lignes de code, tout en conservant la fonctionnalité d'origine intacte.

=== Initialisation de tableau ===

Vous pouvez initialiser un tableau avec des valeurs en utilisant la déclaration ##**Dim**## d'une manière similaire à l'initialisation de tous les autres types de données intrinsèques et de définitions de type. L'extrait de code suivant illustre la syntaxe en utilisant un tableau uni-dimensionnel.

%%(freebasic)
Dim aArray(1 to 5) As Integer => {1, 2, 3, 4, 5}
%%

Cet extrait de code dimensionne un tableau d'entiers avec 5 éléments, puis définit les éléments avec la liste contenue dans les accolades. L'opérateur flèche, ##**=>**## indique au compilateur que la liste qui suit l'instruction ##**Dim**## doit être utilisée pour initialiser le tableau. 

Vous pouvez également dimensionner des tableaux multi-dimensionnels de la même manière, en spécifiant des blocs de données figurant dans des accolades comme l'extrait de code suivant l'illustre.

%%(freebasic)
Dim bArray(1 to 2, 1 to 5) As Integer => {{1, 2, 3, 4, 5},{6, 7, 8, 9, 10}}
%%

Dans cet exemple, le premier bloc, ##**{1, 2, 3, 4, 5}**##, correspond à la ligne 1, et le deuxième bloc, ##**{6, 7, 8, 9, 10}**##, correspond à la ligne 2. Rappelez-vous que les tableaux FreeBASIC sont "ligne-majeur", ainsi la ligne est spécifiée avant la colonne. Lorsque vous initialisez un tableau de cette manière, vous devez être sûr que le nombre d'éléments définis s'intégrera dans le tableau.

=== Initialisation de tableau de ##**Type**## ===

Non seulement vous pouvez initialiser un tableau de ##**Type**##s de données simples, Vous pouvez également initialiser un tableau avec des ##**Type**##s composites. L'extrait de code suivant illustre un tableau de ##**Type**##s qui contient lui-même un tableau comme un élément.

%%(freebasic)
Type aType
	a As Integer
	b As Byte
	c(1 To 2) As String * 10
End Type

Dim As aType myType(1 To 2) => { (1234, 12, {"Hello", "World"}), (5678, 24, {"From", "Freebasic"})} 
%%

Les accolades signifient qu'il s'agit d'une initialisation de tableau, tandis que les parenthèses indiquent l'initialisation d'un ##**Type**##. Comme le ##**Type**## contient un tableau, vous pouvez utiliser les accolades pour charger les données dans ce tableau incorporé, comme vous le feriez avec un tableau autonome. Si le tableau incorporé est un tableau multi-dimensionnel, vous aurez alors besoin d'envelopper chaque ligne avec ##**{**## et ##**}**## comme vous le feriez pour un tableau autonome. 

=== Utilisation du commutateur de compilation -exx ===

Le commutateur de compilation ##**-exx**## permettra le contrôle des erreurs et la vérification des limites de tableau au sein de votre programme. Si vous allez à l'extérieur des limites d'un tableau dans votre programme, le compilateur génère une erreur "##**out of bounds**##" lorsque le programme est en cours d'exécution. 

Ceci est une grande aide dans le débogage de votre programme et pour trouver des problèmes liés aux tableaux. ##**-exx**## vous informera également des assignations de pointeur NULL, il est donc aussi très utile lorsque vous travaillez avec des pointeurs. 

Utiliser ##**-exx**## ajoute un peu de code supplémentaire à votre programme, donc une fois que votre programme fonctionne correctement, compilez-le sans ##**-exx**##.