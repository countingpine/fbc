{{fbdoc item="title" value="Type Aliases"}}----
D'autres noms pour les types de variable ou d'objet

**[[#OVERVIEW">Vue d'ensemble]]**
**[[#DECL">D&eacute;claration]]**
**[[#OVERLOAD">R&eacute;solution de la surcharge]]**
**[[#PROCPTRPTR">Pointeurs de pointeurs de proc&eacute;dure]]**
**[[#TYPEFORWARD">Transmission de type]]**
**[[#INCTYPES">Types incomplets]]**

<a name="OVERVIEW"></a>{{fbdoc item="section" value="Vue d'ensemble
	Les alias de type sont d'autres noms pour un type. Ils peuvent &ecirc;tre utilis&eacute;s pour faciliter un changement en masse d'un type &agrave; un autre, en diminuant la frappe ou rendre possible une d&eacute;pendance circulaire.

<a name="DECL"></a>
	{{fbdoc item="section" value="D&eacute;claration

	Les alias de type sont d&eacute;clar&eacute;s en utilisant le mot-cl&eacute; ##[[KeyPgTypeAlias Type]]## un peu comme la d&eacute;claration de variables ou d'objects avec [[KeyPgExtern Extern]] ou [[KeyPgDim Dim]].

	L'exemple suivant d&eacute;clare un alias de type ##[[KeyPgSingle Single]]## appel&eacute; "##//float//##", une proc&eacute;dure et d&eacute;finit et initialise deux variables de ce type:
type float as single

Type float As Single

Declare Function add (a As float, b As float) As float
Dim foo As float = 1.23
		Dim bar As float = -4.56

	%%

	Les alias de type de pointeur de proc&eacute;dure sont d&eacute;clar&eacute;s de la m&ecirc;me fa&ccedil;on, comme le montre l'exemple suivant:
Declare Function f (ByRef As String) As Integer

Declare Function f (ByRef As String) As Integer

Type func_t As Function (ByRef As String) As Integer
		
Dim func As func_t = @f
	Function f (ByRef arg As String) As Integer
Function = CInt(arg)
End Function

%%
	<a name="OVERLOAD"></a>

	{{fbdoc item="section" value="R&eacute;solution de la surcharge

	Les alias de type ne sont que cela - des alias. A toutes fins utiles, un alias de type **est** du type qu'il remplace. Ainsi dans le cas o&ugrave; la r&eacute;solution de la surcharge de proc&eacute;dure est concern&eacute;e, une proc&eacute;dure d&eacute;clar&eacute;e avec un param&egrave;tre de type "##//alias_vers_T//##" est la m&ecirc;me qu'une proc&eacute;dure d&eacute;clar&eacute;e avec un param&egrave;tre de type "##//T//##" (la m&ecirc;me chose s'applique ainsi &agrave; la surcharge membres des proc&eacute;dures).
En d'autres termes, c'est une erreur -double d&eacute;finition- de d&eacute;clarer une proc&eacute;dure o&ugrave; les param&egrave;tres ne diff&egrave;rent que par un type et son alias, comme l'exemple suivant le montre:

Declare Sub f Overload (a As Single)

Type float As Single
Declare Sub f Overload (a As Single)
'' If uncommented, this will generate a duplicated definition error

'' Declare Sub f (a As float)
	%%

	<a name="PROCPTRPTR"></a>

	{{fbdoc item="section" value="Pointeurs de pointeurs de proc&eacute;dure
Les pointeurs de pointeurs de proc&eacute;dure sont comme n'importe quel autre type de pointeur, sauf qu'ils pointent vers des pointeurs de proc&eacute;dure. Parce que la syntaxe pour d&eacute;clarer des pointeurs de proc&eacute;dure ne permet pas de cr&eacute;er directement un pointeur sur pointeur de proc&eacute;dure, un alias de type est utilis&eacute;.

L'exemple suivant d&eacute;clare un pointeur vers une de proc&eacute;dure retournant un pointeur d'entier, puis un pointeur vers un pointeur vers une de proc&eacute;dure retournant un entier:
dim ppf as pf_t ptr
	Dim pf As Function() As Integer Ptr

Type pf_t As Function() As Integer
	Dim ppf As pf_t Ptr

	%%
<a name="TYPEFORWARD"></a>

{{fbdoc item="section" value="Transmission de type
  Des alias de type peuvent &ecirc;tre avant le r&eacute;f&eacute;rencement: un alias peut faire r&eacute;f&eacute;rence &agrave; un autre type qui n'est pas encore enti&egrave;rement d&eacute;fini.
END TYPE

Type foo As bar
  Type sometype
  f   As foo Ptr
END TYPE
	Type bar

	st  As sometype

	a   As Integer
End Type

%%
  En utilisant un alias de type et un r&eacute;f&eacute;rencement pr&eacute;coce permet des d&eacute;pendances circulaires entre les types.
  %%(freebasic)
Type list As list_

Type listnode
  parent As list Ptr
  text As String
END TYPE
	Type list_

first As listnode Ptr
	 count As Integer
	
	End Type

	%%
<a name="INCTYPES"></a>

{{fbdoc item="section" value="Types incomplets
Un type est consid&eacute;r&eacute; comme incomplet jusqu'&agrave; ce que la taille de celui-ci (c'est le nombre d'octets qui lui sont n&eacute;cessaires en m&eacute;moire) soit connue ainsi que les positions de tous ses champs.  Il n'est pas possible d'allouer de l'espace m&eacute;moire pour un type incomplet.  Il n'est pas possible de d&eacute;clarer une variable ayant un type de donn&eacute;es incomplet, de passer un type incomplet comme param&egrave;tre ou d'acc&eacute;der aux membres d'un type incomplet.
Toutefois, des pointeurs vers des types incomplets peuvent &ecirc;tre attribu&eacute;s, d&eacute;clar&eacute;s comme membres dans d'autres types ou pass&eacute;s comme param&egrave;tres &agrave; une proc&eacute;dure, d&egrave;s lors que la taille d'un pointeur est connue.
'' END TYPE

Type sometype As sometype_
'' Not allowed since size of sometype is unknown
  '' TYPE incomplete
''   a AS sometype
'' END TYPE

'' Allowed since size of a pointer is known
Type complete

a As sometype Ptr
End Type
  Dim x As complete
'' Not allowed since size of sometype is still unknown

'' DIM size_sometype AS INTEGER = SIZEOF( sometype )
'' Complete the type

Type sometype_
  value As Integer
END TYPE

'' Allowed since the types are now completed
	Dim size_sometype As Integer = SizeOf( sometype )


Type completed
   
