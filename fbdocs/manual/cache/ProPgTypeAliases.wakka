{{fbdoc item="title" value="Type Aliases"}}----
D'autres noms pour les types de variable ou d'objet

**{{anchor name="OVERVIEW|Vue d'ensemble"}}**
**{{anchor name="DECL|Déclaration"}}**
**{{anchor name="OVERLOAD|Résolution de la surcharge"}}**
**{{anchor name="PROCPTRPTR|Pointeurs de pointeurs de procédure"}}**
**{{anchor name="TYPEFORWARD|Transmission de type"}}**
**{{anchor name="INCTYPES|Types incomplets"}}**

{{anchor name="OVERVIEW"}}{{fbdoc item="section" value="Vue d'ensemble"}}
	Les alias de type sont d'autres noms pour un type. Ils peuvent être utilisés pour faciliter un changement en masse d'un type à un autre, en diminuant la frappe ou rendre possible une dépendance circulaire.

{{anchor name="DECL"}}{{fbdoc item="section" value="Déclaration"}}
	Les alias de type sont déclarés en utilisant le mot-clé ##[[KeyPgTypeAlias Type]]## un peu comme la déclaration de variables ou d'objects avec [[KeyPgExtern Extern]] ou [[KeyPgDim Dim]].

	L'exemple suivant déclare un alias de type ##[[KeyPgSingle Single]]## appelé "##//float//##", une procédure et définit et initialise deux variables de ce type:

	{{fbdoc item="filename" value="examples/manual/proguide/typalias/builtin.bas"}}%%(freebasic)
type float as single

declare function add (a as float, b as float) as float

dim foo as float = 1.23
dim bar as float = -4.56
		%%

	Les alias de type de pointeur de procédure sont déclarés de la même façon, comme le montre l'exemple suivant:

	{{fbdoc item="filename" value="examples/manual/proguide/typalias/procptr_1.bas"}}%%(freebasic)
Declare Function f (ByRef As String) As Integer

Type func_t As Function (ByRef As String) As Integer

Dim func As func_t = @f
		
Function f (Byref arg as String) as Integer
	Function = Cint(arg)
End Function
%%

{{anchor name="OVERLOAD"}}{{fbdoc item="section" value="Résolution de la surcharge"}}
	Les alias de type ne sont que cela - des alias. A toutes fins utiles, un alias de type **est** du type qu'il remplace. Ainsi dans le cas où la résolution de la surcharge de procédure est concernée, une procédure déclarée avec un paramètre de type "##//alias_vers_T//##" est la même qu'une procédure déclarée avec un paramètre de type "##//T//##" (la même chose s'applique ainsi à la surcharge membres des procédures).

	En d'autres termes, c'est une erreur -double définition- de déclarer une procédure où les paramètres ne diffèrent que par un type et son alias, comme l'exemple suivant le montre:

	{{fbdoc item="filename" value="examples/manual/proguide/typalias/overload.bas"}}%%(freebasic)
Type float As Single

Declare Sub f Overload (a As Single)

'' If uncommented, this will generate a duplicated definition error
'' Declare Sub f (a As float)
%%

{{anchor name="PROCPTRPTR"}}{{fbdoc item="section" value="Pointeurs de pointeurs de procédure"}}
	Les pointeurs de pointeurs de procédure sont comme n'importe quel autre type de pointeur, sauf qu'ils pointent vers des pointeurs de procédure. Parce que la syntaxe pour déclarer des pointeurs de procédure ne permet pas de créer directement un pointeur sur pointeur de procédure, un alias de type est utilisé.

	L'exemple suivant déclare un pointeur vers une de procédure retournant un pointeur d'entier, puis un pointeur vers un pointeur vers une de procédure retournant un entier:

	{{fbdoc item="filename" value="examples/manual/proguide/typalias/procptr_2.bas"}}%%(freebasic)
dim pf as function() as integer ptr

type pf_t as function() as integer
dim ppf as pf_t ptr
	%%

{{anchor name="TYPEFORWARD"}}{{fbdoc item="section" value="Transmission de type"}}
	Des alias de type peuvent être avant le référencement: un alias peut faire référence à un autre type qui n'est pas encore entièrement défini.

	{{fbdoc item="filename" value="examples/manual/proguide/typalias/fwd_1.bas"}}%%(freebasic)
TYPE foo AS bar

TYPE sometype
  f   AS foo PTR
END TYPE

TYPE bar
  st  AS sometype
  a   AS INTEGER
END TYPE
	%%

	En utilisant un alias de type et un référencement précoce permet des dépendances circulaires entre les types.

	{{fbdoc item="filename" value="examples/manual/proguide/typalias/fwd_2.bas"}}%%(freebasic)
TYPE list as list_

TYPE listnode
  parent AS list PTR
  text AS string
END TYPE

TYPE list_
  first AS listnode PTR
  count AS integer
END TYPE
	%%

{{anchor name="INCTYPES"}}{{fbdoc item="section" value="Types incomplets"}}
	 Un type est considéré comme incomplet jusqu'à ce que la taille de celui-ci (c'est le nombre d'octets qui lui sont nécessaires en mémoire) soit connue ainsi que les positions de tous ses champs.  Il n'est pas possible d'allouer de l'espace mémoire pour un type incomplet.  Il n'est pas possible de déclarer une variable ayant un type de données incomplet, de passer un type incomplet comme paramètre ou d'accéder aux membres d'un type incomplet.
	
	Toutefois, des pointeurs vers des types incomplets peuvent être attribués, déclarés comme membres dans d'autres types ou passés comme paramètres à une procédure, dès lors que la taille d'un pointeur est connue.

	{{fbdoc item="filename" value="examples/manual/proguide/typalias/incomp.bas"}}%%(freebasic)
TYPE sometype AS sometype_

'' Not allowed since size of sometype is unknown
'' TYPE incomplete
''   a AS sometype
'' END TYPE

'' Allowed since size of a pointer is known
TYPE complete
  a AS sometype ptr
END TYPE
DIM x AS complete

'' Not allowed since size of sometype is still unknown
'' DIM size_sometype AS INTEGER = SIZEOF( sometype )

'' Complete the type
TYPE sometype_
  value as integer
END TYPE

'' Allowed since the types are now completed
DIM size_sometype AS INTEGER = SIZEOF( sometype )

TYPE completed
  a AS sometype
END TYPE

DIM size_completed AS INTEGER = SIZEOF( completed )
	%%


{{fbdoc item="back" value="CatPgProgrammer|Programmer's Guide"}}
   
