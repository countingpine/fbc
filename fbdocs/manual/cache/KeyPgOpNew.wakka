{{fbdoc item="title" value="Operator New"}}----
Op&eacute;rateur qui alloue dynamiquement de la m&eacute;moire et construit une donn&eacute;e du type sp&eacute;cifi&eacute;

{{fbdoc item="syntax"}}##
	[[KeyPgDeclare declare]] [[KeyPgOperator operator]] **new** ( //size// [[KeyPgAs as]] [[KeyPgUinteger uinteger]] ) [[KeyPgAs as]] [[KeyPgAny any]] [[KeyPgPtr ptr]]
	[[KeyPgDeclare declare]] [[KeyPgOperator operator]] **new[]** ( //size// [[KeyPgAs as]] [[KeyPgUinteger uinteger]] ) [[KeyPgAs as]] [[KeyPgAny any]] [[KeyPgPtr ptr]]
##
{{fbdoc item="usage"}}##
	//result// = **New** //[[DataType datatype]]//
		//ou//
	//result// = **New** //[[DataType datatype]]// ( //initializers//, ... )
		//ou//
	//result// = **New** //[[DataType datatype]]//**[** //count// **]**
##
{{fbdoc item="param"}}
	##//size//## 
		Nombre d'octets &agrave; allouer.
	##//initializers//##
		Valeur(s) pour initialiser la variable.
	##//datatype//##
		Nom du type de donn&eacute;e &agrave; cr&eacute;er.
	##//count//##
		Nombre exact d'&eacute;l&eacute;ments &agrave; allouer.

{{fbdoc item="section" value="Valeur retourn&eacute;e
	Un pointeur du type [[DataType datatype]] vers la nouvelle donn&eacute;e allou&eacute;e.

{{fbdoc item="desc"}}
	L'op&eacute;rateur ##**New**## alloue dynamiquement de la m&eacute;moire et construit une donn&eacute;e du type sp&eacute;cifi&eacute;. Pour des types simples, comme les entiers, une valeur initiale peut &ecirc;tre attribu&eacute;e. Pour des types sans constructeur(s), des valeurs initiales peuvent &ecirc;tre sp&eacute;cifi&eacute;es pour chaque champ. Les types qui ont des constructeurs, ceux-ci peuvent &ecirc;tre appel&eacute;s par ##**New**##. Si aucun initialiseur n'est fourni, les valeurs par d&eacute;faut seront attribu&eacute;es pour ces types.

	##**New[]**## est la version pour les tableaux de l'op&eacute;rateur ##**New**## et alloue suffisamment de m&eacute;moire pour le nombre d'objets sp&eacute;cifi&eacute;.  Le constructeur par d&eacute;faut pour le type sera utilis&eacute; pour initialiser chacun des &eacute;l&eacute;ments.

	Les objects cr&eacute;&eacute;s avec ##**New**## doivent &ecirc;tre lib&eacute;r&eacute;s avec ##[[KeyPgOpDelete Delete]]##. La m&eacute;moire allou&eacute;e avec ##**New[]**## doit &ecirc;tre lib&eacute;r&eacute;e avec ##**Delete[]**##, la version pour les tableaux de ##[[KeyPgOpDelete Delete]]##. Vous ne pouvez pas m&eacute;langer les deux versions de l'op&eacute;rateur.

	Sp&eacute;cifier une valeur initiale ##[[KeyPgAny Any]]##, comme dans ##new datatype(any)## allouera de la m&eacute;moire pour le type, mais n'initialisera pas les donn&eacute;es.  Ceci n'est valide que pour les types qui n'ont pas de constructeur.

	Sp&eacute;cifier une valeur initiale ##[[KeyPgAny Any]]##, comme dans ##new datatype[count]{any}## allouera de la m&eacute;moire pour le tableau, mais n'initialisera pas les donn&eacute;es.  Ceci n'est valide que pour les types qui n'ont pas de constructeur.

	{{fbdoc item="ex"}}

{{fbdoc item="ex"}}
Type Rational
As Integer    numerator, denominator
	End Type
Scope

' Create and initialize a Rational, and store it's address.

	Dim p As Rational Ptr = New Rational(3, 4)
	Print p->numerator & "/" & p->denominator

	' Destroy the rational and give its memory back to the system. 

	Delete p
	End Scope

Scope

' Allocate memory for 100 integers, store the address of the first one.

	Dim p As Integer Ptr = New Integer[100]
	' Assign some values to the integers in the array.

	For i As Integer = 0 To 99
	p[i] = i
		Next
	' Free the entire integer array.

	Delete[] p
	End Scope

%%
{{fbdoc item="lang"}}
- Utilisable seulement dans le dialecte //[[CompilerOptlang -lang fb]]//.
	{{fbdoc item="diff"}}

- Nouveau pour FreeBASIC
	{{fbdoc item="see"}}

- ##[[KeyPgOpDelete Delete]]##
	- ##[[KeyPgOpPlacementNew Placement New]]##
	- ##[[KeyPgOpPlacementNew Placement New]]##

{{fbdoc item="back" value="CatPgOpMemory|Memory Operators"}}{{fbdoc item="back" value="CatPgOperators|Operators"}}