{{fbdoc item="title" value="Simulating Polymorphism"}}----
//Ecrit par [[WikiRick rdc]]//

<div class="fb_header"> Introduction

Le polymorphisme est un outil puissant dans les programmes orient&eacute;s-objet. Une m&eacute;thode polymorphe (Sub ou Function) se comporte diff&eacute;remment selon la d&eacute;finition de l'objet. Par exemple, un objet "animal" peut avoir une m&eacute;thode "parler" qui &eacute;mettra un aboiement pour un chien et un miaulement d'un chat. FreeBASIC ne supporte pas encore le vrai polymorphisme, il sera ajout&eacute; lorsque les classes seront impl&eacute;ment&eacute;es. Cependant, vous pouvez simuler les m&eacute;thodes polymorphes en utilisant les m&eacute;thodes pointeurs. 

<div class="fb_header"> Polymorphisme

Les m&eacute;thodes polymorphes sont des "Sub" ou des "Function" qui ont le type et la m&ecirc;me liste des param&egrave;tres, mais qui se comportent diff&eacute;remment lorsqu'elles sont li&eacute;es &agrave; des objets diff&eacute;rents. Un objet "animal" peut avoir une m&eacute;thode "parler" qui &eacute;mettra un aboiement pour un chien et un miaulement d'un chat.Comme FreeBASIC ne conna&icirc;t pas encore les classes, vous ne pouvez impl&eacute;menter de vraies m&eacute;thodes polymorphes,  you cannot implement true polymorphic methods, mais vous pouvez simuler leur comportement en utilisant des m&eacute;thodes pointeurs.

Le listing suivant montre un couple de "#define" et une d&eacute;claration de type &eacute;tendu:
%%(freebasic)
#define isdog 1
#define iscat 2

Type animal
	Public:
	speak As Sub()
	Declare Constructor (anid As Integer)    
End Type
%%
Les "#define" sont pass&eacute;s au constructeur (Constructor) pour lui signaler quel type d'objet sera cr&eacute;&eacute;. La d&eacute;finition "speak As Sub()" d&eacute;finit la m&eacute;thode pointeur. Comme vousle voyez, l'adresse de deux sous-programmes diff&eacute;rents sera pass&eacute;e &agrave; la m&eacute;thode pointeur "speak". Le listing suivant montre les sous-programmes speak diff&eacute;rents et la m&eacute;thode Constructor:
%%(freebasic)
'Speak method for dog object
Sub Bark()
	Print "Woof!"
End Sub

'Speak method for cat object
Sub <span class="wrd"ttt>Meow()
	Print "Meow!"
End Sub

'Set the proper method pointer based on animal id
Constructor animal(anid As Integer)
	If anid = isdog Then
	    this.speak = @Bark
	Elseif anid = iscat Then
	    this.speak = @Meow
	End If
End Constructor
%%
Le sous-programmes "Bark" sera appel&eacute; si l'objet est un chien et "Meow" si c'est un chat. Vous vous demandez pourquoi on n'a pas surcharg&eacute; la m&eacute;thode? Pour surcharger une m&eacute;thode, le type et la liste de param&egrave;tres doivent &ecirc;tre uniques, o&ugrave; dans une m&eacute;thode polymorphe, le type et le param&egrave;tre doivent &ecirc;tre le m&ecirc;me. Comme "Bark" et "Meow" ont la m&ecirc;me liste de param&egrave;tres, c'est &agrave; dire aucun param&egrave;tre, vous ne pouvez pas surcharger cette m&eacute;thode.

C'est dans le code du Constructor que se d&eacute;cide quelle m&eacute;thode &agrave; appeler pour l'utiliser. Si "anid" est &eacute;gal &agrave; "isdog", alors la m&eacute;thode pointeur "Speak" sera fix&eacute;e sur l'adresse du sous-programme "Bark". Si "anid" est &eacute;gal &agrave; "iscat",  alors la m&eacute;thode pointeur "Speak" sera fix&eacute;e sur l'adresse du sous-programme "Meow". L'op&eacute;rateur @ (adresse de) est utilis&eacute; pour passer l'adresse de "Bark" et "Meow" au pointeur "Speak". 

La r&eacute;f&eacute;rence objet //this// est un param&egrave;tre cach&eacute; qui est pass&eacute; au constructeur et qui fait r&eacute;f&eacute;rence au type, qui dans ce cas est "animal". Vous pouvez l'utiliser pour r&eacute;f&eacute;rencer les variables internes au sein du type.

La seule chose qui reste &agrave; faire est de cr&eacute;er et d'initialiser l'objet:
%%(freebasic)
'Create a dog and cat object
Dim myDog As animal = isdog
Dim mycat As animal = iscat
%%
Ici "myDog" et "myCat" sont cr&eacute;&eacute;s avec les indicateurs appropri&eacute;s pass&eacute;s au constructeur ainsi les r&eacute;f&eacute;rences appropri&eacute;es peuvent &ecirc;tre mises en place. D&egrave;s que les objets sont cr&eacute;&eacute;s vous pouvez appeler la m&eacute;thode "speak" de chaque objet.
%%(freebasic)
'Have the animals speak
Print "My dog says ";
myDog.speak()
Print "My cat says ";
myCat.speak()
%%
Notez que vous appelez la m&ecirc;me m&eacute;thode "speak", cependant les r&eacute;ponses sont diff&eacute;rentes:
%%(freebasic)
My dog says Woof!
My cat says Meow!
%%
C'est l'essence m&ecirc;me des m&eacute;thodes polymorphes. 

Voici le listing du programme complet:
%%(freebasic)
'Simulated Polymorphism Using Method Pointers
'Richard D. Clark
'Requires the CVS version of FreeBasic
'**********************************************

#define isdog 1
#define iscat 2


Type animal
	Public:
	speak As Sub()
	Declare Constructor (anid As Integer)    
End Type

'Speak method for dog object
Sub Bark()
	Print "Woof!"
End Sub

'Speak mehod for cat object
Sub Meow()
	Print "Meow!"
End Sub

'Set the proper method pointer based on animal id
Constructor animal(anid As Integer)
	If anid = isdog Then
	    this.speak = @Bark
	Elseif anid = iscat Then
	    this.speak = @Meow
	End If
End Constructor

'Create a dog and cat object
Dim myDog As animal = isdog
Dim mycat As animal = iscat

'Have the animals speak
Print "My dog says ";
myDog.speak()
Print "My cat says ";
myCat.speak()

Sleep
End
##
