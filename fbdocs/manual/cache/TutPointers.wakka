{{fbdoc item="title" value="Introduction to Pointers"}}----
//Ecrit par [[WikiRick rdc]]//

**Qu'est ce qu'un pointeur?**

Un pointeur est un type de donnée de 4 octets qui contient l"adresse d'un emplacement mémoire. Un pointeur ne contient pas de donnée, il pointe vers une donnée lorsqu'il a été initialisé. Un pointeur non-initialisé ne pointe vers rien du tout et est indéfini.

Pour comprendre les pointeurs, imaginez un carton à oeufs qui aurait les numéros de 1 à 12 inscrit au fond de chaque "trou" (où vous posez les oeufs). Ces "trous" sont comme les emplacements mémoire de l'ordinateur; chaque case, ou emplacement mémoire, a une adresse, dans cet exemple, de 1 à 12. Si un oeuf représente un élément de donnée, alors un oeuf dans le "trou" 1 a une adresse de 1.

Normalement, vous accédez aux données directement par l'intermédiaire de variables. Quand vous DIMensionnez une variable d'un type particulier, vous réservez un espace de stockage pour cette donnée. Vous n'avez pas besoin de connaître ou de vous soucier de savoir où la donnée réside en mémoire car vous pouvez accéder directement à celle-ci en utilisant le nom de la variable. C'est comme tendre la main et prendre un oeuf dans la case 1 (lecture de la donnée) ou placer un oeuf dans la case 1 (initialiser la donnée) sans lire le numéro inscrit au fond de la case.

Utiliser des pointeurs est légèrement différent. Imaginez que vous avez un petit bout de papier qui représente notre pointeur. Pour le moment il est vierge et ne pointe nulle part. Ce pointeur non-défini ne peut être utilisé tant qu'il n'est pas initialisé. Pour l'initialiser, écrivez 1 dessus. Maintenant notre pointeur "pointe" vers la case 1 de notre carton à oeufs. Pour placer une donnée (un oeuf) dans la case 1, nous consultons notre bout de papier, il indique la case 1 et nous plaçons l'oeuf dans cette case. Pour récupérer l'oeuf nous effectuons la manoeuvre oposée.  Nous faisons correspondre notre bout de papier au trou 1 et ensuite récupérons l'oeuf. La mise en place de l'oeuf et sa récupération se réalisent par l'intermédiaire de notre bout de papier et est appelé déréférencer le pointeur. C'est à dire que nous récupérons la donnée par l'intermédiaire de la référence contenue dans le pointeur, le numéro 1. Le pointeur ne contient pas la donnée; il contient une référence vers cette donnée.

Dans FreeBASIC nous définissons un pointeur en utilisant les instructions [[KeyPgDim Dim]] et [[KeyPgPtr Ptr]]:

##%%(freebasic)
dim aptr as integer ptr
%%##

Cette déclaration correspond à notre bout de papier blanc de l'exemple précédent. Le pointeur ne pointe vers rien et n'est pas défini. Si vous essayez de l'utiliser ainsi, il est plus que probable que le programme se plante!

Pour qu'un pointeur soit utilisable, il doit être initialisé:

##%%(freebasic)
dim aptr as integer ptr

aptr = allocate(sizeof(integer))
%%##

Nous avons utilisé [[KeyPgAllocate Allocate]] de façon à reserver assez d'espace mémoire pour un [[KeyPgInteger Integer]] et avons l'adresse de cet espace dans ##//aptr//##. La macro [[KeyPgSizeof sizeof]] renvoie la taille en octets du type de la donnée qui est passée. Si vous préférez, vous pouvez utilisez ##**Len**## au lieu de [[KeyPgSizeof Sizeof]] (depuis .13b).

Une fois le pointeur initialisé, nous pouvons maintenant l'utiliser:

##%%(freebasic)
*aptr = 5
print "aptr: "; *aptr
%%##

Notez le préfixe ***** devant ##//aptr//##. Le ***** est l'opérateur de référence. C'est comme faire correspondre le numéro sur le bout de papier au numéro de la case du carton à oeufs. En utilisant l'opérateur *****, nous pouvons accéder à la donnée (l'oeuf) contenu dans la case pointée par ##//aptr//##.

Voici un exemple complet de programme:

##%%(freebasic)
option explicit

dim aptr as integer ptr

aptr = allocate(sizeof(integer))
*aptr = 5
print "aptr: "; *aptr
deallocate aptr
sleep
%%##

La fonction [[KeyPgDeallocate deallocate]] libère la mémoire pointée par ##//aptr//## et ainsi ##//aptr//## est de nouveau non-défini. C'est comme effacer le numéro sur votre bout de papier. Si nous utilisions ##//aptr//## après désallocation, le programme se planerait.

**A quoi servent les pointeurs?**

Une des principales raisons pour ajouter des pointeurs à FreeBASIC est que beaucoup de bibliothèques externes nécessitent des pointeurs vers des structures et des pointeurs vers des chaînes. Par exemple, l'API Win32 a de nombreuses structures qui doivent être remplies et transmises à une fonction via un pointeur.

Une autre utilisation d'un pointeur se trouve dans la définition d'un [[KeyPgType Type]]. Dans FreeBASIC, les définitions de [[KeyPgType Type]] ne peuvent contenir que des chaînes de longueur définie, mais que faire si vous ne connaissez pas la longueur de la chaîne avant le fonctionnement du programme? Un pointeur peut être utile dans ce cas.

(Il convient de préciser que les définitions de [[KeyPgType Type]] peuvent désormais prendre en charge les chaînes de longueur variable.)

##%%(freebasic)
option explicit

type mytptr
	sptr as zstring ptr
end type
'This function will allocate space for the passed string
'and load it into a memory location, returning the
'pointer to the string.
declare function pSetString(byval s as string) as zstring ptr

'type var
dim mytype as mytptr

'Set a variable string into the type def
mytype.sptr = pSetString("Hello World From FreeBasic!")
print "aptr: "; *mytype.sptr
deallocate(mytype.sptr)
sleep
end

function pSetString(byval s as string) as zstring ptr
	dim sz as zstring ptr
   
	'allocate some space + 1 for the chr(0)
	sz = allocate(len(s) + 1)
	'load the string into the memory location
	*sz = s
	'return the pointer
	return sz
end function
%%##

Ici nous définisons notre [[KeyPgType Type]] avec un champ ##**sptr**## comme [[KeyPgZstring zstring]] [[KeyPgPtr ptr]]. Les [[KeyPgZstring ZString]]s sont des chaînes terminées par un indicateur nul qui sont utilisées par de nombreuses bibliothèques externes et sont conçues pour l'allocation dynamique. Dès que nous avons créé notre [[KeyPgType Type]] nous en créons une instance avec l'instruction [[KeyPgDim dim]]:

##%%(freebasic)
dim mytype as mytptr
%%##

Nous appelons ensuite notre fonction pSetString pour obtenir l'adresse de la chaîne de longueur variable que nous voulons dans notre définition de [[KeyPgType type]].

##%%(freebasic)
mytype.sptr = pSetString("Hello World From FreeBasic!")
%%##

Souvenez-vous que sptr est défini comme un pointeur, non une variable chaîne, donc pSetString retourne un pointeur (adresse mémoire) vers la chaîne, non la chaîne elle-même. En d'autres termes, si la chaîne est en #1, pSetString retourne 1.

La fonction pSetString une [[KeyPgZstring zstring]] temporaire "sz", pour [[KeyPgAllocate allocate]] de l'espace pour le paramètre chaîne "s" qui est passé. Comme une [[KeyPgZstring zstring]] est une chaîne terminée par "null", nous devons ajouter 1 à la longueur de "s" pour le "null terminator" (incateur de fin nul) dans la fonction [[KeyPgAllocate allocate]] .

##%%(freebasic)
'allocate some space + 1 for the chr(0)
sz = allocate(len(s) + 1)
%%##

Une fois que nous avons alloué un espace pour la chaîne, nous utilisons l'opérateur de référence * pour charger les données dans l'emplacement mémoire.

##%%(freebasic)
'load the string into the memory location
*sz = s
%%##

Ensuite, nous retournons  un pointeur (l'adresse de la chaîne) vers notre type, qui est enregistré dans mytype.sptr.

##%%(freebasic)
'return the pointer
return sz
%%##

Nous pouvons maintenant déréférencer la chaîne dans notre type en utilisant l'opérateur de référence.

##%%(freebasic)
print "aptr: "; *mytype.sptr
%%##

Les pointeurs peuvent être déroutants pour les non-initiés, mais ils ne doivent pas l'être si vous gardez à l'esprit que le pointeur ne contient pas de données, il pointe seulement vers certaines données. Le pointeur est une adresse mémoire et vous manipulez les données par l'opérateur de référence *. Ceci n'est vraiment pas très différent d'une variable normale.