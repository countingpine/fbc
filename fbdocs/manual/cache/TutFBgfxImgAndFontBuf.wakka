{{fbdoc item="title" value="FBgfx Image and Font Buffers"}}----
Créer et comprendre votre image FBgfx et les tampons de la police de caractères

Le tampon d'image FBgfx
	Créer des zones tampons
	Format tampon
	Récupérer des Pixels
Le fichier en-tête FBgfx Font
	Détails du fichier en-tête
	Création d'un tampon police de caractères
	Affectation des caractères de la police
Trucs et astuces
	Coloriage de vos polices personnalisées
	""ScrPtr vs ImgBuf""

{{fbdoc item="subsect" value="Télécharger les fichiers d'accompagnement du Tutoriel:  [[http://pritchard.hmcsoft.org/files/fb%20font%20tut.7z FreeBASIC Font Tutorial.7z]]"}}

===Le tampon d'image FBgfx===

FBgfx a un nouveau type de données depuis la version 0.17 et suivantes. Ce type est appelé IMAGE. Vous pouvez l'utiliser en incluant l'en-tête FBgfx dans votre programme (# include "fbgfx.bi") et ensuite accéder à l'espace de noms pour FBgfx, via FB.IMAGE. Quand nous créerons des zones tampons dans ce tutoriel, nous utiliserons le type "fb.Image Ptr". Un pointeur, car c'est de la mémoire dynamique que l'on peut redimensionner.

Pour utiliser une image dans la bibliothèque FBgfx, vous devez le créer via un tampon image. Votre tampon est une zone de mémoire allouée (créée, mis à disposition) pour votre image. Vous avez à désallouer (libérer, rendre disponible à d'autres programmes), la mémoire tampon lorsque vous avez terminé de l'utiliser à la fin de votre programme. FBgfx a son propre format de pixel interne, ainsi qu'une tête au début de chaque tampon image créé. L'en-tête de l'image contient des informations sur votre image. Comme sa largeur, hauteur, profondeur de bits, etc, tandis que le tampon pixel contient les couleurs réelles, pour chaque pixel individuel en format RVB (rouge, bleu, vert).

==Créer des zones tampons==

La taille du buffer que vous créezt varie en fonction de la profondeur d'écran. Le "bytes-per-pixel ou bpp = octets par pixel" est le nombre d'octets nécessaires pour stocker les pixels individuels. Ainsi, un écran 32-bit de profondeur de pixel aura besoin de 4 octets par pixel (8 bits dans un octet). Vous n'avez pas besoin de vous inquiéter à ce sujet, cependant, l'utilisation de ##fb.Image [[KeyPgPtr ptr]]## pour créer votre configuration mémoire tampon rend cela très facile pour obtenir les informations nécessaires à la création de nos tampons. Vous avez seulement besoin de connaître cette information pour comprendre quelle quantité de mémoire la taille d'un tampon peut occuper au total, concernant les informations d'utilisation de la mémoire.

En fait, la création du  tampon mémoire est très simple. C'est juste une simple création d'un ##fb.Image [[KeyPgPtr ptr]]## et un appel à ##[[KeyPgImagecreate Imagecreate]]## (Exemple1.bas):

%%(freebasic)
#include "fbgfx.bi"

  '' Our image width/height
Const ImgW = 64
Const ImgH = 64

  '' Screens have to be created before a call to imagecreate
Screenres 640, 480, 32

  '' Create our buffer
Dim as FB.Image ptr myBuf = ImageCreate(ImgW, ImgH)

  '' Print the address of our buffer.
Print "Buffer created at: " & myBuf
sleep

  '' Destroy our buffer.  Always DESTROY buffers you CREATE
ImageDestroy( myBuf )
Print "Our buffer was destroyed."
sleep
%%

==Dissection du Code==

%%(freebasic)
#include "fbgfx.bi"
%%

Cela inclut le fichier d'en-tête qui contient la définition du type ##fb.Image##.

%%(freebasic)
  '' Our image width/height
Const ImgW = 64
Const ImgH = 64
%%

Ceci crée des constantes qui seront utilisées pour décider de la taille de notre image. FBgfx ne connaît rien à ce sujet. Nous devrons les passer à ##[[KeyPgImagecreate Imagecreate]]## lorsque nous l'utiliserons.

%%(freebasic)
  '' Screens have to be created before a call to imagecreate
Screenres 640, 480, 32
%%

Ceci crée notre écran FBgfx. ##[[KeyPgImagecreate Imagecreate]]## a besoin de connaître la profondeur de bit à l'avance. Toutefois, ##[[KeyPgImagecreate Imagecreate]]## FBgfx a maintenant un paramètre supplémentaire vous permettant de régler la profondeur soi-même.

%%(freebasic)
  '' Create our buffer
Dim as FB.Image ptr myBuf = ImageCreate(ImgW, ImgH)
%%

Avant tout il faut créer un pointeur qui du type ##fb.Image##. C'est juste un emplacement mémoire. Nous n'avons encore rien rempli. En fait, actuellement, il est égal à zéro et ne peut pas être utilisé. Il est considéré comme nul.

L'appel d'##[[KeyPgImagecreate Imagecreate]]## renvoie l'adresse d'une zone de la mémoire d'un ##fb.Image## nouvellement créé qui sert à l'initialisation de notre pointeur. La taille de ce tampon dépend de la profondeur de bits, mais la largeur et la hauteur de l'image contenue dans le tampon seront celles que nous avons définies précédemment. ##[[KeyPgImagecreate Imagecreate]]## peut aussi prendre une couleur de remplissage et de profondeur dans les troisième et quatrième arguments, respectivement; si ce n'est pas spécifié, l'image sera créée remplie avec la couleur transparente et sa profondeur sera celle de la couleur courante de l'écran.

Nous avons maintenant un espace alloué en mémoire. C'est un espace suffisant pour contenir une image """ImgWxImgH""", avec les données que "FBgfx" détient au sein de son type ##fb.Image##. Nous allons avoir besoin de le détruire plus tard, pour une gestion appropriée de la mémoire.

%%(freebasic)
  '' Print the address of our buffer.
Print "Buffer created at: " & myBuf
sleep
%%

Ceci, juste pour vous faire savoir ce que nous avons fait. Nous affichons l'adresse de ##myBuf##. Si ce n'est pas ##0##, nous pouvons supposer que ##[[KeyPgImagecreate Imagecreate]]## a fonctionné.

%%(freebasic)
  '' Destroy our buffer.  Always DESTROY buffers you CREATE
ImageDestroy( myBuf )
Print "Our buffer was destroyed."
sleep
%%

Ici, nous détruisons notre tampon avec un appel à ##[[KeyPgImageDestroy Imagedestroy]]##. Nous n'avons pas à utiliser ##[[KeyPgImageDestroy Imagedestroy]]## pour désallouer notre tampon, mais il est préférable de l'utiliser pour la cohérence et la clarté.

==Format du tampon==

Maintenant que nous savons comment créer des tampons, on peut vouloir avoir plus d'informations sur ce qui aura lieu à l'intérieur. Vous pouvez ouvrir le fichier d'en-tête ##fbgfx.bi## et trouver le type ##fb.Image## et voir tous ces trucs excellents à l'intérieur de celui-ci.

En fait, Nous  n'avons pas besoin d'en savoir beaucoup sur le format lui-même. La raison en est que nous avons utilisé une ##fb.Image [[KeyPgPtr ptr]]##. Dans la mémoire, tout ce qui suit ##Buf + [[KeyPgSizeof Sizeof]](fb.Image)##  correspond aux pixels. Tout ce qui est avant correspond à l'en-tête. L'en-tête est très facilement accessible parce que nous avons utilisé un ##fb.Image [[KeyPgPtr ptr]]##. Tout ce que vous devez savoir est ce que vous voulez chercher.

==FB.IMAGE Data Type==

%%(freebasic)
  '' Image buffer header, new style (incorporates old header)
type IMAGE field = 1
	union
	    old as _OLD_HEADER
	    type as uinteger
	end union
	bpp as integer
	width as uinteger
	height as uinteger
	pitch as uinteger
	_reserved(1 to 12) as ubyte
end type
%%

Cette même information peut être trouvée dans ##fbgfx.bi##. Comme vous pouvez le voir, ce type de données permet de stocker *beaucoup* d'information ordonnée concernant votre tampon. La largeur, la hauteur, pitch (octets par ligne) et la profondeur de bits (octets par pixel) sont toutes intégrées. Dans l'union est inclus le type d'en-tête et l'ancienne en-tête elle-même dans le même espace. Le format de nouvel en-tête est indiquée par une valeur type de 7. Le format d'ancienne en-tête n'est pas utilisé dans le dialecte par défaut dans les nouvelles versions de FB, alors nous n'allons pas le couvrir ici.

Comment pouvons-nous accéder à ces informations dans l'en-tête? Si vous connaissez bien les pointeurs (vous devriez l'être, nous avons utilisé un pointeur pour notre tampon dans le premier exemple), alors tout ce que vous avez à faire est d'accéder à votre tampon comme un pointeur, et accéder directement aux données à l'intérieur. Cela peut vous laisser croire que tout ce qui est contenu dans votre mémoire tampon est le type ##fb.Image## lui-même, mais ce n'est tout simplement pas vrai. L'utilisation d'une ##fb.Image [[KeyPgPtr ptr]]## permet au compilateur de penser que c'est ce qui est contenu dans la mémoire tampon, même si seule la première partie le fait.

==Récupérer des Pixels==

La première section de notre tampon que FreeBASIC nous fournit contient les informations d'en-tête. Ajoutez la taille de la ##fb.Image## à notre adresse et le reste de notre tampon contient les pixels (""Example2.bas"").

%%(freebasic)
  '' We have to include this to use our FB.IMAGE datatype, remember.
#include "fbgfx.bi"
%%

N'oubliez pas d'inclure notre type de données ##fb.Image##!

%%(freebasic)
  '' This one is very important.
  '' We cast to a ubyte ptr first off, to get the exact byte our pixels begin.
  '' We then cast to a uInteger ptr, simply to avoid "suspicious assignment"
  '' warnings.
Dim as uInteger ptr myPix = cast( uInteger ptr, ( cast( ubyte ptr, myBuf ) + sizeof(FB.Image) ) )
%%

Ouf. Très bien. Nous devons nous assurer que nous obtenons bien l'adresse exacte de nos pixels. Un nombre entier contient 4 octets. 3 d'entre eux sont utilisés pour nos RVB et l'extra est généralement utilisé pour le canal alpha lorsque vous en avez besoin (certaines personnes très débrouillardes et utiliseront l'octet alpha - ou canal alpha - pour stocker toutes sortes de données). Même si nous avons seulement UN OCTET de décalage, notre Rouge deviendra Vert et notre Beu deviendra Rouge! Nous devons donc appliquer un ##[[KeyPgUbyte ubyte]] [[KeyPgPtr ptr]]## en premier.

Vous avez sans doute également remarqué que nous avons simplement ajouté ##sizeof(fb.Image)##à notre adresse. C'est un autre avantage de l'utilisation de ##fb.Image##! Si vous ajoutez sa taille au début du buffer, nous avons juste sauté toutes les adresses mémoire liées à l'en-tête et nous sommes maintenant sur nos pixels.

Finalement, nous effectuons un ##[[KeyPgUinteger Uinteger]] [[KeyPgPtr Ptr]]## sur la tout, principalement pour la sécurité. Nous sommes en mode 32 bits de profondeur, nous avons donc 4 octets par pixel.  Cela correspond à un ##[[KeyPgUinteger Uinteger]]##.

Voici une petite ligne si vous ne comprenez toujours pas comment cela fonctionne. Voici notre tampon: | FB.IMAGE Header | Pixels |

Si ce qui est contenu dans la première section de notre tampon est l'en-tête de ##fb.Image##, c'est bien évidemment qu'il va être aussi grand en taille. Ainsi, nous pouvons obtenir notre adresse pour les pixels, simplement en ajoutant la taille de la  ##fb.Image## à l'adresse de notre type de donnée d'origine.

Un problème cependant! Si nous ajoutons cette taille du tampon à notre adresse, pour tenter d'en obtenir une nouvelle, nous nous retrouvons avec des résultats étranges.  C'est parce que notre type de données n'est pas d'un octet de longueur. Nous devons d'abord Cast ##[[KeyPgUbyte Ubyte]] [[KeyPgPtr Ptr]]## puis ajouter l'adresse. Un ##[[KeyPgUbyte Ubyte]]## a une longueur d'un octet, ainsi nous obtiendrons en mémoire l'octet exact nécessaire pour les manipulatios.

Enfin, nous sommes en 32-bits.  Nous avons seulement fait un Cast ##[[KeyPgUbyte Ubyte]] [[KeyPgPtr Ptr]]##.  Bien que nous puissions simplement attribuer au "uInteger ptr" l'adresse du ##[[KeyPgUbyte Ubyte]]##, c'est une meilleure pratique de Cast vers un ##[[KeyPgUinteger Uinteger]] [[KeyPgPtr Ptr]]## en premier.  Nous avons enfin l'adresse de nos pixels, dans le type de données convenable (un par pixel!). Nous pouvons manipuler les pixels directement maintenant, si nous le souhaitons.


%%(freebasic)
  '' Print information stored in our buffer.
Print "Image Width: " & myBuf->Width
Print "Image Height: " & myBuf->Height
Print "Image Bit Depth: " & myBuf->BPP
Print "Image Pitch: " & myBuf->Pitch
Print ""
%%

C'est ce dont je parlais plus tôt. FB traitera votre pointeur comme si c'était un ##fb.Image [[KeyPgPtr ptr]]##, vous pouvez donc accéder aux données de l'en-tête directement. Puisque nous avons maintenant la taille de l'image ainsi que son adresse pixels, nous pouvons les éditer et les manipuler comme s'ils étaient un pointeur sur notre tampon d'écran! Voir ScrPtr ImgBuf.bas vs pour un exemple à ce sujet.

===L'en-tête FBGfx Font===

==Détails de l'en-tête==

La première ligne du tampon d'image qui sera utilisée comme une police contient les informations d'en-tête de votre police, sur la base d'un octet par octet (rappelez-vous que la première rangée de pixels correspond aux premiers octets car il sont stockés dans ligne -> colonne).

Le tout premier octet nous dit quelle version de l'en-tête que nous utilisons. Actuellement, seul 0 est pris en charge, car une seule version en-tête est autorisée. Le deuxième octet nous indique le premier caractère pris en charge dans notre police et le troisième octet nous indique le dernier.

0; Octet; Version de l'en-tête
1; Octet; Premier caractère supporté
2; Octet; Dernier caractère supporté
3 à (3 + DernierCaractère - PremierCaractère); Octet; Largeur de chaque caractère dans notre police.

==Création d'une zone tampon de police==

Si vous aviez une police de caractères dont le premier est le caractère 37 et le dernier le caractère 200, vos octets devraient contenir:

0 pour la version en-tête. C'est la version actuelle uniquement pris en charge.
37 pour le premier caractère pris en charge.
200 pour le dernier caractère pris en charge.
94 octets contenant les largeurs de chaque caractère.

Puisque la première ligne est prise pour les données d'en-tête, le tampon de la police sera un tampon d'image dont la hauteur est la hauteur de la police, plus un. Donc, si vous avez une hauteur de police de 8, vous avez besoin d'une hauteur du tampon de 9. Vous mettrez la police dans la deuxième rangée de votre tampon, plutôt que la première comme vous le feriez habituellement.

Voici un exemple (Exemple3.bas) qui crée une zone tampon de police. Il ne crée qu'elle et affecte seulement les données d'en-tête, pas la police effective:

%%(freebasic)
  '' The first supported character
Const FirstChar = 32
  '' Last supported character
Const LastChar = 190
  '' Number of characters total.
Const NumChar = (LastChar - FirstChar) + 1
%%

Ces constantes nous aident. Elles rendent le code plus propre et plus rapide.


%%(freebasic)
  '' Create a font buffer large enough to hold 96 characters, with widths of 8.
  '' Remember to make our buffer one height larger than the font itself.
Dim as FB.Image ptr myFont = ImageCreate( ( NumChar * 8 ), 8 + 1 )
%%

Créer notre buffer de police. Rappelez-vous, nous avons besoin d'ajouter un espace horizontal pour chaque caractère dans la police (8 pixels de large). Nous avons aussi besoin d'ajouter une rangée supplémentaire pour notre information d'en-tête de police.


%%(freebasic)
  '' Our font header information.
  '' Cast to uByte ptr for safety and consistency, remember.
Dim as uByte ptr myHeader = cast(uByte ptr, myFont )
%%

Nous obtenons notre buffer de police, exact, dans le bon format et n'ayant pas d'avertissements concernant les adresses. L'en-tête est sur une base d'un octet pour un octet, donc nous ne pouvons pas travailler sur lui avec un type ##fb.Image##.


%%(freebasic)
  '' Assign font buffer header.
  '' Header version
myHeader[0] = 0
  '' First supported character
myHeader[1] = FirstChar
  '' Last supported character
myHeader[2] = LastChar
%%

Attribuons à l'en-tête les informations décrites ci-dessus, dans les trois premiers octets. La version d'en-tête, le premier caractère  et le dernier caractère pris en charge.


%%(freebasic)
  '' Assign the widths of each character in the font.
For DoVar as Integer = 0 to NumChar - 1
	'' Skip the header, if you recall
  myHeader[3 + DoVar] = 8  
Next
%%

Chaque caractère de notre police peut avoir sa propre largeur, nous devons donc les affecter. Le ##3 +## saute les information d'en-tête. ""##DoVar##"" commence à 0, donc la première fois qu'il utilise ce code, nous sommes à l'indice 3. Donnant à tous les caractères pris en charge une largeur de 8.


%%(freebasic)
  '' Remember to destroy our image buffer.
ImageDestroy( myFont )
%%

Juste pour vous rappeler

==Affectation des caractères de la police==

C'est assez simple. Nous allons utiliser la police par défaut de FreeBASIC pour la dessiner sur notre tampon. N'oubliez pas que les dessins commencent à la colonne 1, non pas la colonne 0, parce que la toute première colonne est réservée pour les données d'en-tête. Démarrer en dessinant d'abord le premier caractère supporté et donnez-lui la couleur que vous voulez. Attention, vous ne pouvez pas avoir de couleur personnalisée lors de l'élaboration de votre de police. Lorsque vous ajoutez un caractère à votre buffer, sa couleur est bloquée définitivement sur celle qui est utilisée pour le dessiner! Voir la section "Conseils et astuces" pour contourner ce problème.

Voici le code modifié (Exemple4.bas), où nous allons ajouter le dessin de la police via la police FreeBASIC par défaut dans notre tampon.

%%(freebasic)
  '' NEW!!!
  '' Our current font character.
Dim as uByte CurChar
%%

Juste pour avoir un indice rapide du caractère ASCII courant on dessine sur notre police.


%%(freebasic)
Draw String myFont, ( DoVar * 8, 1 ), chr(CurChar), rgb(rnd * 255, rnd * 255, rnd * 255)
%%

Sautez la première ligne du tampon image, car elle contient des informations sur la police. Utilisez la police police FBgfx pour dessiner notre police personnalisée. Remplissez-la avec une couleur aléatoire. Notez que nous avons dessiné dans le tampon, avec "##Draw String myFont##...".


%%(freebasic)
Print chr(CurChar);
%%

Pour plus de clarté seulement, de façon à voir le dessin des caractères que nous avons mis dans le tampon.


%%(freebasic)
  '' Use our font buffer to draw some text!
Draw String (0, 80), "Hello!", , myFont
Draw String (0, 88), "HOW ARE ya DOIN Today?!  YA DOIN FINE?!", , myFont
sleep
%%

Testez notre nouvelle police. Bien sûr, c'est la même que celle à laquelle nous sommes habitués. Vous pourriez avoir créé la vôtre à partir du tampon de votre propre police personnalisée.

===Trucs & astuces===

==Colorisation de vos polices personnalisées==

Bon, maintenant que vous avez réalisé qu'une fois que vous colorisez une police personnalisée, vous ne pouvez pas utiliser ##[[KeyPgDrawString Draw String]]## pour changer cette couleur. Eh bien, aucune crainte, nous pouvons contourner cela (""CustFontCol.bas""). Cependant, cela pourrait être un peu lent.

Nous pouvons créer un objet police, contenant une fonction qui retourne un tampon police. Que fait ce code? il redessine le tampon de la police chaque fois que nous changeons de couleur et renvoie le tampon de la police stockée dans l'objet. Cela *pourrait* théoriquement être accéléré si l'on connaissait la gamme des caractères à redessiner, alors nous pourrions redessiner que ceux-là du plus bas au plus élevé. Mais déterminer cela, pourrait aussi être très lent.

%%(freebasic)
#include "fbgfx.bi"

Type Font
	'' Our font buffer.
  Buf     as FB.Image Ptr
	'' Font header.
  Hdr     as uByte ptr
  
	'' Current font color.
  Col     as uInteger
  
	'' Make our font buffer.
  Declare Sub Make( byVal _Col_ as uInteger = rgb(255, 255, 255) )
	'' Change the font color and edit the font buffer.
	'' Return the new font.
  Declare Function myFont( byVal _Col_ as uInteger = rgb(255, 255, 255) ) as FB.Image ptr
  
	'' Create/Destroy our font.
	  '' Set a default color to it if you like.
  Declare Constructor( byVal _Col_ as uInteger = rgb(255, 255, 255) )
  Declare Destructor()
End Type

  '' Create our font's buffer.
Constructor Font( byVal _Col_ as uInteger = rgb(255, 255, 255) )
  This.Make( _Col_ )
End Constructor

  '' Destroy font buffer.
Destructor Font()
  ImageDestroy( Buf )
End Destructor

  '' Assign the FBgfx font into our font buffer.
Sub Font.Make( byVal _Col_ as uInteger = rgb(255, 255, 255) )
	'' No image buffer data.  Create it.
  If This.Buf = 0 then
  
	  '' No screen created yet.
	If Screenptr = 0 then Exit Sub
	
	  '' Support 256 characters, 8 in width.
	  '' Add the extra row for the font header.
	This.Buf = ImageCreate( 256 * 8, 9 )
	
	  '' Get the address of the font header,
	  '' which is the same as getting our pixel address
	  '' Except that we always will use a ubyte.
	This.Hdr = cast(uByte ptr, This.Buf) + Sizeof(FB.Image)
	
	  '' Assign header information.
	This.Hdr[0] = 0
	  '' First supported character
	This.Hdr[1] = 0
	  '' Last supported character
	This.Hdr[2] = 255
  Else
	If This.Col = _Col_ then Exit Sub
	
  End If
  
	'' Draw our font.
  For DoVar as Integer = 0 to 255
	  '' Set font width information.
	This.Hdr[3 + DoVar] = 8
	
	Draw String This.Buf, (DoVar * 8, 1), chr(DoVar), _Col_
  Next
  
	'' Remember our font color.
  This.Col = _Col_
End Sub

  '' Get the buffer for our font.
  '' Remake the font if the color's different.
Function Font.myFont( byVal _Col_ as uInteger = rgb(255, 255, 255) ) as FB.Image ptr
	'' If our colors match, just return the current buffer.
  If _Col_ = Col then
	Return Buf
  End If
  
	'' Make the font with a new color.
  This.Make( _Col_ )
	'' Return out buffer.
  Return This.Buf
End Function


  '' MAIN CODE HERE!
Screenres 640, 480, 32

  '' Create our font.
Dim as Font myFont = rgb(255, 255, 255)

  '' Draw a string using our custom font.
Draw String (0,0), "Hello.  I am the custom font.",, myFont.myFont()
  '' Gasp.  A new color!
Draw String (0,8), "Hello.  I am the custom font.",, myFont.myFont(rgb(255, 0, 0))
sleep

  '' Speed test.  Turns out it's quite slow.
Scope
  Randomize Timer
	'' Our timer.
  Dim as Double T = Timer
  
	'' Time how long it takes to make a new font this way.
  For DoVar as Integer = 0 to 499
	myFont.Make( rgb(rnd * 255, rnd * 255, rnd * 255) )
  Next
  
	'' And we're all done.  Print important data.
  Locate 3, 1
  Print "Time to Re-Draw font 499 times: " & ( Timer - T )
  Print "Time per Re-Draw: " & ( Timer - T ) / 500
  sleep
End Scope
%%

==""ScrPtr vs ImgBuf""==

Comparaison sur comment dessiner des pixels dans le tampon d'image, par rapport à comment dessiner sur le tampon de l'écran (""ScrPtr vs ImgBuf.bas""):

%%(freebasic)
#include "fbgfx.bi"


Screenres 640, 480, 32


  '' Create a buffer the size of our screen.
Dim as FB.IMAGE ptr myBuf = ImageCreate( 640, 480 )

  '' Get the address of our screen's buffer.
Dim as uInteger ptr myScrPix = ScreenPtr
  '' Get the address of our pixel's buffer.
Dim as uInteger ptr myBufPix = Cast( uInteger ptr, Cast( uByte ptr, myBuf ) + Sizeof(FB.IMAGE) )


  '' Lock our page.  Fill the entire page with white.
Screenlock

  '' Alternatively, if the screen resolution's unknown, use ScreenInfo to
  '' make this more secure
  
  '' Note: this code assumes no padding between rows.  To prevent this,
  '' you need to use ScreenInfo to get the screen's pitch, and calculate
  '' row offsets using that instead.
  For xVar as Integer = 0 to 639
	For yVar as Integer = 0 to 479
	  myScrPix[ ( yVar * 640 ) + xVar ] = rgb(255, 255, 255)
	Next
  Next

Screenunlock
sleep


  '' Draw onto our image buffer all red.
For xVar as Integer = 0 to myBuf->Width - 1
  For yVar as Integer = 0 to myBuf->Height - 1
	myBufPix[ ( yVar * (myBuf->Pitch \ sizeof(*myBufPix)) ) + xVar ] = rgb(255, 0, 0)
  Next
Next

  '' Put the red buffer on the screen.
Put (0,0), myBuf, pset
sleep


/'
  ScreenPtr:
	1) Get address of screen buffer
	   (remember that FBgfx uses a dummy buffer that it flips automatically)
	2) Lock page
	3) Draw onto screen address
	4) Unlock page to show buffer
  
  Image Buffer:
	1) Create an image buffer
	2) Get the address of image pixels
	3) Draw onto image pixels
	   (you can use neat stuff like the buffer information to help you here)
	4) Put down Image where you please
	   (another big plus!)
	   
  About Drawing:
	cast(ubyte ptr, mybuff) + Y * Pitch + X * Bpp
	
	Every Y contains PITCH number of bytes.  In order to reach your new Y, you 
	have to skip an entire row.
	
	It should be safe to do the pointer arithmetic in cases where the pointer's data
	type is not one byte long, so you may find it easier to use a pointer type to
	match your bit depth.
	In these cases you should divide the Pitch and BPP by the size of the pointer type.
	Conveniently, in this case the Pitch should always be divisible by the pixel's type 
	size. And, obviously, so will the BPP, which will just cancel to 1 :D
	
'/
%%