{{fbdoc item="title" value="FBgfx Image and Font Buffers"}}----
Cr&eacute;er et comprendre votre image FBgfx et les tampons de la police de caract&egrave;res

Le tampon d'image FBgfx
	Cr&eacute;er des zones tampons
	Format tampon
	R&eacute;cup&eacute;rer des Pixels
Le fichier en-t&ecirc;te FBgfx Font
	D&eacute;tails du fichier en-t&ecirc;te
	Cr&eacute;ation d'un tampon police de caract&egrave;res
	Affectation des caract&egrave;res de la police
Trucs et astuces
	Coloriage de vos polices personnalis&eacute;es
	ScrPtr vs ImgBuf

**T&eacute;l&eacute;charger les fichiers d'accompagnement du Tutoriel:  [[http://pritchard.hmcsoft.org/files/fb%20font%20tut.7z">FreeBASIC Font Tutorial.7z]]**

<div class="fb_header">Le tampon d'image FBgfx

FBgfx a un nouveau type de donn&eacute;es depuis la version 0.17 et suivantes. Ce type est appel&eacute; IMAGE. Vous pouvez l'utiliser en incluant l'en-t&ecirc;te FBgfx dans votre programme (# include "fbgfx.bi") et ensuite acc&eacute;der &agrave; l'espace de noms pour FBgfx, via FB.IMAGE. Quand nous cr&eacute;erons des zones tampons dans ce tutoriel, nous utiliserons le type "fb.Image Ptr". Un pointeur, car c'est de la m&eacute;moire dynamique que l'on peut redimensionner.

Pour utiliser une image dans la biblioth&egrave;que FBgfx, vous devez le cr&eacute;er via un tampon image. Votre tampon est une zone de m&eacute;moire allou&eacute;e (cr&eacute;&eacute;e, mis &agrave; disposition) pour votre image. Vous avez &agrave; d&eacute;sallouer (lib&eacute;rer, rendre disponible &agrave; d'autres programmes), la m&eacute;moire tampon lorsque vous avez termin&eacute; de l'utiliser &agrave; la fin de votre programme. FBgfx a son propre format de pixel interne, ainsi qu'une t&ecirc;te au d&eacute;but de chaque tampon image cr&eacute;&eacute;. L'en-t&ecirc;te de l'image contient des informations sur votre image. Comme sa largeur, hauteur, profondeur de bits, etc, tandis que le tampon pixel contient les couleurs r&eacute;elles, pour chaque pixel individuel en format RVB (rouge, bleu, vert).

**Cr&eacute;er des zones tampons**

La taille du buffer que vous cr&eacute;ezt varie en fonction de la profondeur d'&eacute;cran. Le "bytes-per-pixel ou bpp = octets par pixel" est le nombre d'octets n&eacute;cessaires pour stocker les pixels individuels. Ainsi, un &eacute;cran 32-bit de profondeur de pixel aura besoin de 4 octets par pixel (8 bits dans un octet). Vous n'avez pas besoin de vous inqui&eacute;ter &agrave; ce sujet, cependant, l'utilisation de ##fb.Image [[KeyPgPtr Ptr]]## pour cr&eacute;er votre configuration m&eacute;moire tampon rend cela tr&egrave;s facile pour obtenir les informations n&eacute;cessaires &agrave; la cr&eacute;ation de nos tampons. Vous avez seulement besoin de conna&icirc;tre cette information pour comprendre quelle quantit&eacute; de m&eacute;moire la taille d'un tampon peut occuper au total, concernant les informations d'utilisation de la m&eacute;moire.

En fait, la cr&eacute;ation du  tampon m&eacute;moire est tr&egrave;s simple. C'est juste une simple cr&eacute;ation d'un ##fb.Image [[KeyPgPtr Ptr]]## et un appel &agrave; ##[[KeyPgImagecreate ImageCreate]]## (Exemple1.bas):

%%(freebasic)
#include "fbgfx.bi"

  '' Our image width/height
Const ImgW = 64
Const ImgH = 64

  '' Screens have to be created before a call to imagecreate
Screenres 640, 480, 32

  '' Create our buffer
Dim as FB.Image ptr myBuf = ImageCreate(ImgW, ImgH)

  '' Print the address of our buffer.
Print "Buffer created at: " & myBuf
sleep

  '' Destroy our buffer.  Always DESTROY buffers you CREATE
ImageDestroy( myBuf )
Print "Our buffer was destroyed."
sleep
%%

**Dissection du Code**

%%(freebasic)
#include "fbgfx.bi"
%%

Cela inclut le fichier d'en-t&ecirc;te qui contient la d&eacute;finition du type ##fb.Image##.

%%(freebasic)
  '' Our image width/height
Const ImgW = 64
Const ImgH = 64
%%

Ceci cr&eacute;e des constantes qui seront utilis&eacute;es pour d&eacute;cider de la taille de notre image. FBgfx ne conna&icirc;t rien &agrave; ce sujet. Nous devrons les passer &agrave; ##[[KeyPgImagecreate ImageCreate]]## lorsque nous l'utiliserons.

%%(freebasic)
  '' Screens have to be created before a call to imagecreate
Screenres 640, 480, 32
%%

Ceci cr&eacute;e notre &eacute;cran FBgfx. ##[[KeyPgImagecreate ImageCreate]]## a besoin de conna&icirc;tre la profondeur de bit &agrave; l'avance. Toutefois, ##[[KeyPgImagecreate ImageCreate]]## FBgfx a maintenant un param&egrave;tre suppl&eacute;mentaire vous permettant de r&eacute;gler la profondeur soi-m&ecirc;me.

%%(freebasic)
  '' Create our buffer
Dim as FB.Image ptr myBuf = ImageCreate(ImgW, ImgH)
%%

Avant tout il faut cr&eacute;er un pointeur qui du type ##fb.Image##. C'est juste un emplacement m&eacute;moire. Nous n'avons encore rien rempli. En fait, actuellement, il est &eacute;gal &agrave; z&eacute;ro et ne peut pas &ecirc;tre utilis&eacute;. Il est consid&eacute;r&eacute; comme nul.

L'appel d'##[[KeyPgImagecreate ImageCreate]]## renvoie l'adresse d'une zone de la m&eacute;moire d'un ##fb.Image## nouvellement cr&eacute;&eacute; qui sert &agrave; l'initialisation de notre pointeur. La taille de ce tampon d&eacute;pend de la profondeur de bits, mais la largeur et la hauteur de l'image contenue dans le tampon seront celles que nous avons d&eacute;finies pr&eacute;c&eacute;demment. ##[[KeyPgImagecreate ImageCreate]]## peut aussi prendre une couleur de remplissage et de profondeur dans les troisi&egrave;me et quatri&egrave;me arguments, respectivement; si ce n'est pas sp&eacute;cifi&eacute;, l'image sera cr&eacute;&eacute;e remplie avec la couleur transparente et sa profondeur sera celle de la couleur courante de l'&eacute;cran.

Nous avons maintenant un espace allou&eacute; en m&eacute;moire. C'est un espace suffisant pour contenir une image "ImgWxImgH", avec les donn&eacute;es que "FBgfx" d&eacute;tient au sein de son type ##fb.Image##. Nous allons avoir besoin de le d&eacute;truire plus tard, pour une gestion appropri&eacute;e de la m&eacute;moire.

%%(freebasic)
  '' Print the address of our buffer.
Print "Buffer created at: " & myBuf
sleep
%%

Ceci, juste pour vous faire savoir ce que nous avons fait. Nous affichons l'adresse de ##myBuf##. Si ce n'est pas ##0##, nous pouvons supposer que ##[[KeyPgImagecreate ImageCreate]]## a fonctionn&eacute;.

%%(freebasic)
  '' Destroy our buffer.  Always DESTROY buffers you CREATE
ImageDestroy( myBuf )
Print "Our buffer was destroyed."
sleep
%%

Ici, nous d&eacute;truisons notre tampon avec un appel &agrave; ##[[KeyPgImageDestroy ImageDestroy]]##. Nous n'avons pas &agrave; utiliser ##[[KeyPgImageDestroy ImageDestroy]]## pour d&eacute;sallouer notre tampon, mais il est pr&eacute;f&eacute;rable de l'utiliser pour la coh&eacute;rence et la clart&eacute;.

**Format du tampon**

Maintenant que nous savons comment cr&eacute;er des tampons, on peut vouloir avoir plus d'informations sur ce qui aura lieu &agrave; l'int&eacute;rieur. Vous pouvez ouvrir le fichier d'en-t&ecirc;te ##fbgfx.bi## et trouver le type ##fb.Image## et voir tous ces trucs excellents &agrave; l'int&eacute;rieur de celui-ci.

En fait, Nous  n'avons pas besoin d'en savoir beaucoup sur le format lui-m&ecirc;me. La raison en est que nous avons utilis&eacute; une ##fb.Image [[KeyPgPtr Ptr]]##. Dans la m&eacute;moire, tout ce qui suit ##Buf + [[KeyPgSizeof SizeOf]](fb.Image)##  correspond aux pixels. Tout ce qui est avant correspond &agrave; l'en-t&ecirc;te. L'en-t&ecirc;te est tr&egrave;s facilement accessible parce que nous avons utilis&eacute; un ##fb.Image [[KeyPgPtr Ptr]]##. Tout ce que vous devez savoir est ce que vous voulez chercher.

**FB.IMAGE Data Type**

%%(freebasic)
  '' Image buffer header, new style (incorporates old header)
type IMAGE field = 1
	union
	    old as _OLD_HEADER
	    type as uinteger
	end union
	bpp as integer
	width as uinteger
	height as uinteger
	pitch as uinteger
	_reserved(1 to 12) as ubyte
end type
%%

Cette m&ecirc;me information peut &ecirc;tre trouv&eacute;e dans ##fbgfx.bi##. Comme vous pouvez le voir, ce type de donn&eacute;es permet de stocker *beaucoup* d'information ordonn&eacute;e concernant votre tampon. La largeur, la hauteur, pitch (octets par ligne) et la profondeur de bits (octets par pixel) sont toutes int&eacute;gr&eacute;es. Dans l'union est inclus le type d'en-t&ecirc;te et l'ancienne en-t&ecirc;te elle-m&ecirc;me dans le m&ecirc;me espace. Le format de nouvel en-t&ecirc;te est indiqu&eacute;e par une valeur type de 7. Le format d'ancienne en-t&ecirc;te n'est pas utilis&eacute; dans le dialecte par d&eacute;faut dans les nouvelles versions de FB, alors nous n'allons pas le couvrir ici.

Comment pouvons-nous acc&eacute;der &agrave; ces informations dans l'en-t&ecirc;te? Si vous connaissez bien les pointeurs (vous devriez l'&ecirc;tre, nous avons utilis&eacute; un pointeur pour notre tampon dans le premier exemple), alors tout ce que vous avez &agrave; faire est d'acc&eacute;der &agrave; votre tampon comme un pointeur, et acc&eacute;der directement aux donn&eacute;es &agrave; l'int&eacute;rieur. Cela peut vous laisser croire que tout ce qui est contenu dans votre m&eacute;moire tampon est le type ##fb.Image## lui-m&ecirc;me, mais ce n'est tout simplement pas vrai. L'utilisation d'une ##fb.Image [[KeyPgPtr Ptr]]## permet au compilateur de penser que c'est ce qui est contenu dans la m&eacute;moire tampon, m&ecirc;me si seule la premi&egrave;re partie le fait.

**R&eacute;cup&eacute;rer des Pixels**

La premi&egrave;re section de notre tampon que FreeBASIC nous fournit contient les informations d'en-t&ecirc;te. Ajoutez la taille de la ##fb.Image## &agrave; notre adresse et le reste de notre tampon contient les pixels (Example2.bas).

%%(freebasic)
  '' We have to include this to use our FB.IMAGE datatype, remember.
#include "fbgfx.bi"
%%

N'oubliez pas d'inclure notre type de donn&eacute;es ##fb.Image##!

%%(freebasic)
  '' This one is very important.
  '' We cast to a ubyte ptr first off, to get the exact byte our pixels begin.
  '' We then cast to a uInteger ptr, simply to avoid "suspicious assignment"
  '' warnings.
Dim as uInteger ptr myPix = cast( uInteger ptr, ( cast( ubyte ptr, myBuf ) + sizeof(FB.Image) ) )
%%

Ouf. Tr&egrave;s bien. Nous devons nous assurer que nous obtenons bien l'adresse exacte de nos pixels. Un nombre entier contient 4 octets. 3 d'entre eux sont utilis&eacute;s pour nos RVB et l'extra est g&eacute;n&eacute;ralement utilis&eacute; pour le canal alpha lorsque vous en avez besoin (certaines personnes tr&egrave;s d&eacute;brouillardes et utiliseront l'octet alpha - ou canal alpha - pour stocker toutes sortes de donn&eacute;es). M&ecirc;me si nous avons seulement UN OCTET de d&eacute;calage, notre Rouge deviendra Vert et notre Beu deviendra Rouge! Nous devons donc appliquer un ##[[KeyPgUbyte UByte]] [[KeyPgPtr Ptr]]## en premier.

Vous avez sans doute &eacute;galement remarqu&eacute; que nous avons simplement ajout&eacute; ##sizeof(fb.Image)##&agrave; notre adresse. C'est un autre avantage de l'utilisation de ##fb.Image##! Si vous ajoutez sa taille au d&eacute;but du buffer, nous avons juste saut&eacute; toutes les adresses m&eacute;moire li&eacute;es &agrave; l'en-t&ecirc;te et nous sommes maintenant sur nos pixels.

Finalement, nous effectuons un ##[[KeyPgUinteger UInteger]] [[KeyPgPtr Ptr]]## sur la tout, principalement pour la s&eacute;curit&eacute;. Nous sommes en mode 32 bits de profondeur, nous avons donc 4 octets par pixel.  Cela correspond &agrave; un ##[[KeyPgUinteger UInteger]]##.

Voici une petite ligne si vous ne comprenez toujours pas comment cela fonctionne. Voici notre tampon: | FB.IMAGE Header | Pixels |

Si ce qui est contenu dans la premi&egrave;re section de notre tampon est l'en-t&ecirc;te de ##fb.Image##, c'est bien &eacute;videmment qu'il va &ecirc;tre aussi grand en taille. Ainsi, nous pouvons obtenir notre adresse pour les pixels, simplement en ajoutant la taille de la  ##fb.Image## &agrave; l'adresse de notre type de donn&eacute;e d'origine.

Un probl&egrave;me cependant! Si nous ajoutons cette taille du tampon &agrave; notre adresse, pour tenter d'en obtenir une nouvelle, nous nous retrouvons avec des r&eacute;sultats &eacute;tranges.  C'est parce que notre type de donn&eacute;es n'est pas d'un octet de longueur. Nous devons d'abord Cast ##[[KeyPgUbyte UByte]] [[KeyPgPtr Ptr]]## puis ajouter l'adresse. Un ##[[KeyPgUbyte UByte]]## a une longueur d'un octet, ainsi nous obtiendrons en m&eacute;moire l'octet exact n&eacute;cessaire pour les manipulatios.

Enfin, nous sommes en 32-bits.  Nous avons seulement fait un Cast ##[[KeyPgUbyte UByte]] [[KeyPgPtr Ptr]]##.  Bien que nous puissions simplement attribuer au "uInteger ptr" l'adresse du ##[[KeyPgUbyte UByte]]##, c'est une meilleure pratique de Cast vers un ##[[KeyPgUinteger UInteger]] [[KeyPgPtr Ptr]]## en premier.  Nous avons enfin l'adresse de nos pixels, dans le type de donn&eacute;es convenable (un par pixel!). Nous pouvons manipuler les pixels directement maintenant, si nous le souhaitons.


%%(freebasic)
  '' Print information stored in our buffer.
Print "Image Width: " & myBuf->Width
Print "Image Height: " & myBuf->Height
Print "Image Bit Depth: " & myBuf->BPP
Print "Image Pitch: " & myBuf->Pitch
Print ""
%%

C'est ce dont je parlais plus t&ocirc;t. FB traitera votre pointeur comme si c'&eacute;tait un ##fb.Image [[KeyPgPtr Ptr]]##, vous pouvez donc acc&eacute;der aux donn&eacute;es de l'en-t&ecirc;te directement. Puisque nous avons maintenant la taille de l'image ainsi que son adresse pixels, nous pouvons les &eacute;diter et les manipuler comme s'ils &eacute;taient un pointeur sur notre tampon d'&eacute;cran! Voir ScrPtr ImgBuf.bas vs pour un exemple &agrave; ce sujet.

<div class="fb_header">L'en-t&ecirc;te FBGfx Font

**D&eacute;tails de l'en-t&ecirc;te**

La premi&egrave;re ligne du tampon d'image qui sera utilis&eacute;e comme une police contient les informations d'en-t&ecirc;te de votre police, sur la base d'un octet par octet (rappelez-vous que la premi&egrave;re rang&eacute;e de pixels correspond aux premiers octets car il sont stock&eacute;s dans ligne -> colonne).

Le tout premier octet nous dit quelle version de l'en-t&ecirc;te que nous utilisons. Actuellement, seul 0 est pris en charge, car une seule version en-t&ecirc;te est autoris&eacute;e. Le deuxi&egrave;me octet nous indique le premier caract&egrave;re pris en charge dans notre police et le troisi&egrave;me octet nous indique le dernier.

0; Octet; Version de l'en-t&ecirc;te
1; Octet; Premier caract&egrave;re support&eacute;
2; Octet; Dernier caract&egrave;re support&eacute;
3 &agrave; (3 + DernierCaract&egrave;re - PremierCaract&egrave;re); Octet; Largeur de chaque caract&egrave;re dans notre police.

**Cr&eacute;ation d'une zone tampon de police**

Si vous aviez une police de caract&egrave;res dont le premier est le caract&egrave;re 37 et le dernier le caract&egrave;re 200, vos octets devraient contenir:

0 pour la version en-t&ecirc;te. C'est la version actuelle uniquement pris en charge.
37 pour le premier caract&egrave;re pris en charge.
200 pour le dernier caract&egrave;re pris en charge.
94 octets contenant les largeurs de chaque caract&egrave;re.

Puisque la premi&egrave;re ligne est prise pour les donn&eacute;es d'en-t&ecirc;te, le tampon de la police sera un tampon d'image dont la hauteur est la hauteur de la police, plus un. Donc, si vous avez une hauteur de police de 8, vous avez besoin d'une hauteur du tampon de 9. Vous mettrez la police dans la deuxi&egrave;me rang&eacute;e de votre tampon, plut&ocirc;t que la premi&egrave;re comme vous le feriez habituellement.

Voici un exemple (Exemple3.bas) qui cr&eacute;e une zone tampon de police. Il ne cr&eacute;e qu'elle et affecte seulement les donn&eacute;es d'en-t&ecirc;te, pas la police effective:

%%(freebasic)
  '' The first supported character
Const FirstChar = 32
  '' Last supported character
Const LastChar = 190
  '' Number of characters total.
Const NumChar = (LastChar - FirstChar) + 1
%%

Ces constantes nous aident. Elles rendent le code plus propre et plus rapide.


%%(freebasic)
  '' Create a font buffer large enough to hold 96 characters, with widths of 8.
  '' Remember to make our buffer one height larger than the font itself.
Dim as FB.Image ptr myFont = ImageCreate( ( NumChar * 8 ), 8 + 1 )
%%

Cr&eacute;er notre buffer de police. Rappelez-vous, nous avons besoin d'ajouter un espace horizontal pour chaque caract&egrave;re dans la police (8 pixels de large). Nous avons aussi besoin d'ajouter une rang&eacute;e suppl&eacute;mentaire pour notre information d'en-t&ecirc;te de police.


%%(freebasic)
  '' Our font header information.
  '' Cast to uByte ptr for safety and consistency, remember.
Dim as uByte ptr myHeader = cast(uByte ptr, myFont )
%%

Nous obtenons notre buffer de police, exact, dans le bon format et n'ayant pas d'avertissements concernant les adresses. L'en-t&ecirc;te est sur une base d'un octet pour un octet, donc nous ne pouvons pas travailler sur lui avec un type ##fb.Image##.


%%(freebasic)
  '' Assign font buffer header.
  '' Header version
myHeader[0] = 0
  '' First supported character
myHeader[1] = FirstChar
  '' Last supported character
myHeader[2] = LastChar
%%

Attribuons &agrave; l'en-t&ecirc;te les informations d&eacute;crites ci-dessus, dans les trois premiers octets. La version d'en-t&ecirc;te, le premier caract&egrave;re  et le dernier caract&egrave;re pris en charge.


%%(freebasic)
  '' Assign the widths of each character in the font.
For DoVar as Integer = 0 to NumChar - 1
	'' Skip the header, if you recall
  myHeader[3 + DoVar] = 8  
Next
%%

Chaque caract&egrave;re de notre police peut avoir sa propre largeur, nous devons donc les affecter. Le ##3 +## saute les information d'en-t&ecirc;te. ##DoVar## commence &agrave; 0, donc la premi&egrave;re fois qu'il utilise ce code, nous sommes &agrave; l'indice 3. Donnant &agrave; tous les caract&egrave;res pris en charge une largeur de 8.


%%(freebasic)
  '' Remember to destroy our image buffer.
ImageDestroy( myFont )
%%

Juste pour vous rappeler

**Affectation des caract&egrave;res de la police**

C'est assez simple. Nous allons utiliser la police par d&eacute;faut de <span >FreeBASIC pour la dessiner sur notre tampon. N'oubliez pas que les dessins commencent &agrave; la colonne 1, non pas la colonne 0, parce que la toute premi&egrave;re colonne est r&eacute;serv&eacute;e pour les donn&eacute;es d'en-t&ecirc;te. D&eacute;marrer en dessinant d'abord le premier caract&egrave;re support&eacute; et donnez-lui la couleur que vous voulez. Attention, vous ne pouvez pas avoir de couleur personnalis&eacute;e lors de l'&eacute;laboration de votre de police. Lorsque vous ajoutez un caract&egrave;re &agrave; votre buffer, sa couleur est bloqu&eacute;e d&eacute;finitivement sur celle qui est utilis&eacute;e pour le dessiner! Voir la section "Conseils et astuces" pour contourner ce probl&egrave;me.

Voici le code modifi&eacute; (Exemple4.bas), o&ugrave; nous allons ajouter le dessin de la police via la police FreeBASIC par d&eacute;faut dans notre tampon.

%%(freebasic)
  '' NEW!!!
  '' Our current font character.
Dim as uByte CurChar
%%

Juste pour avoir un indice rapide du caract&egrave;re ASCII courant on dessine sur notre police.


%%(freebasic)
Draw String myFont, ( DoVar * 8, 1 ), chr(CurChar), rgb(rnd * 255, rnd * 255, rnd * 255)
%%

Sautez la premi&egrave;re ligne du tampon image, car elle contient des informations sur la police. Utilisez la police police FBgfx pour dessiner notre police personnalis&eacute;e. Remplissez-la avec une couleur al&eacute;atoire. Notez que nous avons dessin&eacute; dans le tampon, avec "##Draw String myFont##...".


%%(freebasic)
Print chr(CurChar);
%%

Pour plus de clart&eacute; seulement, de fa&ccedil;on &agrave; voir le dessin des caract&egrave;res que nous avons mis dans le tampon.


%%(freebasic)
  '' Use our font buffer to draw some text!
Draw String (0, 80), "Hello!", , myFont
Draw String (0, 88), "HOW ARE ya DOIN Today?!  YA DOIN FINE?!", , myFont
sleep
%%

Testez notre nouvelle police. Bien s&ucirc;r, c'est la m&ecirc;me que celle &agrave; laquelle nous sommes habitu&eacute;s. Vous pourriez avoir cr&eacute;&eacute; la v&ocirc;tre &agrave; partir du tampon de votre propre police personnalis&eacute;e.

<div class="fb_header">Trucs & astuces

**Colorisation de vos polices personnalis&eacute;es**

Bon, maintenant que vous avez r&eacute;alis&eacute; qu'une fois que vous colorisez une police personnalis&eacute;e, vous ne pouvez pas utiliser ##[[KeyPgDrawString Draw String]]## pour changer cette couleur. Eh bien, aucune crainte, nous pouvons contourner cela (CustFontCol.bas). Cependant, cela pourrait &ecirc;tre un peu lent.

Nous pouvons cr&eacute;er un objet police, contenant une fonction qui retourne un tampon police. Que fait ce code? il redessine le tampon de la police chaque fois que nous changeons de couleur et renvoie le tampon de la police stock&eacute;e dans l'objet. Cela *pourrait* th&eacute;oriquement &ecirc;tre acc&eacute;l&eacute;r&eacute; si l'on connaissait la gamme des caract&egrave;res &agrave; redessiner, alors nous pourrions redessiner que ceux-l&agrave; du plus bas au plus &eacute;lev&eacute;. Mais d&eacute;terminer cela, pourrait aussi &ecirc;tre tr&egrave;s lent.

%%(freebasic)
#include "fbgfx.bi"

Type Font
	'' Our font buffer.
  Buf     as FB.Image Ptr
	'' Font header.
  Hdr     as uByte ptr
  
	'' Current font color.
  Col     as uInteger
  
	'' Make our font buffer.
  Declare Sub Make( byVal _Col_ as uInteger = rgb(255, 255, 255) )
	'' Change the font color and edit the font buffer.
	'' Return the new font.
  Declare Function myFont( byVal _Col_ as uInteger = rgb(255, 255, 255) ) as FB.Image ptr
  
	'' Create/Destroy our font.
	  '' Set a default color to it if you like.
  Declare Constructor( byVal _Col_ as uInteger = rgb(255, 255, 255) )
  Declare Destructor()
End Type

  '' Create our font's buffer.
Constructor Font( byVal _Col_ as uInteger = rgb(255, 255, 255) )
  This.Make( _Col_ )
End Constructor

  '' Destroy font buffer.
Destructor Font()
  ImageDestroy( Buf )
End Destructor

  '' Assign the FBgfx font into our font buffer.
Sub Font.Make( byVal _Col_ as uInteger = rgb(255, 255, 255) )
	'' No image buffer data.  Create it.
  If This.Buf = 0 then
  
	  '' No screen created yet.
	If Screenptr = 0 then Exit Sub
	
	  '' Support 256 characters, 8 in width.
	  '' Add the extra row for the font header.
	This.Buf = ImageCreate( 256 * 8, 9 )
	
	  '' Get the address of the font header,
	  '' which is the same as getting our pixel address
	  '' Except that we always will use a ubyte.
	This.Hdr = cast(uByte ptr, This.Buf) + Sizeof(FB.Image)
	
	  '' Assign header information.
	This.Hdr[0] = 0
	  '' First supported character
	This.Hdr[1] = 0
	  '' Last supported character
	This.Hdr[2] = 255
  Else
	If This.Col = _Col_ then Exit Sub
	
  End If
  
	'' Draw our font.
  For DoVar as Integer = 0 to 255
	  '' Set font width information.
	This.Hdr[3 + DoVar] = 8
	
	Draw String This.Buf, (DoVar * 8, 1), chr(DoVar), _Col_
  Next
  
	'' Remember our font color.
  This.Col = _Col_
End Sub

  '' Get the buffer for our font.
  '' Remake the font if the color's different.
Function Font.myFont( byVal _Col_ as uInteger = rgb(255, 255, 255) ) as FB.Image ptr
	'' If our colors match, just return the current buffer.
  If _Col_ = Col then
	Return Buf
  End If
  
	'' Make the font with a new color.
  This.Make( _Col_ )
	'' Return out buffer.
  Return This.Buf
End Function


  '' MAIN CODE HERE!
Screenres 640, 480, 32

  '' Create our font.
Dim as Font myFont = rgb(255, 255, 255)

  '' Draw a string using our custom font.
Draw String (0,0), "Hello.  I am the custom font.",, myFont.myFont()
  '' Gasp.  A new color!
Draw String (0,8), "Hello.  I am the custom font.",, myFont.myFont(rgb(255, 0, 0))
sleep

  '' Speed test.  Turns out it's quite slow.
Scope
  Randomize Timer
	'' Our timer.
  Dim as Double T = Timer
  
	'' Time how long it takes to make a new font this way.
  For DoVar as Integer = 0 to 499
	myFont.Make( rgb(rnd * 255, rnd * 255, rnd * 255) )
  Next
  
	'' And we're all done.  Print important data.
  Locate 3, 1
  Print "Time to Re-Draw font 499 times: " & ( Timer - T )
  Print "Time per Re-Draw: " & ( Timer - T ) / 500
  sleep
End Scope
%%

**ScrPtr vs ImgBuf**

Comparaison sur comment dessiner des pixels dans le tampon d'image, par rapport &agrave; comment dessiner sur le tampon de l'&eacute;cran (ScrPtr vs ImgBuf.bas):

%%(freebasic)
#include "fbgfx.bi"


Screenres 640, 480, 32


  '' Create a buffer the size of our screen.
Dim as FB.IMAGE ptr myBuf = ImageCreate( 640, 480 )

  '' Get the address of our screen's buffer.
Dim as uInteger ptr myScrPix = ScreenPtr
  '' Get the address of our pixel's buffer.
Dim as uInteger ptr myBufPix = Cast( uInteger ptr, Cast( uByte ptr, myBuf ) + Sizeof(FB.IMAGE) )


  '' Lock our page.  Fill the entire page with white.
Screenlock

  '' Alternatively, if the screen resolution's unknown, use ScreenInfo to
  '' make this more secure
  
  '' Note: this code assumes no padding between rows.  To prevent this,
  '' you need to use ScreenInfo to get the screen's pitch, and calculate
  '' row offsets using that instead.
  For xVar as Integer = 0 to 639
	For yVar as Integer = 0 to 479
	  myScrPix[ ( yVar * 640 ) + xVar ] = rgb(255, 255, 255)
	Next
  Next

Screenunlock
sleep


  '' Draw onto our image buffer all red.
For xVar as Integer = 0 to myBuf->Width - 1
  For yVar as Integer = 0 to myBuf->Height - 1
	myBufPix[ ( yVar * (myBuf->Pitch \ sizeof(*myBufPix)) ) + xVar ] = rgb(255, 0, 0)
  Next
Next

  '' Put the red buffer on the screen.
Put (0,0), myBuf, pset
sleep


/'
  ScreenPtr:
	1) Get address of screen buffer
	   (remember that FBgfx uses a dummy buffer that it flips automatically)
	2) Lock page
	3) Draw onto screen address
	4) Unlock page to show buffer
  
  Image Buffer:
	1) Create an image buffer
	2) Get the address of image pixels
	3) Draw onto image pixels
	   (you can use neat stuff like the buffer information to help you here)
	4) Put down Image where you please
	   (another big plus!)
	   
  About Drawing:
	cast(ubyte ptr, mybuff) + Y * Pitch + X * Bpp
	
	Every Y contains PITCH number of bytes.  In order to reach your new Y, you 
	have to skip an entire row.
	
	It should be safe to do the pointer arithmetic in cases where the pointer's data
	type is not one byte long, so you may find it easier to use a pointer type to
	match your bit depth.
	In these cases you should divide the Pitch and BPP by the size of the pointer type.
	Conveniently, in this case the Pitch should always be divisible by the pixel's type 
	size. And, obviously, so will the BPP, which will just cancel to 1 :D
	
'/
##