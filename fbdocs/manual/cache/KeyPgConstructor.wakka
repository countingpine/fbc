{{fbdoc item="title" value="CONSTRUCTOR"}}----
Appel&eacute; automatiquement lorsqu'une classe ou un type d&eacute;fini par l'utilisateur est cr&eacute;&eacute;

{{fbdoc item="syntax"}}##
	[[KeyPgType Type]] //typename//
		[[KeyPgDeclare declare]] **Constructor** ( )
		[[KeyPgDeclare declare]] **Constructor** ( [ [[KeyPgByref byref]] | [[KeyPgByval byval]] ] //parameter// [[KeyPgAs as]] [[DataType datatype]] [ = //default// ] [, ... ] )
	End Type

	**Constructor** //typename// ( [ //parameters// ] )
		//statements//
	**End Constructor**
##
{{fbdoc item="param"}}
	##//typename//## 
		nom du ##[[KeyPgType Type]]## ou ##[[KeyPgClass Class]]##

{{fbdoc item="desc"}}
	Les m&eacute;thodes ##**Constructor**## sont appel&eacute;es lorsqu'un ##[[KeyPgType Type]]## d&eacute;fini par l'utilisateur ou une variable de ##[[KeyPgClass Class]]## est cr&eacute;&eacute;.

	##//typename//## est le nom du type pour lequel la m&eacute;thode ##**Constructor**## est d&eacute;clar&eacute;e et d&eacute;finie.  La r&eacute;solution de noms pour ##//typename//## suit les m&ecirc;mes r&egrave;gles que les proc&eacute;dures en cas d'utilisation dans un ##[[KeyPgNamespace espace de noms]]##.

	Plus d'un constructeur peut exister pour un type ou une classe.  La m&eacute;thode constructeur exacte appel&eacute;e d&eacute;pend de la signature ##//parameter//## correspondant quand la variable est initialis&eacute;e.  Plus d'un ##//parameter//## peut exister dans la d&eacute;claration de la m&eacute;thode ##**Constructor**##.

	Une m&eacute;thode constructeur est pass&eacute;e &agrave; un param&egrave;tre ##[[KeyPgThis This]]## cach&eacute; qui est du m&ecirc;me type que ##//typename//##.  ##[[KeyPgThis This]]## est &eacute;ventuellement utilis&eacute; pour acc&eacute;der aux champs du ##[[KeyPgType Type]]## ou de la ##[[KeyPgClass Class]]## qui a &eacute;t&eacute; initialis&eacute; dans la m&eacute;thode ##**Constructor**##.

	Le cha&icirc;nage des constructeurs dans les types imbriqu&eacute;s est pris en charge.  Tous les champs qui ont leur propre constructeur par d&eacute;faut sont appel&eacute;s en premier.

	Les constructeurs sont appel&eacute;s lors de la d&eacute;claration d'instances statiques globales ou locales de ##//typename//## et lors de l'allocation dynamique de ##//typename//## en utilisant l'op&eacute;rateur ##[[KeyPgOpNew New]]##.

{{fbdoc item="ex"}}
Exemple de constructeur simple pour d&eacute;butants.
{{fbdoc item="filename" value="examples/manual/udt/constructor-ptr.bas"}}%%(freebasic)
Type MyObj
  Foo As Integer Ptr
  
	'' Constructor to create our integer, and set its value.
  Declare Constructor( ByVal DefVal As Integer = 0 )
	'' Destroy our integer on object deletion.
  Declare Destructor()
End Type

Constructor MyObj( ByVal DefVal As Integer = 0 )
  Print "Creating a new integer in MyObj!"
  Print "The Integer will have the value of: " & DefVal
  Print ""
  
	'' Create a pointer, and set its value to the one passed to the
	'' Constructor.
  This.Foo = New Integer
  *This.Foo = DefVal
End Constructor

Destructor MyObj()
  Print "Deleting our Integer in MyObj!"
  Print ""
  
	'' Delete the pointer we created in MyObj.
  Delete This.Foo
  This.Foo = 0
End Destructor


Scope
	'' Create a MyObj type object
	'' Send the value of '10' to the constructor
  Dim As MyObj Bar = 10
  
	'' See if the integer's been created.  Print its value.
  Print "The Value of our integer is: " & *Bar.Foo
  Print ""
  
  Sleep
End Scope
  '' We've just gone out of a scope.  The Destructor should be called now
  '' Because our objects are being deleted.
Sleep
%%
Exemple de construction plus avanc&eacute;e, montrant une surcharge constructeur entre autres choses.
{{fbdoc item="filename" value="examples/manual/udt/constructor.bas"}}%%(freebasic)
type sample

  _text as string

  declare constructor ()
  declare constructor ( a as integer )
  declare constructor ( a as single  ) 
  declare constructor ( a as string, b as byte ) 

  declare operator cast () as string

end type

constructor sample ()
  print "constructor sample ()"
  print
  this._text = "Empty"
end constructor

constructor sample ( a as integer )
  print "constructor sample ( a as integer )"
  print "  a = "; a
  print
  this._text = str(a)
end constructor

constructor sample ( a as single )
  print "constructor sample ( a as single )"
  print "  a = "; a
  print
  this._text = str(a)
end constructor

constructor sample ( a as string, b as byte )
  print "constructor sample ( a as string, b as byte )"
  print "  a = "; a
  print "  b = "; b
  print
  this._text = str(a) + "," + str(b)
end constructor

TheOperator sample.cast () As String
  return this._text
end operator

print "Creating x1"
dim x1 as sample

print "Creating x2"
dim x2 as sample = 1

print "Creating x3"
dim x3 as sample = 99.9

print "Creating x4"
dim x4 as sample = sample( "aaa", 1 )

print "Values:"
print "  x1 = "; x1
print "  x2 = "; x2
print "  x3 = "; x3
print "  x4 = "; x4
%%
{{fbdoc item="lang"}}
	- Les caract&eacute;ristiques li&eacute;es &agrave; l'objet sont prises en charge uniquement dans le dialecte //[[CompilerOptlang -lang fb]]//

{{fbdoc item="diff"}}
	- Nouveau pour FreeBASIC

{{fbdoc item="see"}}
	- ##[[KeyPgType Class]]##
	- ##[[KeyPgModuleConstructor Constructor (Module)]]##
	- ##[[KeyPgOpNew New]]##
	- ##[[KeyPgDestructor Destructor]]##
	- ##[[KeyPgType Type]]##

{{fbdoc item="back" value="CatPgUserDefTypes|User Defined Types"}}