{{fbdoc item="title" value="FUNCTION"}}----
D&eacute;finit une proc&eacute;dure retournant une valeur

{{fbdoc item="syntax"}}##
	[[[KeyPgPublic Public]]|[[KeyPgPrivate Private]]] **Function** //identifier// [[[KeyPgCdecl CDecl]]|[[KeyPgPascal Pascal]]|[[KeyPgStdcall StdCall]]] [[[KeyPgOverload Overload]]] [[[KeyPgAlias Alias]] //external_identifier//] [([//parameter_list//])] [[[KeyPgAs As]] //return_type//] [[[KeyPgStatic Static]]] [[[KeyPgExport Export]]]
		//statements//
		...
		{ {[[KeyPgReturn Return]] [//return_value//]}|{Function = //return_value//}|{//identifier// = //return_value//} }
		...
	[[KeyPgEndblock End]] Function
##
{{fbdoc item="param"}}
	##//identifier//## 
	le nom de la fonction
	##//external_identifier//## 
	nom visible de l'ext&eacute;rieur (&agrave; l'&eacute;diteur de liens) entre guillemets
		##//parameter_list//## 
		##//parameter//[, //parameter//[, ...]]##
		##//parameter//## 
	##[[[KeyPgByref ByRef]]|[[KeyPgByval ByVal]]] //identifier// [[[KeyPgAs As]] //type//] [= //default_value//]##
	##//identifier//## 
	le nom de la variable r&eacute;f&eacute;renc&eacute;e dans la fonction.  Si l'argument est un tableau, alors l'identificateur doit &ecirc;tre suivi de parenth&egrave;ses vides. 

##//type//## 
	le type de variable
	##//default_value//## 
	la valeur de l'argument si rien n'est sp&eacute;cifi&eacute; dans l'appel
	##//return_type//## 
	le type de la variable retourn&eacute;e par la fonction
	##//statements//## 

	une ou plusieurs d&eacute;claration(s) qui compose(nt) le corps de la fonction
	
	##//return_value//## 
	
	la valeur retourn&eacute;e par la fonction

	{{fbdoc item="desc"}}
	
	Une fonction d&eacute;finit un bloc de code qui peut &ecirc;tre ex&eacute;cut&eacute; par une seule instruction (un appel de fonction) et retourne une valeur &agrave; l'appelant lorsqu'elle a termin&eacute; (la valeur retourn&eacute;e). Il y a plusieurs raisons d'utiliser les fonctions:

	- R&eacute;duit les redondances dans votre programme

- Permet la r&eacute;utilisation de code dans de nombreux programmes

- Am&eacute;liore la lisibilit&eacute; du programme
- Am&eacute;liore la maintenance du programme
- Facilite l'am&eacute;lioration de votre programme

//Droits d'acc&egrave;s// : Les mots-cl&eacute;s ##[[KeyPgPublic Public]]## et ##[[KeyPgPrivate Private]]## sp&eacute;cifient des droits d'acc&egrave;s, respectivement, publics ou priv&eacute;s entre niveaux-modules. Si aucun n'est donn&eacute;, par d&eacute;faut la fonction aura un acc&egrave;s (##[[KeyPgPublic Public]]##).

//Convention d'appel// : La convention d'appel, ou l'ordre dans lequel les arguments sont entr&eacute;s et sortis de la pile lors des appels de fonction, est sp&eacute;cifi&eacute;e avec les mots-cl&eacute;s ##[[KeyPgCdecl cdecl]]##, ##[[KeyPgPascal pascal]]## et ##[[KeyPgStdcall stdcall]]##. Si aucune n'est fournie, la fonction utilise la convention standard par d&eacute;faut (##[[KeyPgStdcall stdcall]]##).

//Passage des arguments// : Les fonctions peuvent recevoir une ou plusieurs variables, ou arguments, en cas d'appel. Ces arguments sont r&eacute;pertori&eacute;s en tant que ##//parameters//## dans ##//parameter_list//##. Les mots-cl&eacute;s ##[[KeyPgByref ByRef]]## et ##[[KeyPgByval ByVal]]## pr&eacute;cisent si l'argument sera pass&eacute; par r&eacute;f&eacute;rence ou par valeur, respectivement. Le type de l'argument est donn&eacute;e par "##[[KeyPgAs As]] //type//##" derri&egrave;re le ##//parameter//##. Si un param&egrave;tre est donn&eacute; dans la d&eacute;claration avec une valeur par d&eacute;faut, le param&egrave;tre est facultatif.  Les param&egrave;tres de tableaux sont sp&eacute;cifi&eacute;s en pla&ccedil;ant des parenth&egrave;ses vides apr&egrave;s l'identifiant.  Notez que les param&egrave;tres tableau sont toujours ##[[KeyPgByref ByRef]]## et le mot-clef ##[[KeyPgByref ByRef]]## n'est ni n&eacute;cessaire ni permis comme param&egrave;tre tableau.  Lorsque vous appelez une fonction avec un argument de tableau les parenth&egrave;ses sont de rigueur l&agrave; aussi, voir les exemples.
	//Fonctions surcharg&eacute;es// : Une fonction surcharg&eacute;e peut partager le m&ecirc;me nom (##//identifier//##) qu'une autre avec une signature diff&eacute;rente. Le mot-cl&eacute; ##[[KeyPgOverload Overload]]## pr&eacute;cise qu'une fonction peut &ecirc;tre surcharg&eacute;e. Une fonction peut &ecirc;tre d&eacute;finie - ou d&eacute;clar&eacute;e - en utilisant le mot-cl&eacute;  ##[[KeyPgOverload Overload]]## avant toutes les fonctions qui les surchargent.
//Les valeurs de retour// : ##//return_type//## sp&eacute;cifie le ##[[DataType data type]]## retourn&eacute; par une fonction &agrave; la sortie. Si aucun type de donn&eacute;es n'est sp&eacute;cifi&eacute;, alors la fonction retournera le type de donn&eacute;es par d&eacute;faut, qui sera ##//Integer//## sauf si a &eacute;t&eacute; pr&eacute;cis&eacute; un autre type de donn&eacute;es en utilisant ##[[KeyPgDefsng DefSng]]##, ##[[KeyPgDefdbl DefDbl]]##, ##[[KeyPgDefstr DefStr]]##, etc. Les fonctions peuvent retourner des valeurs //(et bient&ocirc;t, des r&eacute;f&eacute;rences)// en utilisant trois m&eacute;thodes: le mot-cl&eacute; ##[[KeyPgReturn Return]]## suivi d'une valeur fait sortir de la fonction imm&eacute;diatement et renvoie cette valeur &agrave; l'appelant. Les fonctions peuvent &eacute;galement renvoyer des valeurs en attribuant le mot cl&eacute; ##//Function//## ou l'##//identifier//## de la fonction &agrave; la valeur de retour souhait&eacute;e. Cependant, les deux derni&egrave;res m&eacute;thodes ne provoquent pas la sortie de la fonction. Comme les fonctions retournent des valeurs, les appels de fonction &eacute;valuent les expressions. Ainsi, les appels de fonction peuvent &ecirc;tre faits partout o&ugrave; une expression est attendue, comme dans les d&eacute;clarations [[KeyPgOpAssignment Affectations]] ou ##[[KeyPgIfthen If]]##.
//Pr&eacute;servation des variables locales// : Le mot-clef ##[[KeyPgStatic Static]]## indique que les variables locales d&eacute;clar&eacute;es dans une fonction sont conserv&eacute;es entre les appels de cette fonction. En entrant dans une fonction d&eacute;finie avec ##[[KeyPgStatic Static]]##, les variables locales ont la m&ecirc;me valeur que la derni&egrave;re fois que la fonction a &eacute;t&eacute; appel&eacute;e.

{{fbdoc item="ex"}}
'' This program demonstrates the declaration of a function 
'' This program demonstrates the declaration of a function 

'' and returning a value using Return command

Declare Function ReturnTen () As Integer

Print ReturnTen () '' ReturnTen returns an integer by default.
	Function ReturnTen() As Integer
Return 10
End Function

%%
'' This program demonstrates function overloading.

'' This program demonstrates the declaration of a function 
'' and returning a value using assignment to function name
Declare Function ReturnTen () As Integer
Print ReturnTen () '' ReturnTen returns an integer by default.

Function ReturnTen() As Integer
ReturnTen = 10
End Function

%%
	%%(freebasic)
'' This program demonstrates function overloading.

'' The overloaded functions must be FIRST.
	Declare Function ReturnTen Overload (a As Single) As Integer
Declare Function ReturnTen Overload (a As String) As Integer

Declare Function ReturnTen (a As Integer) As Integer
	Print ReturnTen (10.000!) '' ReturnTen will take a single and return an integer
Print ReturnTen (10)      '' ReturnTen will take an integer and return an integer
Print ReturnTen ("10")    '' ReturnTen will take a string and return an integer

Function ReturnTen Overload (a As Single) As Integer
Return Int(a)

End Function
	Function ReturnTen Overload (a As String) As Integer
Return Val(a)

End Function
Function ReturnTen (a As Integer) As Integer
Return a

End Function
%%
'' functions taking array arguments.

'' The following example demonstrates optional parameters.
  Function TestFunc(P As String = "Default") As String
Return P

End Function
Print TestFunc("Testing:")
Print TestFunc
%%
%%

'' This example shows how to declare and call 
	'' functions taking array arguments.
	Function x(b() As Double) As Integer
	x = UBound(b)-LBound(b)+1
	End Function

Dim a(1 To 10) As Double
	Print x(a())
	Dim c(10 To 20) As Double 
	Print x(c())
	%%
	{{fbdoc item="lang"}}

- Dans le dialecte //[[CompilerOptlang -lang fb]]// dialect, ##**ByVal**## est la convention par d&eacute;faut de passage de param&egrave;tre pour tous les types int&eacute;gr&eacute;s sauf ##[[KeyPgString String]]##; ##**String**## et les ##[[KeyPgType Type]]##s d&eacute;finis par l'utilisateur sont pass&eacute;s ##[[KeyPgByref ByRef]]## par d&eacute;faut.
	- Dans les dialectes //[[CompilerOptlang -lang qb]]// et //[[CompilerOptlang -lang fblite]]//, ##**ByRef**## est la convention par d&eacute;faut de passage de param&egrave;tre.
	- Dans le dialecte //[[CompilerOptlang -lang qb]]//, le nom de la fonction doit &ecirc;tre utilis&eacute; dans une affectation pour sp&eacute;cifier la valeur de retour.  Utiliser ##**Function** = ...##" pour sp&eacute;cifier que la valeur de retour ne peut &ecirc;tre utilis&eacute;e.
	- Dans les dialectes //[[CompilerOptlang -lang qb]]// et //[[CompilerOptlang -lang fblite]]//, ##[[KeyPgReturn Return]]## peut &ecirc;tre utilis&eacute; pour retourner une valeur lorsque ##[[KeyPgOptiongosub Option Gosub]]## n'est pas valide.  Dans //[[CompilerOptlang -lang qb]]//, cela doit &ecirc;tre fait en utilisant explicitement l'instruction ##[[KeyPgOptionnogosub Option Nogosub]]##.
	{{fbdoc item="diff"}}
	- Les param&egrave;tres peuvent &ecirc;tre optionnels en FreeBASIC.
	- En QBASIC, le type de retour peut &ecirc;tre sp&eacute;cifi&eacute; seulement avec un suffixe, pas avec ##AS TYPE##, et autoriser seulement les fonctions &agrave; retourner un type int&eacute;gr&eacute;.

- La valeur de retour peut maintenant &ecirc;tre pr&eacute;cis&eacute;e par une instruction ##[[KeyPgReturn Return]]##.
