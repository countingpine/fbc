{{fbdoc item="title" value="Operator AND (Conjunction)"}}----
Retourne la manipulation de bits AND (conjonction) de deux valeurs numériques

{{fbdoc item="syntax"}}##
	[[KeyPgDeclare declare]] [[KeyPgOperator operator]] **And** ( [[KeyPgByref byref]] //lhs// [[KeyPgAs as]] //T1//, [[KeyPgByref byref]] //rhs// [[KeyPgAs as]] //T2// ) [[KeyPgAs as]] //Ret//
##
{{fbdoc item="usage"}}##
	//result// = //lhs// **And** //rhs//
##
{{fbdoc item="param"}}
	##//lhs//##
		L'expression du côté gauche.
	##//T1//##
		N'importe quel type numérique.
	##//rhs//##
		L'expression du côté droit.
	##//T2//##
		N'importe quel type numérique.
	##//Ret//##
		Un type numérique (varie avec ##//T1//## et ##//T2//##).

{{fbdoc item="ret"}}
	Retourne la manipulation de bits AND (conjonction) des deux opérandes.

{{fbdoc item="desc"}}
	Cet opérateur retourne la manipulation de bits AND de ses opérandes, une opération logique dont le résultat est une valeur dont les bits dépendent de la valeur des bits des deux opérandes.

	La table de vérité ci-dessous montre les différentes combinaisons d'une opération AND booléenne:

	{{table columns="3" cellpadding="2" cells="Bit côté gauche;Bit côté droit;Résultat;0;0;0;1;0;0;0;1;0;1;1;1"}}

	Aucun court-circuit n'est exécuté - les deux expressions sont toujours évaluées.
	
	Le type de la valeur retournée dépend des types des valeurs passées. Les valeurs de types ##[[KeyPgByte Byte]]##, ##[[KeyPgUbyte Ubyte]]## et à virgule flottante sont en premier converties en ##[[KeyPgInteger Integer]]##. Si les types des deux côtés diffèrent seulement par le fait d'être signé ou non, alors le type de la valeur retournée sera le même que le type le l'opérande côté gauche (##//T1//##), autrement, le plus large des deux types sera utilisé.

	Cet opérateur peut être surchargé pour des types définis par l'utilisateur.

{{fbdoc item="ex"}}
{{fbdoc item="filename" value="examples/manual/operator/and-bitwise.bas"}}%%(freebasic)
' Using the AND operator on two numeric values
DIM AS UBYTE numeric_value1, numeric_value2
numeric_value1 = 15 '00001111
numeric_value2 = 30 '00011110

'Result =  14  =     00001110
PRINT numeric_value1 AND numeric_value2
SLEEP
%%

{{fbdoc item="filename" value="examples/manual/operator/and-logical.bas"}}%%(freebasic)
' Using the AND operator on two conditional expressions
Dim As UByte numeric_value1, numeric_value2
numeric_value1 = 15
numeric_value2 = 25

IF numeric_value1 > 10 AND numeric_value1 < 20 Then Print "Numeric_Value1 is between 10 and 20"
IF numeric_value2 > 10 AND numeric_value2 < 20 Then Print "Numeric_Value2 is between 10 and 20"
SLEEP

' This will output "Numeric_Value1 is between 10 and 20" because
' both conditions of the IF statement is true
' It will not output the result of the second IF statement because the first
' condition is true and the second is false.
%%

{{fbdoc item="lang"}}
	- Dans le dialecte //[[CompilerOptlang -lang qb]]//, cet opérateur ne peut pas être surchargé.

{{fbdoc item="diff"}}
	- Aucune

{{fbdoc item="see"}}
	- [[TblTruth Table de vérité des opérateurs]]

{{fbdoc item="back" value="CatPgOpLogical|Logical Operators"}}{{fbdoc item="back" value="CatPgOperators|Operators"}}