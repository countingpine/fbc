{{fbdoc item="title" value="Dynamic Arrays in Types"}}----
//Ecrit par [[WikiRick rdc]]//

<div class="fb_header"> Introduction 

Un tableau dynamique dans une d&eacute;finition de type est une fonctionnalit&eacute; tr&egrave;s utile, mais FreeBASIC ne le supporte pas. Ou plut&ocirc;t, il ne le supporte pas directement. Cependant, vous pouvez cr&eacute;er des tableaux dynamiques en utilisant les pointeurs et les fonctions associ&eacute;es &agrave; la m&eacute;moire.

Un tableau est simplement un bloc contigu de m&eacute;moire qui contient un certain type de donn&eacute;es. Les tableaux en FreeBASIC utilisent un descripteur de tableau pour d&eacute;crire les donn&eacute;es contenues dans celui-ci et vous pouvez utiliser cette m&ecirc;me technique pour construire un tableau dynamique dans un type. Les deux &eacute;l&eacute;ments dont vous avez besoin dans votre "type def" sont un pointeur sur un type particulier de donn&eacute;es et un indicateur de taille.

Vous pouvez ensuite utiliser le "champ ptr" pour allouer un bloc de m&eacute;moire de la taille n&eacute;cessaire et enregistrer cette taille dans le champ de l'indicateur de taille. Le champ de taille est utilis&eacute; pour vous dire combien d'&eacute;l&eacute;ments sont actuellement dans le tableau. Une fois que le tableau a &eacute;t&eacute; initialis&eacute;, vous pouvez ensuite utiliser l'indexation pointeur pour acc&eacute;der &agrave; chaque &eacute;l&eacute;ment du tableau.

<div class="fb_header">Obtenir le Pointeur dans le Code

Le programme suivant illustre les &eacute;tapes de la cr&eacute;ation, l'initialisation et le redimensionnement dynamique d'un tableau "type def".
%%(freebasic)
'Define type:
'size is current size of array
'darray will contain array data
Type DType
	size As Integer
	darray As Integer Ptr
End Type

'Create an instance of type
Dim myType As DType
Dim As Integer i, tmp

'Create enough space for elements
myType.darray = Callocate(5, Sizeof(Integer))
'Set the length of the array
'in the array size indicator
myType.size = 5

'Load data into array
For i = 0 To myType.Size - 1 
	myType.darray[i] = i
Next

'Print data
For i = 0 To myType.Size - 1
	Print "darray[";i;" ]:";myType.darray[i]
Next
Print "Press any key..."
Sleep
Print

'Save the current array size
tmp = myType.size
'Now resize the array
myType.darray = Reallocate(myType.darray, 10)
'Set the length indicator
myType.size = 10

'Load in data into new allocation
For i = tmp - 1 To myType.Size - 1
	myType.darray[i] = i
Next

'Print out contents
For i = 0 To myType.Size - 1
	Print "darray[";i;" ]:";myType.darray[i]
Next
Print "Press any key..."
Sleep

'Free allocated space
Deallocate myType.darray

End
%%

<div class="fb_header">Comment &ccedil;a marche?

La premi&egrave;re &eacute;tape est, bien s&ucirc;r, de d&eacute;finir le "type-def":
%%(freebasic)
Type DType
	size As Integer
	darray As Integer Ptr
End Type
%%

Comme ce n'est qu'un exemple, il y a seulement deux &eacute;l&eacute;ments dans le type, un indicateur de taille et le pointeur de tableau. Notez que le pointeur de tableau est d&eacute;fini comme un "ptr Integer". Lorsque vous d&eacute;finissez un pointeur sur un type particulier, vous cr&eacute;ez un pointeur typ&eacute;. Le compilateur peut utiliser ces informations de type pour v&eacute;rifier et s'assurer que les valeurs plac&eacute;es dans le tableau sont valides et utilisera ces informations pour l'arithm&eacute;tique des pointeurs.

La prochaine &eacute;tape est de d&eacute;finir les variables de travail.
%%(freebasic)
Dim myType As DType
Dim As Integer i, tmp
%%
Voici un exemple du type qui a &eacute;t&eacute; cr&eacute;&eacute;, ainsi que certaines variables de travail qui sont utilis&eacute;es dans le code suivant. ATTENTION: Vous devez initialiser le pointeur de tableau avant que vous puissiez l'utiliser; utiliser un pointeur non initialis&eacute; peut provoquer des plantages du programme, des blocages du syst&egrave;me et toutes sortes de mauvaises choses.
%%(freebasic)
myType.darray = Callocate(5, Sizeof(Integer))
myType.size = 5
%%
Ces deux lignes de code initialisent le pointeur de tableau pour contenir 5 entiers. "Callocate" est utilis&eacute; pour allouer le segment de m&eacute;moire, "Callocate" va initialiser le segment avec des z&eacute;ros.

Le champ de la taille stocke la longueur courante du tableau. Maintenant, bien s&ucirc;r, vous pouvez calculer la taille du tableau en divisant simplement le nombre d'octets dans l'allocation par la taille d'un entier, mais en utilisant un indicateur de taille dans le type est beaucoup plus propre et vous fait gagner un calcul dans votre programme.
%%(freebasic)
For i = 0 To myType.Size - 1 
	myType.darray[i] = i
Next
%%
Cette section de code charge le tableau avec quelques valeurs. Vous pouvez voir que sauver la taille du tableau simplifie le processus de codage. Comme le tableau est un pointeur typ&eacute;, vous pouvez acc&eacute;der au tableau en utilisant la m&eacute;thode d'indexation pointeur, qui est presque comme l'acc&egrave;s &agrave; un tableau pr&eacute;d&eacute;fini.
%%(freebasic)
For i = 0 To myType.Size - 1
	Print "darray[";i;" ]:";myType.darray[i]
Next
%%
Cette section affiche simplement les valeurs en utilisant la m&ecirc;me m&eacute;thode qui a &eacute;t&eacute; utilis&eacute;e pour charger le tableau.

Bien s&ucirc;r, cela doit &ecirc;tre un tableau dynamique, donc vous devriez &ecirc;tre capable de redimensionner le tableau et c'est exactement ce que la section de code suivante va faire.
%%(freebasic)
tmp = myType.size
myType.darray = Reallocate(myType.darray, 10)
myType.size = 10
%%
La premi&egrave;re ligne de code enregistre la taille actuelle du tableau de sorte que le nouveau segment de m&eacute;moire peut &ecirc;tre initialis&eacute; sans &eacute;craser les donn&eacute;es existantes. Vous verrez dans un instant.

La seconde ligne utilise la fonction "Reallocate" pour redimensionner le segment de m&eacute;moire, c'est-&agrave; dire redimensionner le tableau. Dans ce cas, le tableau est plus grand; vous pourriez bien s&ucirc;r faire le tableau plus petit. Si vous deviez faire le tableau plus petit, toutes les donn&eacute;es en-dehors du nouveau segment seraient perdues, comme vous le souhaitiez.

La derni&egrave;re ligne de code ci-dessus enregistre la taille du tableau nouveau dans l'indicateur de taille.
%%(freebasic)
For i = tmp - 1 To myType.Size - 1
	myType.darray[i] = i
Next
%%
Ici, vous pouvez voir pourquoi l'ancienne taille du tableau a &eacute;t&eacute; enregistr&eacute;e. Dans l'instruction "For", la proc&eacute;dure d'initialisation commence &agrave; partir de l'ancien indice et parcourt les indices nouvellement ajout&eacute;s, stockant les donn&eacute;es dans le segment de m&eacute;moire. C'est comme utiliser la d&eacute;claration "Redim Preserve" sur un tableau normal.
%%(freebasic)
For i = 0 To myType.Size - 1
	Print "darray[";i;" ]:";myType.darray[i]
Next
%%
Cette section de code affiche simplement les nouvelles valeurs. 
%%(freebasic)
Deallocate myType.darray
%%
Ceci est d'une importance vitale. Vous devez toujours lib&eacute;rer toute la m&eacute;moire allou&eacute;e que vous avez cr&eacute;&eacute; dans votre programme afin de pr&eacute;venir les fuites de m&eacute;moire.

Lorsque vous ex&eacute;cutez le programme, vous devriez avoir l'affichage suivant:
%%(freebasic)
darray[ 0 ]: 0
darray[ 1 ]: 1
darray[ 2 ]: 2
darray[ 3 ]: 3
darray[ 4 ]: 4
Press any key...

darray[ 0 ]: 0
darray[ 1 ]: 1
darray[ 2 ]: 2
darray[ 3 ]: 3
darray[ 4 ]: 4
darray[ 5 ]: 5
darray[ 6 ]: 6
darray[ 7 ]: 7
darray[ 8 ]: 8
darray[ 9 ]: 9
Press any key...
%%
Le premier affichage montre le tableau original. Le second affichage montre le tableau nouvellement redimensionn&eacute;.
