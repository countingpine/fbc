{{fbdoc item="title" value="Linked Lists"}}----

Une liste chaînée est une structure qui est facilement extensible en utilisant une seule fonction et qui devient dans très utile lorsque vous avez besoin d'un tableau de quelque chose, mais dont vous n'avez aucune idée de combien. Le concept derrière une liste chaînée est que chaque structure de noeud a un pointeur vers la structure de noeud suivante et précédente. C'est ce qu'on appelle une double liste  chaînée, car il relie deux noeuds différents. En utilisant un pointeur sur une structure, vous pouvez spécifier un pointeur nul si il n'y a pas de noeud suivant ou précédent, et puisque le pointeur stocke une adresse mémoire, le montant des noeuds, vous pouvez stocker est limité uniquement par la mémoire.

Le seul inconvénient de l'utilisation d'une liste chaînée est que dans le but de stocker par exemple un entier, vous devez allouer de l'espace non seulement pour ce nombre entier, mais aussi pour une structure qui contient un pointeur vers l'entier et un pointeur vers les noeuds environnants. Cependant, cela n'a pas beaucoup d'importance sur les ordinateurs modernes, sauf si vous stockez des millions de noeuds.

La structure de base de la liste chaînée est le noeud. La déclaration est la suivante:
%%(freebasic)
type listnode
	as any ptr pData
	as listnode ptr pNext
	as listnode ptr pPrev
end type
%%
Une petite remarque, si quelqu'un qui a accès à ces scripts désire les mettre à jour car ils contiennent des mots-clefs nouveaux pour ""FreeBASIC"" (comme ptr), il est libre de le faire :) Aussi, LIST n'apparaît pas comme un mot-clef FB keyword (corrigez-moi si je me trompe).

Cette structure contient trois pointeurs. Le premier est un pointeur sur quelque chose (Any Ptr), ce qui signifie que vous pouvez stocker des chaînes, des entiers, des caractères, même des types définis par l'utilisateur et des unions. Mais cela signifie aussi que vous devez passer un pointeur. Vous pouvez obtenir un pointeur en utilisant la fonction Allocate (ou CAllocate).
Les deux pointeurs suivants sont des pointeurs vers des //listnode//s, ceci dit, vous êtes techniquement autorisé à faire cela:
Print node->pNext->pNext->pNext->pNext->pNext...
puisque chaque noeud contient un pointeur vers un autre noeud. Le problème avec la syntaxe ci-dessus est que vous êtes limité par la quantité de noeuds auxquels vous pouvez accéder et le code est difficile à comprendre. Vous pouvez utiliser la fonction de //""ListGetNext""// à cet effet et une boucle avec //While//.

Avant d'aller plus loin, voyons toutes les déclarations pour l'utilisation de listes chaînées. Notez que chaque fonction a un préfixe "List".

%%(freebasic)
declare function ListCreate() as listnode ptr
declare function ListAdd(list as listnode ptr, item as any ptr) as any ptr
declare function ListAddHead(list as listnode ptr, item as any ptr) as any ptr
declare function ListGetFirst(list as listnode ptr) as listnode ptr
declare function ListGetLast(list as listnode ptr) as listnode ptr
declare function ListGetNext(list as listnode ptr) as listnode ptr
declare function ListGetPrev(list as listnode ptr) as listnode ptr
declare function ListGetData(list as listnode ptr) as any ptr
declare function ListRemove(list as listnode ptr, bDelete as integer = 0) as listnode ptr
declare function ListRemoveAll(list as listnode ptr, bDelete as integer = 0)
%%
Hmm, il semble qu'il n'aime pas mon utilisation de "Rem" dans une fonction. Mais il le compile quand même.

Vous pouvez voir qu'il y a une fonction pour créer une liste chaînée, ajouter un élément, obtenir différents noeuds, obtenir des données et supprimer des noeuds. Actuellement, nous allons nous concentrer sur la fonction """ListCreate""". Elle n'a aucun paramètre et renvoie un pointeur "listnode" La structure qu'elle crée ne contient pas de données. La structure entière est nulle, mais c'est quand même une structure. Si vous ajoutez un noeud, le membre pNext va changer et pointer vers le nouvel élément, de sorte qu'il ne restera pas comme un noeud nul, car cela n'aurait pas de sens. Toutefois, la valeur retournée par """ListCreate""" ne stockera pas toutes les données  et n'aura pas un noeud précédent.

La fonction """ListCreate""" ressemble à ceci:br \>%%(freebasic)
%%' CREATE
Function ListCreate() As Any Ptr
Dim As listnode Ptr pTemp
	pTemp = CAllocate(Len(listnode))
	' CAllocate automatically zeroes memory.
	Return pTemp

	End Function
Je préfère utiliser l'instruction Return pour renvoyer une valeur à partir d'une fonction, mais FUNCTION = pTemp et ListCreate = pTemp sont aussi permis, bien qu'ils ne fassent pas quitter immédiatement la fonction.
%%
Le but de cette fonction est facile à voir, un noeud est alloué et retourné. Le commentaire dit que la fonction CAllocate remplit automatiquement la mémoire de  zéros. Si vous avez utilisé la fonction "Allocate", la mémoire ne serait pas remplie automatiquement de zéros et vous auriez à le faire vous-même.

Les fonctions suivantes, ListAdd et ListAddHead, ajoutent un noeud à la liste. ListAdd ajoute un noeud à la fin de la liste (la queue), tandis que ListAddHead met un noeud tout en haut (la tête).

(freebasic)

%%' ADD, ADDHEAD
Function ListAdd(list As listnode Ptr, item As Any Ptr) As Any Ptr

Dim As listnode Ptr pTemp
	If (list = 0) Then Return item

	pTemp = ListGetLast(list)

	pTemp->pNext = CAllocate(Len(listnode))

	pTemp->pNext->pPrev = pTemp
	pTemp->pNext->pData = item
	Return item

	End Function
Function ListAddHead(list As listnode Ptr, item As Any Ptr) As Any Ptr

Dim As listnode Ptr pTemp
	If (list = 0) Then Return item

	pTemp = list->pNext

	list->pNext = CAllocate(Len(listnode))
	list->pNext->pPrev = list

	list->pNext->pData = item
	list->pNext->pNext = pTemp
	If (pTemp <> 0) Then

	pTemp->pPrev = list->pNext
		End If
	Return item

	End Function
Vous pouvez voir que ListeAdd fait référence à une fonction qui n'est pas encore prête, ListGetLast. Pour l'instant tout ce que vous devez savoir est qu'elle retourne un pointeur sur le dernier noeud de la liste. Elle sera traîtée plus tard.
%%
ListeAdd récupère le dernier noeud et définit son pointeur "pNext" vers une nouvelle structure "listnode". Cela ne provoquera pas de perte de mémoire puisque le dernier noeud a un "pNext" de valeur nulle et vient après. Une fois que notre noeud est ajouté, nous pouvons y accéder en utilisant l'opérateur ->. La ligne

pTemp->pNext->pPrev = pTemp
est toute la base de listes chaînées, la pièce de liaison. Ce qui est dit c'est que nous avons une référence à un noeud. Ce noeud sait où se trouve le noeud suivant, et maintenant nous pouvons dire que le noeud après ce suivant est là où le précédent est. Cela peut sembler un peu redondant au premier abord, mais le compilateur ne sait pas où sont les noeuds jusqu'à ce que vous les définissiez. Une fois que vous avez fait cela, vous pouvez parcourir la liste chaînée.
La fonction "ListAddHead" est un peu plus compliquée, puisque nous insérons sommes un noeud entre le premier noeud actuel et le noeud nul de "ListCreate". Ce qu'il fait essentiellement est d'allouer de l'espace pour contenir le noeud courant d'abord, créer un nouveau noeud là et les lier tous ensemble. Si vous regardez d'un peu plus près, cela devrait vous sembler beaucoup plus clair. L'instruction "If" à la fin est tout simplement là pour éviter un accès à de la mémoire qui n'existe pas (NULL->pPrev). Si pTemp n'est pas dans les fait égal à zéro, alors le membre pPrev sera assigné. Sinon, il n'y a aucune raison de s'inquiéter à ce sujet.

Les fonctions suivantes sont ListGetFirst et ListGetLast. Je les ai mises en oeuvre car "ListGetLast" a été référencée dans une fonction précédemment.

(freebasic)

%%' GETFIRST, GETLAST
Function ListGetFirst(list As listnode Ptr) As Any Ptr

If (list = 0) Then Return 0
	Return list->pNext

	End Function
Function ListGetLast(list As listnode Ptr) As Any Ptr

Dim As listnode Ptr pTemp
	If (list = 0) Then Return 0

	pTemp = list

	While (pTemp->pNext <> 0)
	pTemp = pTemp->pNext
		Wend
	Return pTemp

	End Function
La première fonction est probablement la fonction la plus courte et la plus facile à comprendre, même si elle repose sur le fait que vous détenez un pointeur vers le noeud retourné par "ListCreate". Si vous ne le faites pas, elle pourrait retourner n'importe quel noeud aléatoire. Tout ce qu'elle fait est de retourner un pointeur vers le premier noeud ou le noeud qui vient juste après le noeud nul.
%%

La seconde fonction, "ListGetLast", boucle à travers la liste jusqu'à ce qu'elle trouve un noeud nul. La raison pour laquelle je vérifie si "pTemp->pNext = 0" au lieu de "pTemp = 0", c'est que je ne veux pas qu'elle retourne zéro. Je veux retourner le dernier noeud, qui est le noeud qui a sa valeur pNext mise à zéro. Une fois que le noeud est trouvé, ListGetLast le renvoie .

Les trois prochaines fonctions sont simplement des fonctions d'aide et pourraient être facilement réalisées avec une ligne de code. Elles existent réellement, car l'implémentation initiale qui n'a pas été écrite par moi, avait une fonction "ListGetNext".

(freebasic)

%%' GETNEXT, GETPREV
Function ListGetNext(list As listnode Ptr) As Any Ptr

If (list = 0) Then Return 0
	Return list->pNext

	End Function
Function ListGetPrev(list As listnode Ptr) As Any Ptr

' can't do anything to a null list
	If (list = 0) Then Return 0
	' this is needed for below
	If (list->pPrev = 0) Then Return 0
	' since the list starts with a null node (pPrev and pData = 0),
	' the first should be the one right after the real first.
	If (list->pPrev->pPrev = 0) Then Return 0
	Return list->pPrev

	End Function
' GETDATA

Function ListGetData(list As listnode Ptr) As Any Ptr

If (list = 0) Then Return 0
	Return list->pData

	End Function
La première fonction, ListGetNext, est exactement la même que "ListGetFirst", mais elle se différencie par le point de vue. Bien que vous puissiez utiliser ListGetFirst sur ô€‹ô€‹une valeur noeud dans cette implémentation, ce n'est pas une bonne idée parce que certains d'autres implémentations peuvent boucler sur le début de la liste afin de trouver le premier noeud, auquel cas vous seriez coincé dans une boucle infinie.
%%

La fonction "ListGetPrev" est un peu plus complexe, car je ne veux pas retourner de noeud nul. La première ligne de code et la troisième (et non les commentaires) sont celles qui sont réellement nécessaires, mais la seconde assure que nous n'accédons pas à de la mémoire nulle. La troisième ligne dit que si le noeud, deux noeuds au-dessus, est nul, nous devrions retourner zéro. Cela signifie que si vous êtes au niveau du noeud le plus haut (pas le noeud nul), il n'y a pas de noeud précédent avec lequel vous pourriez faire n'importe quoi, bien qu'il y existe un noeud précédent et on devrait retourner zéro. La dernière ligne traite le cas par défaut, où il existe en fait un noeud précédent qui doit donc être retourné.

La fonction "ListGetData" est aussi simple et brève comme les fonctions "ListGetFirst" et "ListGetNext". Elle renvoie simplement un pointeur sur les données du noeud.

Les deux dernières fonctions suppriment des noeuds de la liste.

(freebasic)
%%' REMOVE, REMOVEALL
Function ListRemove(list As listnode Ptr, bDelete As Integer = 0) As Any Ptr

Dim As listnode Ptr pPrev
	Dim As listnode Ptr pNext
	If (list = 0) Then Return 0

	pPrev = list->pPrev

	pNext = list->pNext
	If ((list->pData <> 0) And (bDelete <> 0)) Then Deallocate list->pData

	Deallocate list

	If (pPrev <> 0) Then

	pPrev->pNext = pNext
		End If
	If (pNext <> 0) Then
	pNext->pPrev = pPrev
		End If
	Return pNext

	End Function
Function ListRemoveAll(list As listnode Ptr, bDelete As Integer = 0)

Dim As listnode Ptr node
	node = list

	If (list = 0) Then Return 0
	While (node <> 0)

	If ((node->pData <> 0) And (bDelete <> 0)) Then Deallocate node->pData
		node = ListRemove(node)
		Wend
	Return

	End Function
La fonction "ListRemove" a deux utilités: supprimer le noeud spécifié et relier ensemble les deux noeuds environnants. Vous pouvez voir que pour ce faire elle stocke le pointeur précédent et le suivant. Le paramètre optionnel, "bdelete", spécifie si l'élément de données devrait être supprimé. Si vous stockez seulement des entiers, ou même des structures sans pointeurs à l'intérieur, vous pouvez passer 1 à ce paramètre et l'élément sera supprimé pour vous. Mais si vous avez une structure contenant des pointeurs, la meilleure idée est de supprimer toutes les données vous-même et laisser "ListRemove" gérer seulement la partie liste pour s'assurer qu'il n'y a pas de perte de mémoire. Le pointeur "listnode" est désalloué indépendamment quel que soit la valeur du paramètre.
%%

"""ListRemove""All" s'appuie sur la fonction """ListRemove""" pour supprimer les noeuds. Elle boucle simplement à travers la liste en utilisant une "boucle while" et supprime tous les noeuds. Le code original utilisait une "boucle For", mais FB ne semble pas faire comme mon

For node = list To 0 Step ""ListRemove""(node)
donc il a été changé
Ça y est, voici le fichier complet qui inclut un exemple dans le haut de façon à les utiliser. Ceci est la première fois que j'écris un tutoriel, alors n'hésitez pas à laisser des commentaires sur les points que je pourrais améliorer. Aussi, si vous trouvez un bug dans mon code (j'ai trouvé un certain nombre pendant la rédaction de ce tuto), s'il vous plaît faites le moi savoir. N'hésitez pas à modifier le bug, mais je voudrais être tenu au courant.

(freebasic)

%%Type listnode
As Any Ptr pData
	As listnode Ptr pNext
	As listnode Ptr pPrev
	End Type
Declare Function ListCreate() As listnode Ptr

Declare Function ListAdd(list As listnode Ptr, item As Any Ptr) As Any Ptr
Declare Function ListAddHead(list As listnode Ptr, item As Any Ptr) As Any Ptr
Declare Function ListGetFirst(list As listnode Ptr) As listnode Ptr
Declare Function ListGetLast(list As listnode Ptr) As listnode Ptr
Declare Function ListGetNext(list As listnode Ptr) As listnode Ptr
Declare Function ListGetPrev(list As listnode Ptr) As listnode Ptr
Declare Function ListGetData(list As listnode Ptr) As Any Ptr
Declare Function ListRemove(list As listnode Ptr, bDelete As Integer = 0) As listnode Ptr
Declare Function ListRemoveAll(list As listnode Ptr, bDelete As Integer = 0)
Dim As listnode Ptr list, node

Dim As Integer Ptr item
list = ListCreate()
item = ListAdd(list, CAllocate(Len(Integer)))
*item = 4
item = ListAdd(list, CAllocate(Len(Integer)))
*item = 44
item = 0 ' just to show it works
node = ListGetFirst(list)
While node <> 0

Print "found item"
	item = ListGetData(node)
	Print *item
	node = ListRemove(node,1)
	Wend
While Inkey$ = "" : Wend

' CREATE

Function ListCreate() As Any Ptr
Dim As listnode Ptr pTemp
	pTemp = CAllocate(Len(listnode))
	' CAllocate automatically zeroes memory.
	Return pTemp

	End Function
' ADD, ADDHEAD

Function ListAdd(list As listnode Ptr, item As Any Ptr) As Any Ptr

Dim As listnode Ptr pTemp
	If (list = 0) Then Return item

	pTemp = ListGetLast(list)

	pTemp->pNext = CAllocate(Len(listnode))

	pTemp->pNext->pPrev = pTemp
	pTemp->pNext->pData = item
	Return item

	End Function
Function ListAddHead(list As listnode Ptr, item As Any Ptr) As Any Ptr

Dim As listnode Ptr pTemp
	If (list = 0) Then Return item

	pTemp = list->pNext

	list->pNext = CAllocate(Len(listnode))
	list->pNext->pPrev = list

	list->pNext->pData = item
	list->pNext->pNext = pTemp
	If (pTemp <> 0) Then

	pTemp->pPrev = list->pNext
		End If
	Return item

	End Function
' GETFIRST, GETLAST

Function ListGetFirst(list As listnode Ptr) As Any Ptr

If (list = 0) Then Return 0
	Return list->pNext

	End Function
Function ListGetLast(list As listnode Ptr) As Any Ptr

Dim As listnode Ptr pTemp
	If (list = 0) Then Return 0

	pTemp = list

	While (pTemp->pNext <> 0)
	pTemp = pTemp->pNext
		Wend
	Return pTemp

	End Function
' GETNEXT, GETPREV

Function ListGetNext(list As listnode Ptr) As Any Ptr

If (list = 0) Then Return 0
	Return list->pNext

	End Function
Function ListGetPrev(list As listnode Ptr) As Any Ptr

' can't do anything to a null list
	If (list = 0) Then Return 0
	' this is needed for below
	If (list->pPrev = 0) Then Return 0
	' since the list starts with a null node (pPrev and pData = 0),
	' the first should be the one right after the real first.
	If (list->pPrev->pPrev = 0) Then Return 0
	Return list->pPrev

	End Function
' GETDATA

Function ListGetData(list As listnode Ptr) As Any Ptr

If (list = 0) Then Return 0
	Return list->pData

	End Function
' REMOVE, REMOVEALL

Function ListRemove(list As listnode Ptr, bDelete As Integer = 0) As Any Ptr

Dim As listnode Ptr pPrev
	Dim As listnode Ptr pNext
	If (list = 0) Then Return 0

	pPrev = list->pPrev

	pNext = list->pNext
	If ((list->pData <> 0) And (bDelete <> 0)) Then Deallocate list->pData

	Deallocate list

	If (pPrev <> 0) Then

	pPrev->pNext = pNext
		End If
	If (pNext <> 0) Then
	pNext->pPrev = pPrev
		End If
	Return pNext

	End Function
Function ListRemoveAll(list As listnode Ptr, bDelete As Integer = 0)

Dim As listnode Ptr node
	node = list

	If (list = 0) Then Return 0
	While (node <> 0)

	If ((node->pData <> 0) And (bDelete <> 0)) Then Deallocate node->pData
		node = ListRemove(node)
		Wend
	Return

	End Function
Si vous ne l'avez pas déjà remarqué, "ListeAdd" et "ListAddHead" renvoient un pointeur sur les données que vous entrez. L'exemple de code (voir ci-dessus) montre comment utiliser cette fonctionnalité. "ListRemove" renvoie un pointeur vers le noeud suivant. Voilà comment "ListRemoveAll" supprime les noeuds. "ListRemoveAll" est la seule fonction qui ne renvoie rien. Ce n'est pas nécessaire, puisque toute la liste sera vide après l'avoir appelée.
%%

If you haven't noticed already, ""ListAdd"" and ""ListAddHead"" return a pointer to the data you inputted. The sample code (see above) shows how to use this functionality. ""ListRemove"" returns a pointer to next node. That's how ""ListRemoveAll"" removes the nodes. ""ListRemoveAll"" is the only function that doesn't return anything. There is no need, since the whole list will be empty after you have called it.