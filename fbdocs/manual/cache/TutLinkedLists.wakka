{{fbdoc item="title" value="Linked Lists"}}----

Une liste cha&icirc;n&eacute;e est une structure qui est facilement extensible en utilisant une seule fonction et qui devient dans tr&egrave;s utile lorsque vous avez besoin d'un tableau de quelque chose, mais dont vous n'avez aucune id&eacute;e de combien. Le concept derri&egrave;re une liste cha&icirc;n&eacute;e est que chaque structure de noeud a un pointeur vers la structure de noeud suivante et pr&eacute;c&eacute;dente. C'est ce qu'on appelle une double liste  cha&icirc;n&eacute;e, car il relie deux noeuds diff&eacute;rents. En utilisant un pointeur sur une structure, vous pouvez sp&eacute;cifier un pointeur nul si il n'y a pas de noeud suivant ou pr&eacute;c&eacute;dent, et puisque le pointeur stocke une adresse m&eacute;moire, le montant des noeuds, vous pouvez stocker est limit&eacute; uniquement par la m&eacute;moire.

Le seul inconv&eacute;nient de l'utilisation d'une liste cha&icirc;n&eacute;e est que dans le but de stocker par exemple un entier, vous devez allouer de l'espace non seulement pour ce nombre entier, mais aussi pour une structure qui contient un pointeur vers l'entier et un pointeur vers les noeuds environnants. Cependant, cela n'a pas beaucoup d'importance sur les ordinateurs modernes, sauf si vous stockez des millions de noeuds.

La structure de base de la liste cha&icirc;n&eacute;e est le noeud. La d&eacute;claration est la suivante:
%%(freebasic)
type listnode
	as any ptr pData
	as listnode ptr pNext
	as listnode ptr pPrev
end type
%%
Une petite remarque, si quelqu'un qui a acc&egrave;s &agrave; ces scripts d&eacute;sire les mettre &agrave; jour car ils contiennent des mots-clefs nouveaux pour FreeBASIC (comme ptr), il est libre de le faire :) Aussi, LIST n'appara&icirc;t pas comme un mot-clef FB keyword (corrigez-moi si je me trompe).

Cette structure contient trois pointeurs. Le premier est un pointeur sur quelque chose (Any Ptr), ce qui signifie que vous pouvez stocker des cha&icirc;nes, des entiers, des caract&egrave;res, m&ecirc;me des types d&eacute;finis par l'utilisateur et des unions. Mais cela signifie aussi que vous devez passer un pointeur. Vous pouvez obtenir un pointeur en utilisant la fonction Allocate (ou CAllocate).
Les deux pointeurs suivants sont des pointeurs vers des //listnode//s, ceci dit, vous &ecirc;tes techniquement autoris&eacute; &agrave; faire cela:
Print node->pNext->pNext->pNext->pNext->pNext...
puisque chaque noeud contient un pointeur vers un autre noeud. Le probl&egrave;me avec la syntaxe ci-dessus est que vous &ecirc;tes limit&eacute; par la quantit&eacute; de noeuds auxquels vous pouvez acc&eacute;der et le code est difficile &agrave; comprendre. Vous pouvez utiliser la fonction de //ListGetNext// &agrave; cet effet et une boucle avec //While//.

Avant d'aller plus loin, voyons toutes les d&eacute;clarations pour l'utilisation de listes cha&icirc;n&eacute;es. Notez que chaque fonction a un pr&eacute;fixe "List".

%%(freebasic)
declare function ListCreate() as listnode ptr
declare function ListAdd(list as listnode ptr, item as any ptr) as any ptr
declare function ListAddHead(list as listnode ptr, item as any ptr) as any ptr
declare function ListGetFirst(list as listnode ptr) as listnode ptr
declare function ListGetLast(list as listnode ptr) as listnode ptr
declare function ListGetNext(list as listnode ptr) as listnode ptr
declare function ListGetPrev(list as listnode ptr) as listnode ptr
declare function ListGetData(list as listnode ptr) as any ptr
declare function ListRemove(list as listnode ptr, bDelete as integer = 0) as listnode ptr
Declare Function ListRemoveAll(list As listnode Ptr, bDelete As Integer = 0)
%%
Hmm, il semble qu'il n'aime pas mon utilisation de "Rem" dans une fonction. Mais il le compile quand m&ecirc;me.

Vous pouvez voir qu'il y a une fonction pour cr&eacute;er une liste cha&icirc;n&eacute;e, ajouter un &eacute;l&eacute;ment, obtenir diff&eacute;rents noeuds, obtenir des donn&eacute;es et supprimer des noeuds. Actuellement, nous allons nous concentrer sur la fonction "ListCreate". Elle n'a aucun param&egrave;tre et renvoie un pointeur "listnode" La structure qu'elle cr&eacute;e ne contient pas de donn&eacute;es. La structure enti&egrave;re est nulle, mais c'est quand m&ecirc;me une structure. Si vous ajoutez un noeud, le membre pNext va changer et pointer vers le nouvel &eacute;l&eacute;ment, de sorte qu'il ne restera pas comme un noeud nul, car cela n'aurait pas de sens. Toutefois, la valeur retourn&eacute;e par "ListCreate" ne stockera pas toutes les donn&eacute;es  et n'aura pas un noeud pr&eacute;c&eacute;dent.

La fonction "ListCreate" ressemble &agrave; ceci:br \>%%(freebasic)
' CREATE
Function ListCreate() As Any Ptr
Dim As listnode Ptr pTemp
	pTemp = CAllocate(Len(listnode))
	' CAllocate automatically zeroes memory.
	Return pTemp

	End Function
%%
Je pr&eacute;f&egrave;re utiliser l'instruction Return pour renvoyer une valeur &agrave; partir d'une fonction, mais FUNCTION = pTemp et ListCreate = pTemp sont aussi permis, bien qu'ils ne fassent pas quitter imm&eacute;diatement la fonction.
Le but de cette fonction est facile &agrave; voir, un noeud est allou&eacute; et retourn&eacute;. Le commentaire dit que la fonction CAllocate remplit automatiquement la m&eacute;moire de  z&eacute;ros. Si vous avez utilis&eacute; la fonction "Allocate", la m&eacute;moire ne serait pas remplie automatiquement de z&eacute;ros et vous auriez &agrave; le faire vous-m&ecirc;me.

Les fonctions suivantes, ListAdd et ListAddHead, ajoutent un noeud &agrave; la liste. ListAdd ajoute un noeud &agrave; la fin de la liste (la queue), tandis que ListAddHead met un noeud tout en haut (la t&ecirc;te).

The next functions, ""ListAdd"" and ""ListAddHead"", add a node to the list. ""ListAdd"" appends a node to the end of the list (the tail), while ""ListAddHead"" puts a node at the very top (the head).

' ADD, ADDHEAD
Function ListAdd(list As listnode Ptr, item As Any Ptr) As Any Ptr

Dim As listnode Ptr pTemp
	If (list = 0) Then Return item

	pTemp = ListGetLast(list)

	pTemp->pNext = CAllocate(Len(listnode))

	pTemp->pNext->pPrev = pTemp
	pTemp->pNext->pData = item
	Return item

	End Function
Function ListAddHead(list As listnode Ptr, item As Any Ptr) As Any Ptr

Dim As listnode Ptr pTemp
	If (list = 0) Then Return item

	pTemp = list->pNext

	list->pNext = CAllocate(Len(listnode))
	list->pNext->pPrev = list

	list->pNext->pData = item
	list->pNext->pNext = pTemp
	If (pTemp <> 0) Then

	pTemp->pPrev = list->pNext
		End If
	Return item

	End Function
%%
Vous pouvez voir que ListeAdd fait r&eacute;f&eacute;rence &agrave; une fonction qui n'est pas encore pr&ecirc;te, ListGetLast. Pour l'instant tout ce que vous devez savoir est qu'elle retourne un pointeur sur le dernier noeud de la liste. Elle sera tra&icirc;t&eacute;e plus tard.
ListeAdd r&eacute;cup&egrave;re le dernier noeud et d&eacute;finit son pointeur "pNext" vers une nouvelle structure "listnode". Cela ne provoquera pas de perte de m&eacute;moire puisque le dernier noeud a un "pNext" de valeur nulle et vient apr&egrave;s. Une fois que notre noeud est ajout&eacute;, nous pouvons y acc&eacute;der en utilisant l'op&eacute;rateur ->. La ligne 

pTemp->pNext->pPrev = pTemp <br>est toute la base de listes cha&icirc;n&eacute;es, la pi&egrave;ce de liaison. Ce qui est dit c'est que nous avons une r&eacute;f&eacute;rence &agrave; un noeud. Ce noeud sait o&ugrave; se trouve le noeud suivant, et maintenant nous pouvons dire que le noeud apr&egrave;s ce suivant est l&agrave; o&ugrave; le pr&eacute;c&eacute;dent est. Cela peut sembler un peu redondant au premier abord, mais le compilateur ne sait pas o&ugrave; sont les noeuds jusqu'&agrave; ce que vous les d&eacute;finissiez. Une fois que vous avez fait cela, vous pouvez parcourir la liste cha&icirc;n&eacute;e.
La fonction "ListAddHead" est un peu plus compliqu&eacute;e, puisque nous ins&eacute;rons sommes un noeud entre le premier noeud actuel et le noeud nul de "ListCreate". Ce qu'il fait essentiellement est d'allouer de l'espace pour contenir le noeud courant d'abord, cr&eacute;er un nouveau noeud l&agrave; et les lier tous ensemble. Si vous regardez d'un peu plus pr&egrave;s, cela devrait vous sembler beaucoup plus clair. L'instruction "If" &agrave; la fin est tout simplement l&agrave; pour &eacute;viter un acc&egrave;s &agrave; de la m&eacute;moire qui n'existe pas (NULL->pPrev). Si pTemp n'est pas dans les fait &eacute;gal &agrave; z&eacute;ro, alors le membre pPrev sera assign&eacute;. Sinon, il n'y a aucune raison de s'inqui&eacute;ter &agrave; ce sujet.
Les fonctions suivantes sont ListGetFirst et ListGetLast. Je les ai mises en oeuvre car "ListGetLast" a &eacute;t&eacute; r&eacute;f&eacute;renc&eacute;e dans une fonction pr&eacute;c&eacute;demment.

The ""ListAddHead"" function is a little more complicated, since we're actually inserting a node between the current first node and the null node from ""ListCreate"". What it does basically is allocates space to hold the current first node, creates a new node there, and links them all together. If you study it a little, it should seem a lot clearer. The If statement at the end just makes sure that we're not trying to access memory that doesn't exist (NULL->pPrev). If pTemp does not in fact equal zero, then its pPrev member will be assigned. Otherwise, there is no reason to worry about it.

' GETFIRST, GETLAST

Function ListGetFirst(list As listnode Ptr) As Any Ptr
If (list = 0) Then Return 0

Return list->pNext
	End Function

	Function ListGetLast(list As listnode Ptr) As Any Ptr
Dim As listnode Ptr pTemp

If (list = 0) Then Return 0
	pTemp = list

	While (pTemp->pNext <> 0)

	pTemp = pTemp->pNext
	Wend
		Return pTemp
	End Function

	%%
La premi&egrave;re fonction est probablement la fonction la plus courte et la plus facile &agrave; comprendre, m&ecirc;me si elle repose sur le fait que vous d&eacute;tenez un pointeur vers le noeud retourn&eacute; par "ListCreate". Si vous ne le faites pas, elle pourrait retourner n'importe quel noeud al&eacute;atoire. Tout ce qu'elle fait est de retourner un pointeur vers le premier noeud ou le noeud qui vient juste apr&egrave;s le noeud nul.
La seconde fonction, "ListGetLast", boucle &agrave; travers la liste jusqu'&agrave; ce qu'elle trouve un noeud nul. La raison pour laquelle je v&eacute;rifie si "pTemp->pNext = 0" au lieu de "pTemp = 0", c'est que je ne veux pas qu'elle retourne z&eacute;ro. Je veux retourner le dernier noeud, qui est le noeud qui a sa valeur pNext mise &agrave; z&eacute;ro. Une fois que le noeud est trouv&eacute;, ListGetLast le renvoie .

Les trois prochaines fonctions sont simplement des fonctions d'aide et pourraient &ecirc;tre facilement r&eacute;alis&eacute;es avec une ligne de code. Elles existent r&eacute;ellement, car l'impl&eacute;mentation initiale qui n'a pas &eacute;t&eacute; &eacute;crite par moi, avait une fonction "ListGetNext".

The second function, ""ListGetLast"", loops through the list until it finds a null node. The reason I check if pTemp->pNext = 0 instead of pTemp = 0 is that I don't want to return zero. I want to return the last node, which is the node that has its pNext value set to zero. Once that node is found, ""ListGetLast"" returns it.

' GETNEXT, GETPREV

Function ListGetNext(list As listnode Ptr) As Any Ptr
If (list = 0) Then Return 0

Return list->pNext
	End Function

	Function ListGetPrev(list As listnode Ptr) As Any Ptr
' can't do anything to a null list

If (list = 0) Then Return 0
	' this is needed for below
	If (list->pPrev = 0) Then Return 0
	' since the list starts with a null node (pPrev and pData = 0),
	' the first should be the one right after the real first.
	If (list->pPrev->pPrev = 0) Then Return 0
	Return list->pPrev
	End Function

	' GETDATA
Function ListGetData(list As listnode Ptr) As Any Ptr

If (list = 0) Then Return 0

Return list->pData
	End Function

	%%
La premi&egrave;re fonction, ListGetNext, est exactement la m&ecirc;me que "ListGetFirst", mais elle se diff&eacute;rencie par le point de vue. Bien que vous puissiez utiliser ListGetFirst sur &ocirc;€‹&ocirc;€‹une valeur noeud dans cette impl&eacute;mentation, ce n'est pas une bonne id&eacute;e parce que certains d'autres impl&eacute;mentations peuvent boucler sur le d&eacute;but de la liste afin de trouver le premier noeud, auquel cas vous seriez coinc&eacute; dans une boucle infinie.
La fonction "ListGetPrev" est un peu plus complexe, car je ne veux pas retourner de noeud nul. La premi&egrave;re ligne de code et la troisi&egrave;me (et non les commentaires) sont celles qui sont r&eacute;ellement n&eacute;cessaires, mais la seconde assure que nous n'acc&eacute;dons pas &agrave; de la m&eacute;moire nulle. La troisi&egrave;me ligne dit que si le noeud, deux noeuds au-dessus, est nul, nous devrions retourner z&eacute;ro. Cela signifie que si vous &ecirc;tes au niveau du noeud le plus haut (pas le noeud nul), il n'y a pas de noeud pr&eacute;c&eacute;dent avec lequel vous pourriez faire n'importe quoi, bien qu'il y existe un noeud pr&eacute;c&eacute;dent et on devrait retourner z&eacute;ro. La derni&egrave;re ligne traite le cas par d&eacute;faut, o&ugrave; il existe en fait un noeud pr&eacute;c&eacute;dent qui doit donc &ecirc;tre retourn&eacute;.

La fonction "ListGetData" est aussi simple et br&egrave;ve comme les fonctions "ListGetFirst" et "ListGetNext". Elle renvoie simplement un pointeur sur les donn&eacute;es du noeud.

Les deux derni&egrave;res fonctions suppriment des noeuds de la liste.

The ""ListGetData"" function is as easy and brief as the ""ListGetFirst"" and ""ListGetNext"" functions. It just returns a pointer to the node's data.

' REMOVE, REMOVEALL
Function ListRemove(list As listnode Ptr, bDelete As Integer = 0) As Any Ptr
Dim As listnode Ptr pPrev

Dim As listnode Ptr pNext
	If (list = 0) Then Return 0
	pPrev = list->pPrev

	pNext = list->pNext

	If ((list->pData <> 0) And (bDelete <> 0)) Then Deallocate list->pData
	Deallocate list

	If (pPrev <> 0) Then

	pPrev->pNext = pNext

	End If
		If (pNext <> 0) Then
	pNext->pPrev = pPrev
	End If
		Return pNext
	End Function

	Function ListRemoveAll(list As listnode Ptr, bDelete As Integer = 0)
Dim As listnode Ptr node

node = list
	If (list = 0) Then Return 0

	While (node <> 0)
	If ((node->pData <> 0) And (bDelete <> 0)) Then Deallocate node->pData

	node = ListRemove(node)
		Wend
		Return
	End Function
%%
La fonction "ListRemove" a deux utilit&eacute;s: supprimer le noeud sp&eacute;cifi&eacute; et relier ensemble les deux noeuds environnants. Vous pouvez voir que pour ce faire elle stocke le pointeur pr&eacute;c&eacute;dent et le suivant. Le param&egrave;tre optionnel, "bdelete", sp&eacute;cifie si l'&eacute;l&eacute;ment de donn&eacute;es devrait &ecirc;tre supprim&eacute;. Si vous stockez seulement des entiers, ou m&ecirc;me des structures sans pointeurs &agrave; l'int&eacute;rieur, vous pouvez passer 1 &agrave; ce param&egrave;tre et l'&eacute;l&eacute;ment sera supprim&eacute; pour vous. Mais si vous avez une structure contenant des pointeurs, la meilleure id&eacute;e est de supprimer toutes les donn&eacute;es vous-m&ecirc;me et laisser "ListRemove" g&eacute;rer seulement la partie liste pour s'assurer qu'il n'y a pas de perte de m&eacute;moire. Le pointeur "listnode" est d&eacute;sallou&eacute; ind&eacute;pendamment quel que soit la valeur du param&egrave;tre.

"ListRemoveAll" s'appuie sur la fonction "ListRemove" pour supprimer les noeuds. Elle boucle simplement &agrave; travers la liste en utilisant une "boucle while" et supprime tous les noeuds. Le code original utilisait une "boucle For", mais FB ne semble pas faire comme mon

For node = list To 0 Step ListRemove(node)
donc il a &eacute;t&eacute; chang&eacute;
&Ccedil;a y est, voici le fichier complet qui inclut un exemple dans le haut de fa&ccedil;on &agrave; les utiliser. Ceci est la premi&egrave;re fois que j'&eacute;cris un tutoriel, alors n'h&eacute;sitez pas &agrave; laisser des commentaires sur les points que je pourrais am&eacute;liorer. Aussi, si vous trouvez un bug dans mon code (j'ai trouv&eacute; un certain nombre pendant la r&eacute;daction de ce tuto), s'il vous pla&icirc;t faites le moi savoir. N'h&eacute;sitez pas &agrave; modifier le bug, mais je voudrais &ecirc;tre tenu au courant.

That's it, here's the whole file that includes a sample at the top of how to use them. This is my first time writing a tutorial, so feel free to leave comments on ways I could improve. Also, if you catch a bug in my code (I found a couple while writing this), please let me know. Feel free to edit the bug out also, but I'd like to know about it too.

Type listnode
As Any Ptr pData
	As listnode Ptr pNext
	As listnode Ptr pPrev
	End Type
Declare Function ListCreate() As listnode Ptr

Declare Function ListAdd(list As listnode Ptr, item As Any Ptr) As Any Ptr
Declare Function ListAddHead(list As listnode Ptr, item As Any Ptr) As Any Ptr
Declare Function ListGetFirst(list As listnode Ptr) As listnode Ptr
Declare Function ListGetLast(list As listnode Ptr) As listnode Ptr
Declare Function ListGetNext(list As listnode Ptr) As listnode Ptr
Declare Function ListGetPrev(list As listnode Ptr) As listnode Ptr
Declare Function ListGetData(list As listnode Ptr) As Any Ptr
Declare Function ListRemove(list As listnode Ptr, bDelete As Integer = 0) As listnode Ptr
Declare Function ListRemoveAll(list As listnode Ptr, bDelete As Integer = 0)
Dim As listnode Ptr list, node

Dim As Integer Ptr item
list = ListCreate()
item = ListAdd(list, CAllocate(Len(Integer)))
*item = 4
item = ListAdd(list, CAllocate(Len(Integer)))
*item = 44
item = 0 ' just to show it works
node = ListGetFirst(list)
While node <> 0

Print "found item"
	item = ListGetData(node)
	Print *item
	node = ListRemove(node,1)
	Wend
While Inkey$ = "" : Wend

' CREATE

Function ListCreate() As Any Ptr
Dim As listnode Ptr pTemp
	pTemp = CAllocate(Len(listnode))
	' CAllocate automatically zeroes memory.
	Return pTemp

	End Function
' ADD, ADDHEAD

Function ListAdd(list As listnode Ptr, item As Any Ptr) As Any Ptr

Dim As listnode Ptr pTemp
	If (list = 0) Then Return item

	pTemp = ListGetLast(list)

	pTemp->pNext = CAllocate(Len(listnode))

	pTemp->pNext->pPrev = pTemp
	pTemp->pNext->pData = item
	Return item

	End Function
Function ListAddHead(list As listnode Ptr, item As Any Ptr) As Any Ptr

Dim As listnode Ptr pTemp
	If (list = 0) Then Return item

	pTemp = list->pNext

	list->pNext = CAllocate(Len(listnode))
	list->pNext->pPrev = list

	list->pNext->pData = item
	list->pNext->pNext = pTemp
	If (pTemp <> 0) Then

	pTemp->pPrev = list->pNext
	    End If
	Return item

	End Function
' GETFIRST, GETLAST

Function ListGetFirst(list As listnode Ptr) As Any Ptr

If (list = 0) Then Return 0
	Return list->pNext

	End Function
Function ListGetLast(list As listnode Ptr) As Any Ptr

Dim As listnode Ptr pTemp
	If (list = 0) Then Return 0

	pTemp = list

	While (pTemp->pNext <> 0)
	pTemp = pTemp->pNext
	    Wend
	Return pTemp

	End Function
' GETNEXT, GETPREV

Function ListGetNext(list As listnode Ptr) As Any Ptr

If (list = 0) Then Return 0
	Return list->pNext

	End Function
Function ListGetPrev(list As listnode Ptr) As Any Ptr

' can't do anything to a null list
	If (list = 0) Then Return 0
	' this is needed for below
	If (list->pPrev = 0) Then Return 0
	' since the list starts with a null node (pPrev and pData = 0),
	' the first should be the one right after the real first.
	If (list->pPrev->pPrev = 0) Then Return 0
	Return list->pPrev

	End Function
' GETDATA

Function ListGetData(list As listnode Ptr) As Any Ptr

If (list = 0) Then Return 0
	Return list->pData

	End Function
' REMOVE, REMOVEALL

Function ListRemove(list As listnode Ptr, bDelete As Integer = 0) As Any Ptr

Dim As listnode Ptr pPrev
	Dim As listnode Ptr pNext
	If (list = 0) Then Return 0

	pPrev = list->pPrev

	pNext = list->pNext
	If ((list->pData <> 0) And (bDelete <> 0)) Then Deallocate list->pData

	Deallocate list

	If (pPrev <> 0) Then

	pPrev->pNext = pNext
	    End If
	If (pNext <> 0) Then
	pNext->pPrev = pPrev
	    End If
	Return pNext

	End Function
Function ListRemoveAll(list As listnode Ptr, bDelete As Integer = 0)

Dim As listnode Ptr node
	node = list

	If (list = 0) Then Return 0
	While (node <> 0)

	If ((node->pData <> 0) And (bDelete <> 0)) Then Deallocate node->pData
	    node = ListRemove(node)
	    Wend
	Return
End Function
%%

Si vous ne l'avez pas d&eacute;j&agrave; remarqu&eacute;, "ListeAdd" et "ListAddHead" renvoient un pointeur sur les donn&eacute;es que vous entrez. L'exemple de code (voir ci-dessus) montre comment utiliser cette fonctionnalit&eacute;. "ListRemove" renvoie un pointeur vers le noeud suivant. Voil&agrave; comment "ListRemoveAll" supprime les noeuds. "ListRemoveAll" est la seule fonction qui ne renvoie rien. Ce n'est pas n&eacute;cessaire, puisque toute la liste sera vide apr&egrave;s l'avoir appel&eacute;e.