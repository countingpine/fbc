{{fbdoc item="title" value="Beginners Guide to Types as Objects (Part 2)"}}----

**Introduction.**
----

Bienvenue dans la deuxième partie du tutoriel. Dans cette partie je suppose que vous avez lu la Partie 1, essayé les exemples et expérimenté avec des tests de votre choix.  Je vais maintenant couvrir certains sujets que je n'ai pas inclus dans la Partie 1.

**Property indexée.**
----

Une ##**Property**## indexée est une ##**Property**## qui se comporte comme un tableau, sauf que comme dans le cas d'une ##**Property**## ordinaire, une fonction est appelée lorsque vous y accédez.  Je vais commencer par un exemple très court juste pour vous montrer la syntaxe.

%%(freebasic)
Type foo
  Declare Property bar(ByVal index As Integer, ByVal value As Integer)
  Declare Property bar(ByVal index As Integer) As Integer
  dummy As Integer
End Type 

Property foo.bar(ByVal index As Integer, ByVal value As Integer)
  Print "Property set, index=" & index & ", value=" & value 
End Property

Property foo.bar(ByVal index As Integer) As Integer
  Print "Property get, index=" & index
  Property = 0
End Property

Dim baz As foo

baz.bar(0) = 42
Print baz.bar(0)
%%

Comme vous pouvez le voir la déclaration de notre ##**Property**## indexée est très similaire à une ##**Property**## ordinaire, sauf que cette fois on ajoute un argument pour l'indice.  J'inclus un membre entier factice parce qu'un type doit avoir au moins un membre de données.  Comme vous pouvez le voir la ##**Property**## est alors utilisé avec (0), pour indiquer que nous voulons obtenir/définir l'indice "zéroième", exactement comme on le ferait pour un tableau ordinaire.  Maintenant, je vais vous montrer un exemple un peu plus utile et je vais le décrire:

%%(freebasic)
Type foo
  Declare Constructor(ByVal num_elements As Integer)
  Declare Destructor()
  Declare Property bar(ByVal index As Integer, ByVal value As Integer)
  Declare Property bar(ByVal index As Integer) As Integer
private:
  x As Integer ptr
  size As Integer
End Type 

Constructor foo(ByVal num_elements As Integer)
  x = CAllocate(num_elements * sizeof(Integer))
  size = num_elements
End Constructor

Destructor foo()
  DeAllocate(x)
End Destructor

Property foo.bar(ByVal index As Integer, ByVal value As Integer)
  If (index >= 0) AND (index < size) Then
	x[index] = value
  Else
	Error 6
  End If
End Property

Property foo.bar(ByVal index As Integer) As Integer
  If (index >= 0) AND (index < size) Then
	Property = x[index]
  Else
	Error 6
  End If
End Property

Dim baz As foo = foo(10)

baz.bar(1) = 42
Print baz.bar(1)
%%

Cette fois j'ai ajouté un ##**Constructor**## et un ##**Destructor**##, qui allouer et désallouer un tableau dynamique dans la mémoire, ##**x**##, avec le nombre d'éléments spécifiés dans le ##**Constructor**##.  Puis, quand les fonctions de ##**Property**## sont invoquées, Je vérifie si l'indice est dans les limites du tableau, s'il l'est alors j'effectue la demande obtenir/définir.  Si l'index spécifié est hors limites, alors ##**'Error 6'**## se produit, qui est un moyen d'interrompre le programme avec ##**'out of bounds error'**## de FB, vous pouvez remplacer ceci par votre propre routine de traitement des erreurs.  Essayez ceci en modifiant le code ##**'baz.bar(1) = 42'**## par ##**'baz.bar(10) = 42'**##, et vous verrez ceci en action, car nous n'avons précisé que 10 éléments (indice 0-9)

**"Constructor" de copie.**
----

Un ##**Constructor**## de copie est un type spécial de ##**Constructor**##, qui est utilisé pour faire une copie d'un objet existant.  Lorsque vous écrivez du code comme celui-ci:

%%(freebasic)
Type foo
...
End Type

Dim As foo a
Dim As foo b = a
%%

Ce qui se passe c'est que FreeBASIC génère automatiquement du code caché pour construire **b**, en faisant une copie de **a**, c'est le ##**Constructor**## de copie par défaut, et il recopie simplement les champs de données (membres).  Nous pouvons définir notre propre ##**Constructor**## de copie; voici juste un bref extrait pour montrer comment on le déclare.

%%(freebasic)
Type foo
  Declare Constructor(ByRef obj As foo)
  ...
End Type
%%

Ce sera très utile pour une raison que je vais maintenant vous expliquer.

**Copie profonde/superficielle.**
----

Dans l'exemple précédent où nous avions le code ##**'Dim As foo b = a'**##, c'est ce qu'on appelle une copie superficielle, une simple recopie des champs de données a été effectuée, mais parfois ce n'est pas souhaitable, imaginez que l'un des membres soit un pointeur, ce qui va arriver, c'est que l'adresse vers laquelle pointe le pointeur sera recopiée, ainsi les deux objets pointeront vers la même zone mémoire.  L'exemple suivant illustre cela:

%%(freebasic)
Type foo
  x As Integer ptr
End Type

Dim As foo a

a.x = Allocate(sizeof(Integer))
*a.x = 42

Dim As foo b = a

Print *a.x, *b.x

*a.x = 420

Print *a.x, *b.x

DeAllocate(a.x)
%%

Comme vous le voyez,  parce qu'ils pointent tous deux vers la même mémoire, changer l'un affecte l'autre.  Comme expliqué dans la section précédente sur le ##**Constructor**## de copie, FreeBASIC crée le code pour faire des copies superficielles par défaut. Cela est également vrai si nous faisons une affectation comme:

%%(freebasic)
Dim As foo a, b

b = a
%%

Dans ce cas également FreeBASIC crée un opérateur d'affectation par défaut (Let) pour effectuer une copie superficielle.  Afin de faire des copies complètes nous avons besoin de définir un ##**Constructor**## de copie et un opérateur d'assignation qui est surchargé pour accepter notre ##**Type**##.  Voici un exemple qui les utilise.

%%(freebasic)
Type foo
  Declare Constructor()
  Declare Constructor(ByRef obj As foo)
  Declare Destructor()
  Declare Operator Let(ByRef obj As foo)
  x As Integer ptr
End Type

Constructor foo()
  Print "Default ctor"
  x = CAllocate(sizeof(Integer))
End Constructor

Constructor foo(ByRef obj As foo)
  Print "Copy ctor"
  x = CAllocate(sizeof(Integer))
  *x = *obj.x
End Constructor

Destructor foo()
  Print "dtor"
  DeAllocate(x)
End Destructor

Operator foo.Let(ByRef obj As foo)
  Print "Let"
  *x = *obj.x
End Operator

Dim As foo a

*a.x = 42

Dim As foo b = a 'Uses the copy constructor

Print *a.x, *b.x

*a.x = 420

Print *a.x, *b.x
%%

Comme vous pouvez le voir le ##**Constructor**## de copie est appelé sur la ligne '##**Dim As foo b = a**##' et cette fois, nous avons alloué de la mémoire, et copié les données dans le nouveau ##**Constructor**## de copie, de sorte que nous pouvons ajuster **x** dans un objet sans que cela affecte les autres.  Si nous modifions le code principal comme suit:

%%(freebasic)
Dim As foo a, b

*a.x = 42
b = a    'The assignment operator (Let) gets used this time.

Print *a.x, *b.x

*a.x = 420

Print *a.x, *b.x
%%

Alors, à ce moment-là, l'opérateur d'affectation est utilisé. Notez que dans le code de l'opérateur d'affectation nous n'avons pas besoin d'allouer de la mémoire car elle a déjà été allouée dans le ##**Constructor**## par défaut, il suffit de copier les données dedans.  La ligne '##***x = *obj.x**##' effectue cette copie.  Si nous avions quelque chose de plus avancé comme un tableau dynamique en mémoire, nous aurions besoin de réallouer de la mémoire, pour avoir la bonne taille en fonction des données qui sont copiées.  Voici une version plus avancée juste pour montrer cela.

%%(freebasic)
Type foo
  Declare Constructor(ByVal num_elements As Integer)
  Declare Constructor(ByRef obj As foo)
  Declare Destructor()
  Declare Operator Let(ByRef obj As foo)
  x As Integer ptr
  size As Integer
End Type

Constructor foo(ByVal num_elements As Integer)
  Print "Default ctor"
  x = CAllocate(sizeof(Integer) * num_elements)
  size = num_elements
End Constructor

Constructor foo(ByRef obj As foo)
  Print "Copy ctor"
  x = CAllocate(sizeof(Integer) * obj.size)
  size = obj.size
  For i As Integer = 0 To size - 1
	x[i] = obj.x[i]
  Next i
End Constructor

Destructor foo()
  Print "dtor"
  DeAllocate(x)
End Destructor

Operator foo.Let(ByRef obj As foo)
  Print "Let"
  x = ReAllocate(x, sizeof(Integer) * obj.size)
  size = obj.size
  For i As Integer = 0 To size - 1
	x[i] = obj.x[i]
  Next i
End Operator

Dim As foo a = foo(5)

a.x[0] = 42
a.x[1] = 420

Dim As foo b = a 'Uses the copy constructor

Print a.x[0], a.x[1], b.x[0], b.x[1]

b.x[0] = 10
b.x[1] = 20

Print a.x[0], a.x[1], b.x[0], b.x[1]

b = a ' Now using the assignment operator

Print a.x[0], a.x[1], b.x[0], b.x[1]
%%

Cela peut paraître assez complexe au premier abord, mais cela vaut la peine d'une relecture, et d'expérimenter avec les exemples, ce n'est pas trop compliqué une fois qu'on a l'habitude de l'utiliser.

**Passage d'objets aux fonctions par valeur (ByVal)**
----

L'idée de copies profondes et peu profondes s'applique également au passage par valeur d'un objet à une fonction.  Lorsque vous transmettez une référence à un objet (ByRef), vous pouvez modifier l'objet, et ces modifications persisteront, mais vous pouvez également le passer par la valeur, ce qui signifie que vous pouvez le modifier sans que les changements persistent en dehors de la fonction.  Quand un objet est passé par valeur à une fonction, une nouvelle copie est créée et si cet objet a un ##**Constructor**## de copie, alors celui-ci est invoqué, s'il n'en a pas, alors une copie cachée superficielle est effectuée.  Une fois que la fonction se termine, le ##**Destructor**## des objets est appelé.

**New/Delete**
----

##**New**## et ##**Delete**## sont des opérateurs spéciaux d'allocation dynamique de mémoire, puis ils la détruisent.  Parce qu'ils sont utilisés avec de la mémoire dynamique, ils sont utilisés avec des pointeurs.  Dans tous les exemples jusqu'à présent, nous avons juste utilisé ##**Dim**## pour créer nos objets, cela va les créer sur la pile, mais en utilisant ##**New**## nous pouvons les créer dynamiquement, ce qui peut permettre plus de flexibilité, tout comme l'utilisation de ##**Allocate/DeAllocate**## avec la mémoire normale.  Une autre chose importante à propos de ##**New**##, est que vous n'avez pas besoin de vérifier si le pointeur est NULL après ##**New**##, comme vous le feriez si vous aviez utilisé ##**Allocate**##.  Si ##**New**## échoue, il provoque une exception, ce qui terminera le programme.  Dans les versions ultérieures de FreeBASIC, il est probable qu'un certain type de mécanisme ##**try..catch**## sera créé afin de permettre une meilleure gestion des exceptions, mais au moment où j'écris, ce n'est pas encore mis en oeuvre.  

Il existe deux variantes différentes de ##**New**##/##**Delete**##.  Le premier type, crée seulement un seul élément ou objet, par exemple:

%%(freebasic)
Dim As Integer ptr foo = new Integer

*foo = 1
Print *foo

Delete foo
%%

Cela va créer un ##**New Integer**##, puis le détruire quand nous appelons ##**Delete**##.  Souvenez-vous j'ai utilisé ##**Ptr**##, parce que c'est de la mémoire dynamique.  Pour les types de données simples vous pouvez également spécifier une valeur par défaut, en la plaçant entre parenthèses après le type de données, à savoir:

%%(freebasic)
Dim As Integer ptr foo = new Integer(42)

Print *foo

Delete foo
%%

Cela fonctionne également pour les types de données utilisateur avec seulement de simples champs de données:

%%(freebasic)
Type foo
  x As Integer
  y As Integer
End Type

Dim As foo ptr bar = new foo(1, 2)
  
Print bar->x, bar->y

Delete bar
%%

Cette initialisation ne fonctionne pas pour les types plus complexes impliquant des ##**Constructor**##s/##**Destructor**##s etc, cependant il y a une fonctionnalité utile, c'est que lors de l'utilisation ##**New**##/##**Delete**## avec des objets, il appelle également ##**Constructor**## et ##**Destructor**##, essayez l'exemple suivant:

%%(freebasic)
Type foo
  Declare Constructor()
  Declare Destructor()
  x As Integer
  y As Integer
End Type

Constructor foo()
  Print "ctor"
End Constructor

Destructor foo()
  Print "dtor"
End Destructor

Dim As foo ptr bar = new foo

Delete bar
%%

Vous verrez que le ##**Constructor**## et le ##**Destructor**## de l'objet sont appelés.

Le deuxième type de ##**New**##/##**Delete**## est pour la création de tableaux, cette fois le nombre d'éléments est placé entre crochets '[]', après le type de donnée.  Lorsque vous utilisez la version tableau, vous devez également utiliser '##**delete[]**##' au lieu de '##**delete**##', de sorte que FreeBASIC sait que vous supprimez un tableau, voici un exemple simple utilisant le type ##**Integer**##:

%%(freebasic)
Dim As Integer ptr foo = new Integer[20]

foo[1] = 1
Print foo[1]

Delete[] foo
%%

Cela va créer un tableau dynamique, avec 20 éléments entiers.  Il convient de noter que ceci est différent de ##**Allocate**##, qui nécessite le nombre d'octets comme argument; en utilisant ##**New**##, vous devez spécifier le nombre d'éléments.  La méthode tableau fonctionne de la même façon pour les objets:

%%(freebasic)
Type foo
  Declare Constructor()
  Declare Destructor()
  x As Integer
  y As Integer
End Type

Constructor foo()
  Print "ctor"
End Constructor

Destructor foo()
  Print "dtor"
End Destructor

Dim As foo ptr bar = new foo[3]

Delete[] bar
%%

Lorsque vous exécuterez ce code, vous verrez que trois paires de ##**Constructor**##/##**Destructor**## sont appelés, parce que nous avons créé une gamme de trois instances de "foo".

Vous devez vous souvenir d'appeler ##**Delete**## ou ##**Delete[]**## pour toute mémoire allouée avec ##**New**##, ou vous provoquerez une perte de mémoire, tout comme vous devez vous souvenir d'appeler ##**DeAllocate**## pour toute mémoire que vous allouez avec la fonction ##**Allocate**##.

**Name Mangling**
----

##**Name mangling**##, aussi appelé ##**name decoration**##, est quelque chose qui se passe en coulisses, à un niveau inférieur, et en tant que tel n'est pas essentiel à connaître.  La raison du ##**Name mangling**## est de résoudre les problèmes provoqués par le fait que plusieurs fonctions ont le même nom, ce qui arrive lorsque des fonctions sont surchargées ou font partie d'un type.  Prenez par exemple les ##**sub**##s surchargées ci-dessous:

%%(freebasic)
Sub foo overload ()

End Sub

Sub foo(ByVal i As Integer)

End Sub
%%

Si nous n'avions pas le ##**name mangling**##, alors les deux pourraient être connues à un niveau inférieur sous le nom de FOO, ce qui provoquerait un conflit de nom, elles doivent donc être "décorées" pour savoir laquelle doit être appelée quand ils sont utilisées.  Pour la première ##**sub**##, le compilateur crée en fait une ##**sub**## appelée _Z3FOOv et pour la seconde, il crée une ##**sub**## appelée _Z3FOOi.  Le compilateur se souvient alors de cela et choisit la ##**sub**## appropriée à appeler, selon la façon dont vous l'appelez, par exemple 'foo()' appellera effectivement _Z3FOOv, et 'foo(1)' appellera _Z3FOOi.  Nous pouvons deviner quelque chose, que 'v' est utilisé pour "void" (pas d'argument), et 'i' pour "integer".  Les détails complets de ##**name mangling**## sont assez complexes et varient entre les compilateurs, les compilateurs Microsoft utilisent un schéma de ##**name mangling**## différent de celui des compilateurs GNU et d'autres compilateurs peuvent utiliser des systèmes différents, eux aussi.  La principale chose que nous devons savoir, La principale chose que nous devons savoir, c'est que FreeBASIC suit GCC 3.x ABI (Application binary interface), ce qui signifie que toutes les fonctions surchargées, ou des types complexes ne seront compatibles qu'avec d'autres compilateurs utilisant le même schéma.  Il s'agit d'une limitation malheureuse, mais ce n'est pas vraiment un problème FreeBASIC, il est commun à tous les compilateurs qui utilisent des fonctionnalités avancées, et même si tous les auteurs compilateur étaient sur un schéma commun de ##**name mangling**##, il y aurait d'autres questions qui seraient cause d'incompatibilité.

**"this" implicite**
----

De nouveau, il n'est pas impératif de tout connaître sur ce sujet, c'est quelque chose qui se passe en coulisses à un niveau inférieur.  Lorsque vous appelez une fonction membre d'un objet, ce qui se passe c'est qu'un paramètre caché est passé, de sorte que la fonction sait quelle instance de l'objet est visée.  Cela est également vrai pour les membres ##**property/constructor/destructor/operator**##.  Si nous regardons un exemple très simple:

%%(freebasic)
Type foo
  Declare Sub bar(ByVal n As Integer)
  x As Integer
End Type

Sub foo.bar(ByVal n As Integer)
  x = n
End Sub

Dim baz As foo
baz.bar(5)
%%

Ce qui se passe réellement dans les coulisses est quelque chose d'essentiellement équivalent à cela:

%%(freebasic)
Type foo
  x As Integer
End Type

Sub foo_bar(ByRef _this As foo, ByVal n As Integer)
  _this.x = n
End Sub

Dim baz As foo
foo_bar(baz, 5)
%%

Cette méthode utilisant un '##**this**##' explicite est souvent utilisée dans des langues qui ne disposent pas de moyens pour rendre cela plus facile.  OOP (Programmation Orientée Objet) est tout simplement un ensemble de concepts, qui peuvent être codés dans la plupart des langages, certaines choses sont plus difficiles à mettre en uvre, comme les constructeurs, vous auriez à  appeler explicitement une fonction 'create' ou 'init'.  Pour certaines choses telles que la distinction public / privé, c'est encore plus difficile, voire impossible, parce que le compilateur ne sait pas les faire respecter.  La raison de l'ajout de fonctionnalités à un langage orienté objet est de cacher beaucoup de cela, et d'ajouter le sucre syntaxique pour rendre cela plus simple à faire, ou plus transparent dans l'utilisation, comme la façon dont nous pouvons utiliser les propriétés comme si elles étaient membres ordinaires de données, plutôt que des fonctions, qui est ce qu'elles sont vraiment.

**Conseils pour le débogage/profilage**
----

Lorsque vous utilisez ##**GDB**## ou autres débogueurs, et l'outil de profilage ##**gprof**##, l'information est présentée dans la syntaxe ""C++"" et tous vos noms de variables et autres symboles sont affichés en majuscules, voici juste un très bref tour d'horizon pour vous aider à comprendre comment ils sont affichés:

Here's an example type:

%%(freebasic)
Type bar
  Declare Constructor()
  Declare Constructor(ByRef obj As bar)
  Declare Constructor(ByVal n As Integer)
  Declare Destructor()
  Declare Operator Cast() As Any ptr
  Declare Operator Let(ByVal n As Integer)
  Declare Property foo(ByVal n As Integer)
  Declare Property foo() As Integer
  member As Any Ptr
End Type
%%

Si vous utilisez ##**GDB**##, ils seront affichés comme suit (notez qu'en ""C++"" on utilise :: où on devrait utiliser . (dot), '::' est connu comme l'opérateur de résolution de portée):

  BAR::BAR()            - Le constructeur par défaut
  BAR::BAR(BAR&)        - Le constructeur de copie (& en ""C++"" signifie une référence, comme byref)
  BAR::BAR(int)         - Le constructeur prenant un argument entier (notez qu'il n'y a aucun symbole spécial pour désigner ByVal, car c'est la valeur de passage par défaut dans les méthodes C/""C++"")
  BAR::~BAR()           - Le destructeur
  BAR::operator void*() - Un "cast" vers "Any ptr" (void est similaire à Any, * signifie pointeur)
  BAR::operator=(int)   - L'opérateur d'affectation (Let), désigné par '=', en C/""C++"" '=' est une affectation, '""==""' teste l'égalité.
  BAR::FOO(int)         - Validateur de Property foo, prenant un argument entier
  BAR::FOO()            - Récupérateur de Property foo

Les sub/functions membres sont présentés de la même manière que les propriétés, les propriétés indexées sont indiquées aussi de même, juste avec un argument supplémentaire pour l'indice.

Voici comment les types de données FB seront affichés:

Any ptr     - void *
ZString ptr - char *
String      - FBSTRING
byte        - signed char
ubyte       - bool
short       - short
ushort      - unsigned short
integer     - int
uinteger    - unsigned int
longint     - long long
ulongint    - unsigned long long

J'espère que ceci vous aura aidé à comprendre comment les choses sont affichées dans GDB / gprof, un peu d'expérimentation facilitera les choses.

**Autres lectures**
----

http://www.freebasic.net/wiki/wikka.php?wakka=KeyPgOpNew
http://www.freebasic.net/wiki/wikka.php?wakka=KeyPgOpDelete
http://en.wikipedia.org/wiki/Copy_constructor
http://en.wikipedia.org/wiki/Object_copy
http://en.wikipedia.org/wiki/Name_mangling