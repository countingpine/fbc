{{fbdoc item="title" value="Comment programmer un jeu: Le&ccedil;on 1"}}

{{fbdoc item="section" value="Introduction par Lachie Dazdarian"}}
L'objectif de cette série de leçons est d'aider les débutants qui connaissent un peu le BASIC, à apprendre les bases de la programmation en FreeBASIC nécessaires pour créer un jeu sur ordinateur. Quelues connaissances de base du BASIC seront très utiles pour faciliter les choses, cependant je crois que ceux qui ne connaissent pas le BASIC à fond peuvent quand même comprendre ces leçons. J'utilise ici le mot (enfin, c'est un acronyme) "BASIC" et non pas FreeBASIC, parce que si vous connaissez les bases de QuickBASIC, Visual Basic ou toute autre variante de Basic, ces leçons doivent être faciles à comprendre.

Je commence cette série parce que je pense que des tutoriels de ce genre ont toujours été quelque chose qui a manqué à notre communauté, même avant FreeBASIC. J'ai correspondu durant ma vie de programmeur avec quelques novices en programmation et ils ont toujours eu à peu près les mêmes problèmes quand ils ont essayé de programmer un jeu. Donc, je pense que je suis capable de détecter ce dont les débutants ont besoin et de quelle façon les choses doivent leur être expliquées. Je me souviens aussi de mes débuts et des problèmes que j'ai eus avec l'aide des routines séparées qui n'ont jamais été destinées à être combinées et utilisées pour créer un jeu. Le point de rupture a été pour moi le moment où j'ai découvert RelLib (une bibliothèque graphique en QuickBASIC par R.E.Lope) et le moteur de défilement qui a été créé avec elle. Ce moteur de défilement m'a incité à explorer ses mécaniciens et à le développer (avec une certaine aide de R.E.Lope). En un seul instant j'ai acquis la capacité de programmer la plupart des choses (nécessaires pour compléter un jeu) tout seul. C'est comme conduire un vélo. Le moment où vous avez acquis la compétence réelle a duré une seconde.

Donc, c'est mon objectif avec cette série. Pour vous en apprendre suffisamment pour que vous soyez auto-suffisant dans 90% des cas. Et la meilleure façon d'apprendre de nouvelles choses est de les voir appliquées. De nombreux tutoriels échouent dans cette tâche car trop génériques. Vous aurez toujours besoin d'aide de programmeurs plus expérimentés, mais l'idée est que vous n'en avez pas besoin à chaque étape. Ayez à l'esprit que cela dépend du type de jeu que vous développez et la bibliothèque graphique / outils que vous utilisez.

Les programmes d'exemple et de mini-jeux que nous allons créer seront codés en GFXlib (la bibliothèque graphique intégrée de FreeBASIC). Lynn Legacy, Arkade, Line Puissant et Poxie ont été codées avec elle (entre autres) et je pense que ces jeux sont de bonnes références. Mais ne vous inquiétez pas. Passer d'une librairie graphique à l'autre est relativement facile quand on sait comment en utiliserer au moins une.

Ce tutoriel ne traitera pas des moteurs "raycasting" (programmation 3D) ou quelque chose d'"avancé" de ce genre. Si vous voulez utiliser cela, mais n'êtes qu'un débutant, vous avez BESOIN des leçons suivantes EN PREMIER.

Puisque nous allons coder en FreeBASIC vous avez besoin en premier FreeBASIC (si vous ne l'avez pas encore) à partir de http://www.freebasic.net (les exemples ont été compilés avec la version 0.18b) et l'un des IDE FreeBASIC disponibles. Je recommande FBIDE ou FBEdit.

{{fbdoc item="section" value="Exemple #1: Un programme simple - Le cercle se déplace!"}}

Nous allons commencer avec des trucs élémentaires. Le premier programme que nous allons le coder n'aura pas d'éléments graphiques externes, car le chargement des graphiques à partir des fichiers externes (généralement des images BMP) est toujours une affaire compliquée et vous embrouillera pour un début. Croyez-moi. Soyez patient.

Le programme que nous allons créer va vous permettre de déplacer un cercle autour de l'écran. Un programme très simple, mais à travers lui, nous allons apprendre des notions importantes, beaucoup de déclarations élémentaires et méthodes nécessaires pour créer n'importe quel jeu avec GFXlib.

Comme nous utilisons GFXlib vous devez être au courant du fichier gfxlib.txt (documentation GFXlib) situé dans le répertoire /FreeBASIC/docs. C'est notre bible et il très utile pour ces leçons puisque je ne vais pas expliquer tous les paramètres de chaque déclaration utilisée dans les programmes d'exemple (le plus probable). Ce document est quelque peu dépassé depuis que FreeBASIC a évolué avec les nouvelles versions, donc n'oubliez pas de consulter aussi le manuel en ligne du FreeBASIC (partie du Wiki FreeBASIC).

Ouvrez un nouveau programme dans FBIDE. La première chose que nous allons faire est de définir le mode graphique. Quoi? Fixer un mode graphique? Choix de la résolution graphique du programme et de la profondeur des couleurs en bits (8 bits, 16 bits, ...). Par exemple, la profondeur de couleur 8 bits est le standard en mode 256 couleurs (8 bits par pixel). Le mode graphique est réglé avec la déclaration écran suivante:

%%(freebasic)
	SCREEN 13,8,2,0
%%

13 signifie une résolution graphique de 320*200, 8  signifie graphiques 8-bit, 2 signifie deux pages de travail et 0 signifie mode fenêtré (1 pour plein écran). Un minimum de 2 pages de travail est recommandée pour tout programme dépendant de graphiques. Ces notions deviendront plus claires un peu plus tard. Pour plus de détails sur la déclaration SCREEN référez-vous à la documentation de GFXlib ou au Wiki FreeBASIC (une version plus "avancée" de SCREEN est SCREENRES).

La prochaine étape est de définir une boucle qui joue jusqu'à ce que l'utilisateur appuie sur la lettre Q du clavier. Les boucles sont la base de tout programme et pas seulement pour un jeu d'ordinateur. Coder un programme en utilisant une méthode qui le ferait s'arrêter et le mettrait en attente d'une action quelconque de l'utilisateur est une méthode MAUVAISE et ERRONEE quel que soit ce que vous voulez programmer pour que d'autres personnes puissent y jouer. Nous utiliserons les boucles comme des lieux où le programme attend que l'utilisateur fasse quelque chose (clics avec la souris ou appuie sur une touche) et où le programme exécute une routine selon l'action de l'utilisateur. Elles seront également utilisées comme un lieu où les objets non contrôlés par le joueur (ennemis) seront gérés / déplacés. Les boucles sont un "must".

Si vous êtes au courant de toutes ces choses, vous pouvez passer à la fin de cette section et télécharger l'exemple terminé (avec commentaires). S'il y a dedans quelque chose que vous ne comprenez pas, revenez ici.

Nous pouvons définir une boucle de plusieurs façons (avec les déclarations WHILE: WEND, en utilisant l'instruction GOTO - Noooon), mais la meilleure est d'utiliser DO...LOOP. Ce type de boucle répète simplement un bloc d'instructions jusqu'à ce que la condition soit remplie. Vous établissez la(les) condition(s) après LOOP avec UNTIL. Testez le code suivant:

%%(freebasic)
	SCREEN 13,8,2,0 ' Sets the graphic mode
	DO
	' We'll put our statements here later
	Loop Until Inkey$ = "Q" Or Inkey$ = "q"
%%

Si vous compilez ce code et l'exécutez, vous aurez une petit fenêtre 320 * 200 noire et vide et vous pourrez la désactiver en appuyant sur la touche Q (vous pourriez avoir besoin de la maintenir). Le programme boucle tout simplement jusqu'à ce que vous appuyez sur "Q" ou "q". J'ai utilisé les deux: majuscules et minuscules pour la lettre "Q" au cas où les majuscules seraient verrouillées sur votre clavier. INKEY $ est une instruction qui retourne la dernière touche appuyée du clavier . J'expliquerai plus tard pourquoi elle ne doit pas être utilisée dans les jeux et quel est le meilleur substitut.

Pour tracer un cercle j'utiliserai la déclaration CIRCLE (se référer à la documentation GFXlib). Essayez le code suivant:

%%(freebasic)
	SCREEN 13,8,2,0 ' Sets the graphic mode

	DO

	CIRCLE (150, 90), 10, 15 

	Loop Until Inkey$ = "Q" Or Inkey$ = "q"
%%

Le dernier code dessine un petit cercle aux coordonnées 150, 90 avec un rayon de 10 et la couleur 15 (Blanc pur) dans une boucle, que vous pouvez essayer si vous compilez le code. Alors, comment déplacer de ce cercle? Nous devons relier ses coordonnées avec des VARIABLES. Pour cela nous allons utiliser deux variables nommées circlex et circley. Vérifiez le code suivant:

%%(freebasic)
	DIM SHARED AS SINGLE circlex, circley

	SCREEN 13,8,2,0 ' Sets the graphic mode

	circlex = 150 ' Initial circle position
	circley = 90

	DO

	CIRCLE (circlex, circlex), 10, 15 

	Loop Until Inkey$ = "Q" Or Inkey$ = "q"
%%

Cela n'apporte aucune modification dans le résultat de notre programme, mais c'est une étape vers ce que nous voulons accomplir. Vous pouvez modifier les valeuurs de circlex et circley, mais ce n'est pas ce que nous voulons vraiment. Afin de déplacer le cercle nous devons connecter les variables circlex et circley avec les déclarations du clavier.

Nous avons déclaré les deux premières variables dans notre programme. Depuis FreeBASIC ver.0.17 toutes les variables dans les programmes de FreeBASIC doivent être déclarées, mais si vous utilisez la  commande en ligne "-lang qb" pendant la compilation, vous pouvez compiler en utilisant la compatibilité avec le vieux dialecte QBasic (je ne le recommande pas car cela vous privera des avancées et extensions possibles que la compatibilité FB par défaut fournit déjà et fournira). Pour plus d'infos sur cela consultez la page appropriée du wiki FreeBASIC - Utilisation de la ligne de commande. Les variables sont déclarées (dimensionnées) de cette façon:

%%(freebasic)
	DIM variable_name [AS type_of_variable] 
%%

Ou...

%%(freebasic)
	DIM [AS type_of_variable] variable1, variable2, variable3, ... 
%%

Les données entre [ ] sont facultatives et les crochets ne sont pas utilisés. Les types de variables disponibles en FreeBASIC sont BYTE, SHORT, INTEGER, STRING, SINGLE, DOUBLE et quelques autres, mais il n'est pas important, à ce niveau, de donner des détails sur elles. Ce que vous devez savoir maintenant c'est que vous pouvez déclarer des variables ou des tableaux d' INTEGER quand ils contiennent des données graphiques (tampons mémoire contenant des éléments graphiques) ou quand elles représentent des données qui ne nécessitent de précision décimale (nombre de vies, points, etc;); les variables qui ont besoin de précision décimale sont déclarées AS SINGLE ou DOUBLE. Celles-ci sont généralement des variables utilisées dans les jeux qui reposent sur des formules de physique comme les jeux d'arcade de conduite de voiture ou des jeux "Jump 'n run" (effet de la pesanteur). Simplement, la différence entre la vitesse de deux pixels par cycle et la vitesse d'un pixel par cycle est le plus souvent trop gros, et dans ces limites, vous ne pouvez pas reproduire des effets comme le mouvement des fluides de la manière la plus satisfaisante. Derrière DIM vous pouvez ausi ajouter SHARED qui rend la variable spécifique lisible dans l'ensemble du programme (tous les sous-programmes). N' utiliser pas SHARED uniquement avec les variables déclarées à l'intérieur des sous-routines (je le fais très rarement). Si vous avez à déclarer des TABLEAUX  dans une routine, je vous conseille de remplacer DIM par REDIM. Les chaînes sont utilisés pour contenir des données texte. Comme VotreNom = "Dodo", mais vous devez au préalable déclarer VotreNom AS STRING.

Maintenant je vais vous présenter une nouvelle fonction remplaçant INKEY$ qui permet de détecter de multiples pressions sur les touches et qui est beaucoup plus réactive (réponse parfaite) que INKEY$. La faille du INKEY$, en plus d'être très non-réactive (ce que vous avez probablement remarqué lorsque vous avez essayé de fermer les exemples précédemment compilés), est qu'elle ne peut détecter qu'une seule pression de touche à tout instant ce qui le rend complètement inutilisable dans les jeux.

Le substitut, nous allons utiliser est MULTIKEY (une déclaration GFXlib) qui dispose d'un seul paramètre, et c'est le "scancode DOS" de la touche que vous voulez interroger. Vous pourriez être perdu maintenant. Le "scancode DOS" n'est rien d'autre que le code attribué par l'ordinateur aux touches du clavier. Si vous consultez l'annexe A de la documentation de la GFXlib, vous verrez ce que chaque code représente. Par exemple, MULTIKEY(&h1C) correspond à un appui sur la touche ENTRER. La GFXlib vous permet de remplacer ces scancodes par des constantes "facile à lire" comme expliqué dans l'annexe A. Pour utiliser GFXlib vous devez inclure son fichier.bi (fbgfx.bi) dans votre source. Qu'est-ce qu'un fichier.bi? Eh bien, ce peut être n'importe quel type de module que vous joignez à votre code source et qui peut fournir différents sous-programmes (si vous ne savez pas ce qu'est un sous-programme est, nous verrons plus tard) et déclarations utilisées dans votre module principal. Le code que vous devez ajouter corresond aux deux lignes suivantes:

%%(freebasic)
	#include "fbgfx.bi" 
	Using FB
%%

Il est préférable de mettre ces deux lignes quelque part au début de votre programme (avant ou après les déclarations des "sub"). Vous n'avez pas besoin de définir un chemin vers fbgfx.bi car il a placé dans le répertoire /FreeBASIC /inc. Vous avez seulement besoin de définir un chemin vers un fichier.bi s'il n'est pas dans ce répertoire ou dans le répertoire du code source. Utiliser FB indique au programme que nous accèderons aux symboles GFXlib sans espace de noms, ce qui signifie, sans avoir à mettre "FB." en face de chaque symbole GFXlib. Reportez-vous au Wiki sur l'UTILISATION de FreeBASIC.

Maintenant, le plaisir commence.

Nous allons ajouter une nouvelle variable nommée "circlespeed" dont les drapeaux (bits à 1) indiquent le nombre de pixels du cercle qui se déplacent dans un cycle (une boucle). Le mouvement sera provoqué par les touches flèches. Chaque fois que l'utilisateur appuie sur une touche fléchée nous allons dire au programme de modifier "circlex" ou "circley" (cela dépend de la touche appuyée) par la quantité "circlespeed". Testez le code suivant:

%%(freebasic)
	#include "fbgfx.bi"
	Using FB

	DIM SHARED AS SINGLE circlex, circley, circlespeed 

	SCREEN 13,8,2,0 ' Sets the graphic mode

	circlex = 150   ' Initial circle position
	circley = 90
	circlespeed = 1 ' Circle's speed => 1 pixel per loop

	DO

	CIRCLE (circlex, circley), 10, 15

	' According to pushed key we change the circle's coordinates.
	IF MULTIKEY(SC_RIGHT) THEN circlex = circlex + circlespeed
	IF MULTIKEY(SC_LEFT) THEN circlex = circlex - circlespeed
	IF MULTIKEY(SC_DOWN) THEN circley = circley + circlespeed
	IF MULTIKEY(SC_UP) THEN circley = circley - circlespeed

	LOOP UNTIL MULTIKEY(SC_Q) OR MULTIKEY(SC_ESCAPE)
%%

Comme vous le voyez nous avons aussi changé la condition après UNTIL puisque nous utilisons MULTIKEY maintenant. Maintenant vous pouvez aussi quitter le programme en appuyant sur ESCAPE (j'ai ajouté une autre condition).

Si vous compilez la dernière version du code, deux choses indésirables se produisent. Le programme s'exécutera si rapidement que vous ne remarquerez même pas le mouvement du cercle et le cercle "s'étale" sur l'écran (les cercles tracés aux différentes coordonnées dans les cycles précédents ne sont pas effacés et s'accumulent à l'écran). Pour éviter cela vous devez placer l'instruction CLS (nettoie l'écran) dans la boucle de façon que pour chaque nouveau cycle l'ancien cercle du cycle précédent soit effacé avant le tracé du nouveau.

Pour réduire la vitesse du programme le correctif le plus rapide est la commande SLEEP. Que fait-elle? Elle attend (ne fait rien) jusqu'à ce que la quantité de temps spécifiée (en millisecondes) soit écoulée ou bien qu'une touche soit appuyée. Pour annuler l'option "touche appuyée" utilisez "SLEEP millisecondes, 1". Cette instruction est également une solution efficace pour le problème d'utilisation du processeur à 100%. Vous voyez, si vous n'utilisez pas cette instruction tout type de programme FreeBASIC avec une boucle (même la plus simple) mobilisera tous les cycles de l'ordinateur et toutes les autres tâches de Windows ne pourront être exécutées correctement. Cela rend également difficile pour vous d'exécuter d'autres tâches pendant l'exécution ce genre de programme FreeBASIC. Euh ... ce n'est pas un problème énorme et une bonne quantité de programmeurs qui ont réalisé des jeux FreeBASIC jusqu'à présent n'ont pas pris la peine de s'en préoccuper.

Copiez et collez le code suivant et compilez le:

%%(freebasic)
	#include "fbgfx.bi"
	Using FB

	DIM SHARED AS SINGLE circlex, circley, circlespeed  

	SCREEN 13,8,2,0 ' Sets the graphic mode

	circlex = 150   ' Initial circle position
	circley = 90
	circlespeed = 1 ' Circle's speed => 1 pixel per loop

	DO

	CLS
	CIRCLE (circlex, circley), 10, 15

	' According to pushed key we change the circle's coordinates.
	IF MULTIKEY(SC_RIGHT) THEN circlex = circlex + circlespeed
	IF MULTIKEY(SC_LEFT) THEN circlex = circlex - circlespeed
	IF MULTIKEY(SC_DOWN) THEN circley = circley + circlespeed
	IF MULTIKEY(SC_UP) THEN circley = circley - circlespeed

	SLEEP 10, 1

	LOOP UNTIL MULTIKEY(SC_Q) OR MULTIKEY(SC_ESCAPE)
%%

Voila! Notre cercle se déplacement "assez lentement".

La dernière version du code ne présente pas la meilleure manière de coder, mais j'ai été obligé de le simplifier afin de rendre cette leçon facile à comprendre. Nous allons maintenant déclarer nos variables de la manière dont elles doivent l'être dans tout programme "sérieux" et de montrer l'utilité et l'utilisation de deux pages de travail.

La façon dont les variables sont déclarées dans le code ci-dessus n'est pas plus pratique que dans les grands projets où nous avons énormément de variables habituellement associées à plusieurs objets (un objet peut être le joueur, un ennemi ou tout ce qui est défini avec PLUS D'UNE VARIABLE).

Alors d'abord nous allons définir un type de données défini par l'utilisateur avec l'instruction TYPE qui peut contenir plusieurs variables/tableaux (restez avec moi!). Nous allons nommer ce type de données utilisateur "ObjectType". Le code:

%%(freebasic)
	TYPE ObjectType
	     x AS SINGLE
	     y AS SINGLE
	     speed AS SINGLE
	END TYPE
%%

Après cela, nous déclarons notre cercle comme un objet:

%%(freebasic)
	DIM SHARED CircleM AS ObjectType
	' We can't declare this variable with "Circle"
	' since then FB can't differ it from 
	' the statement CIRCLE, thus "CircleM".
%%

Comment cette méthode est-elle bénéfique? Elle nous permet de gérer les variables du programme par un moyen plus efficace et plus propre. Au lieu d'avoir (dans cet exemple) à déclarer les caractéristiques de chaque cercle (la position, vitesse, etc) séparément, nous allons simplement utiliser un "type:def" qui comprend toutes ces variables et lui associer une variable ou un tableau (dans notre cas, c'est CircleM). Alors maintenant, la position x du cercle est marqué avec "CircleM.x", la position y cercle avec "CircleM.y" et la vitesse du cercle avec "CircleM.speed". J'espère que vous comprenez maintenant pourquoi c'est mieux. Un Type défini par l'utilisateur peut être connecté à plusieurs variables ou des tableaux. Dans cet exemple, vous pouvez ajouter un autre objet avec quelque chose comme "DIM SHARED EnemyCircle(8) AS ObjectType" qui nous permettrait de gérer 8 "cercles ennemis" avec un ensemble spécifique de routines (une IA d'une certaine sorte) en utilisant les variables "ObjectType type:def (x, y, speed)", et ces cercles pourraient "attaquer" le cercle de l'utilisateur d'une certaine façon. Dans la prochaine leçon tout cela deviendra plus clair. Avoir à l'esprit que TOUTES les variables ne doivent pas être déclarées en utilisant un "type:def". Ce sont seulement pour les "objets" de votre jeu qui seront définis (caractérisés) avec plusieurs variables (comme un héros déterminé par la santé, de l'argent, le score, la force, etc.).

Après le changement de la version finale du code ressemble à ceci:

%%(freebasic)
	#include "fbgfx.bi"
	Using FB 

	' Our user defined type.
	TYPE ObjectType
	     x AS SINGLE
	     y AS SINGLE
	     speed AS SINGLE
	END TYPE

	DIM SHARED CircleM AS ObjectType
	' We can't declare this variable with "Circle"
	' since then FB can't differ it from 
	' the statement CIRCLE, thus "CircleM".

	SCREEN 13,8,2,0 ' Sets the graphic mode
	SETMOUSE 0,0,0 ' Hides the mouse cursor

	CircleM.x = 150   ' Initial circle's position
	CircleM.y = 90
	CircleM.speed = 1 ' Circle's speed => 1 pixel per loop

	DO

	CLS
	CIRCLE (CircleM.x, CircleM.y), 10, 15

	' According to pushed key we change the circle's coordinates.
	IF MULTIKEY(SC_RIGHT) THEN CircleM.x = CircleM.x + CircleM.speed
	IF MULTIKEY(SC_LEFT) THEN CircleM.x = CircleM.x - CircleM.speed
	IF MULTIKEY(SC_DOWN) THEN CircleM.y = CircleM.y + CircleM.speed
	IF MULTIKEY(SC_UP) THEN CircleM.y = CircleM.y - CircleM.speed

	SLEEP 10, 1 ' Wait for 10 milliseconds.

	LOOP UNTIL MULTIKEY(SC_Q) OR MULTIKEY(SC_ESCAPE)
%%

Vous remarquerez, j'ai ajouté une autre instruction dans le code. L'instructione SETMOUSE positionne le curseur de la souris (les deux premiers paramètres) et l'affiche ou le cache (le troisième paramètre; 0 le cache). Vous pouvez utiliser cette instruction avec ces paramètres par défaut dans chacun de vos programmes APRES l'instruction SCREEN (IMPORTANT!), car même si votre programme contôlera la souris, vous préférerez peut être dessiner votre propre curseur.  because even if your program is going to feature a mouse controllable interface, you will most likely draw your own cursor. Croyez-moi sur ce point. Euh, j'utilise beaucoup trop cette façon de voir les choses.

Téléchargez l'exemple achevé avec des commentaires supplémentaires à l'intérieur du source: move_circle.zip

Ouf, nous en avons fini avec le premier exemple. Certains d'entre vous pourraient penser que je suis allé trop dans les détails, mais je me sens que tout cela était nécessaire pour rendre les exemples suivants et les leçons de cette aventure des plus agréables.

Néanmoins, cet exemple est loin d'être ce que nous voulons, non? Alors au chapitre suivant vous apprendrez comment charger des graphismes à partir de fichiers externes, entre autres. 

{{fbdoc item="section" value="Exemple 2: Un guerrier courant autour d'un champ vert"}}

Dans l'exemple suivant nous allons appliquer toutes les connaissances du premier exemple, alors ne vous attendez pas pour cet exemple à un retour sur chaque instruction. Je vais vous expliquer chaque nouvelle instruction et juste rafraichir les anciennes.

Dans cette section, nous allons commencer à coder notre mini-jeu qui ne sera pas terminé dans cette leçon. Dans cette leçon, nous allons simplement créer un programme où un guerrier tourne autour d'un champ vert (un seul écran).

D'abord je vais vous montrer le graphique que nous allons utiliser. Nous allons travailler en mode couleur 8-bit de profondeur, donc les images que nous allons utiliser doivent être enregistrées dans ce mode (mode 256 couleurs). Pour les "sprites" guerrier je vais utiliser les "sprites" du personnage principal de mon premier jeu "Dark Quest".

http://hmcsoft.org/fb/htpagl1-sprites.png

Comme vous le voyez cette image dispose de 12 sprites de nos guerriers, chacun ayant 20 * 20 pixels de large. Deux pour chaque direction (animation de marche) et un sprite pour chaque direction lorsque le guerrier se balance avec son épée. L'épée balancée n'est mis en oeuvre dans la première leçon, mais deviendra nécessaire plus tard.

La seconde image est l'image d'arrière-plan que vous pouvez télécharger en cliquant ici (320*200 pixels de large, image BMP 8-bit).

Téléchargez les images et placez-les où vous allez placer la source, ou tout simplement Téléchargez l'exemple achevé à la fin de cette section.

Au début de notre programme, Il faut inclure fbgfx.bi, comme dans le premier exemple, puis définir le même mode graphique. Le code:

%%(freebasic)
	#include "fbgfx.bi" 
	Using FB

	SCREEN 13,8,2,0 ' Sets the graphic mode
	SETMOUSE 0,0,0  ' Hides the mouse cursor
%%

Maintenant, nous allons déclarer deux pointeurs de mémoire qui pointeront vers les tampons mémoire où nos graphiques sont stockés (un pour les sprites et un pour le fond).

Le premier pointeur est nommé "background1" et il est déclaré avec la ligne suivante:

%%(freebasic)
	DIM SHARED background1 AS ANY PTR
%%

ANY PTR nous dit que "background1" sera effectivement un pointeur mémoire. Un pointeur défini comme ANY PTR désactive le compilateur pour la vérification le type de données sur lequel il pointe. C'est utile car il peut pointer vers différents types de données. Nous allons utiliser des pointeurs car nous allons allouer de la mémoire pour nos graphiques en utilisant l'instruction IMAGECREATE. IMAGECREATE alloue la bonne quantité de mémoire pour un élement graphique (sprites / image), si nous donnons sa hauteur et sa largeur. Sinon, nous aurions à le faire manuellement, ce qui signifie, calculer la quantité de mémoire nécessaire d'après la taille du sprite, la profondeur de bit et la taille de  la variable. IMAGECREATE fait cela pour nous. Comme le résultat d'IMAGECREATE est un pointeur, nous devons nous référer à un pointeur et non une variable. Ne vous inquiétez pas si vous ne savez rien à propos des pointeurs. Vous n'en avez pas besoin pour comprendre ce tutoriel.

Le pointeur suivant pointe vers la mémoire tampon qui contient les 12 sprites du guerrier. Nous allons le dimensionner comme un tableau unidimensionnel, chaque élément du tableau représentant un sprite.

%%(freebasic)
	DIM SHARED WarriorSprite(12) AS ANY PTR
%%

Ces deux lignes devraient être mis dans le code avant l'instruction SCREEN. C'est la façon d'écrire chaque programme. Déclarations des sous-programmes, déclarations des variables, puis les déclarations des sous-programmes supplémentaire si nécessaire, puis le code réel. Le début de notre programme devrait maintenant ressembler à ceci:

%%(freebasic)
	#include "fbgfx.bi" 
	Using FB

	DIM SHARED background1 AS ANY PTR ' A pointer that points to a memory
	                                  ' buffer holding the background graphics
	DIM SHARED WarriorSprite(12) AS ANY PTR ' A pointer that points to a memory
	                                        ' buffer holding the warrior sprites

	SCREEN 13,8,2,0 ' Sets the graphic mode
	SETMOUSE 0,0,0  ' Hides the mouse cursor
%%

Dès que la résolution de l'écran, la profondeur de couleur et nombre de pages du travail sont fixés, nous allons cacher notre page de travail avant le chargement des graphiques sur elle car nous ne voulons pas que l'utilisateur voit tous les graphique du programme à chaque fois qu'il ou elle lance notre programme . Pour accomplir cela, nous allons utiliser l'instruction SCREENSET. Que fait-elle? Elle définit la page de travail (premier paramètre) et la page visible (deuxième paramètre). Dans notre cas nous allons mettre en page 1 la page de travail et en page 0 la page visible. Après l'utilisation de "SCREENSET 1, 0" chaque fois que nous dessinerons ou chargerons quelque chose sur l'écran, cel sera chargé / dessiné sur la page de travail et ne sera pas visible pour l'utilisateur jusqu'à ce que nous utilisons l'instruction SCREENCOPY ou SCREENSET avec des paramètres différents (SCREENSET 1, 1). Cela nous permet de charger des graphiques sur l'écran, invisibles pour l'utilisateur et de les supprimer avant que la page de travail ne soit la page visible. Cette permutation (flipping) de pages  est également utile dans les boucles avec des" programmes "exigeant des graphiques" pour éviter le scintillement ou un autre événement indésirable.


