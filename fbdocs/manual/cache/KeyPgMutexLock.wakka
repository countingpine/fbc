{{fbdoc item="title" value="MUTEXLOCK"}}----
Acquiert un "mutex"

{{fbdoc item="syntax"}}##
	[[KeyPgDeclare declare]] [[KeyPgSub sub]] **Mutexlock** ( [[KeyPgByval byval]] //id// [[KeyPgAs as]] [[KeyPgAny any]] [[KeyPgPtr ptr]] )
##
{{fbdoc item="usage"}}##
	**Mutexlock**( //id// )
##
{{fbdoc item="param"}}
	##//id//##
		Le ##[[KeyPgAny any]] [[KeyPgPtr ptr]]## "handle" du "mutex" à verrouiller.

{{fbdoc item="desc"}}
	##Mutexlock## arrête tous les autres "threads" utilisant un "handle" de "mutex" généré par ##[[KeyPgMutexCreate Mutexcreate]]##, jusqu'à ce que le "handle" soit déverrouillé avec ##[[KeyPgMutexUnlock Mutexunlock]]##.

	Voir ##[[KeyPgMutexCreate Mutexcreate]]## pour plus d'information générale sur les "mutex".

{{fbdoc item="ex"}}
{{fbdoc item="filename" value="examples/manual/threads/mutexlock.bas"}}%%(freebasic)
'' Threading synchronization using Mutexes
'' If you comment out the lines containing "MutexLock" and "MutexUnlock",
'' the threads will not be in sync and some of the data may be printed
'' out of place.

DECLARE SUB thread1( param as any ptr )
DECLARE SUB thread2( param as any ptr )
DECLARE SUB teletype (BYVAL text AS STRING, BYVAL x AS INTEGER, BYVAL y AS INTEGER)

DIM SHARED threadsync AS any ptr
DIM SHARED thread1handle AS any ptr
DIM SHARED thread2handle AS any ptr

'' Create a mutex to synchronize the threads
threadsync = MUTEXCREATE

'' Call thread 1
thread1handle = THREADCREATE(@thread1)
IF thread1handle = 0 THEN
	PRINT "Error creating thread1"
END IF

'' Call thread 2
thread2handle = THREADCREATE(@thread2)
IF thread2handle = 0 THEN
	PRINT "Error creating thread1"
END IF

'' Wait until both threads are finished
THREADWAIT(thread1handle)
THREADWAIT(thread2handle)

teletype "Testing.................", 1, 1
teletype "Testing again...........", 10, 1

'' Discard the mutex when we are through using teletype
MUTEXDESTROY threadsync

SLEEP
END

'' Thread 1 calls a simple "teletype" routine
SUB thread1( param as any ptr )
	teletype "This is a test...", 4, 1
END SUB

'' ...As does thread 2
SUB thread2( param as any ptr )
	teletype "This is another test...", 7, 1
END SUB

'' Teletype unfurls some text across the screen at a given location
SUB teletype (BYVAL text AS STRING, BYVAL x AS INTEGER, BYVAL y AS INTEGER)
	DIM i AS INTEGER, a as INTEGER
	DIM text_length AS INTEGER

	text_length = LEN(text)
	FOR a = 0 TO text_length
	    '' MutexLock prevents the two simultaneously running
	    '' threads from sharing "x", "y", and "a"
	    MUTEXLOCK threadsync

	    LOCATE x,(y+a)
	    PRINT CHR(text[a])

	    '' MutexUnlock releases these variables for other use
	    MUTEXUNLOCK threadsync

	    SLEEP 25
   NEXT a
END SUB
%%

{{fbdoc item="lang"}}
	- Les "Thread" n'existent pas dans le dialecte //[[CompilerOptlang -lang qb]]//.

{{fbdoc item="target"}}
	- La version DOS de ""FreeBASIC"" ne permet pas les "threads", car l'OS ne les supporte pas.
	- Dans Linux les "threads" sont toujours démarrés dans l'ordre de leur création, ceci n'est pas possible sous ""Win32"". Il s'agit de l'OS, pas une question ""FreeBASIC"".

{{fbdoc item="diff"}}
	- Nouveau pour ""FreeBASIC""

{{fbdoc item="see"}}
	- ##[[KeyPgMutexCreate Mutexcreate]]##
	- ##[[KeyPgMutexDestroy Mutexdestroy]]##
	- ##[[KeyPgMutexUnlock Mutexunlock]]##
	- ##[[KeyPgThreadCreate Threadcreate]]##
	- ##[[KeyPgThreadWait Threadwait]]##

{{fbdoc item="back" value="CatPgThreading|Threading Support Functions"}}

