{{fbdoc item="title" value="Operator Placement New"}}----
Opérateur pour construire un object à l'adresse mémoire spécifiée.

{{fbdoc item="syntax"}}##
	//result// = **New(//address//)** //[[DataType datatype]]//
		//ou//
	//result// = **New(//address//)** //[[DataType datatype]]// ( //initializers//, ... )
		//ou//
	//result// = **New(//address//)** //[[DataType datatype]]//**[** //count// **]**
##
{{fbdoc item="param"}}
	##//address//## 
		La position mémoire où construire. Les parenthèses **ne sont pas** facultatives.
	##//size//## 
		Le nombre d'octets à allouer.
	##//initializers//##
		La valeur initiale de la variable.
	##//datatype//##
		Le nom du type de donnée à créer.
	##//count//##
		Le nombre d'éléments à allouer.

{{fbdoc item="ret"}}
	Un pointeur du type [[DataType datatype]] vers la nouvelle donnée allouée.

{{fbdoc item="desc"}}
	L'opérateur ##**New (Emplacement mémoire)**## construit un type de donnée spécifique à l'emplacement mémoire spécifié. 

	Pour des types simples, comme les entiers, une valeur initiale peut être donnée. Pour des types sans constructeur, des valeurs initiales peuvent être spécifiées pour chacun des champs. Pour les types ayant des constructeurs ceux-ci peuvent être appelés par ##**New (Emplacement mémoire)**##. Si aucun initialiseur n'est fourni, les valeurs par défaut seront utilisées.

	La mémoire **n'est pas** allouée quand on utilise l'opérateur ##**Placement New**##. Au lieu de cela, la mémoire à l'##//address//##e spécifiée est utilisée.  Il est incorrect d'appeler ##[[KeyPgOpDelete Delete]]## pour cette adresse. Voir les exemples ci-dssous pour utiliser correctement //new (emplacement mémoire)//.

	Spécifier une valeur initiale ##[[KeyPgAny Any]]##, comme dans ##new(address) datatype(any)## n'initialisera pas les données.  Ceci n'est valide que pour des types de donnée n'ayant pas de constructeur.

	Spécifier une valeur initiale ##[[KeyPgAny Any]]##, comme dans ##new(address) datatype[count]{any}## n'initialisera pas les données.  Ceci n'est valide que pour des types de donnée n'ayant pas de constructeur.

{{fbdoc item="ex"}}
{{fbdoc item="filename" value="examples/manual/operator/placement_new.bas"}}%%(freebasic)
'' "placement new" example

type Rational
	as integer	numerator, denominator
end type

scope
	
	'' allocate some memory to construct as a Rational
	dim as any ptr ap = callocate(len(Rational))
	
	'' make the placement new call
	dim as Rational ptr r = new (ap) Rational( 3, 4 )
	
	'' you can see, the addresses are the same, just having different types in the compiler
	print ap, r
	
	'' confirm all is okay
	print r->numerator & "/" & r->denominator

	'' destroying must be done explicitly, because delete will automatically free the memory
	'' and that isn't always okay when using placement new. ALWAYS explicitly call the destructor.
	r->destructor( )
	
	'' we explicitly allocated, so we explicitly deallocate
	deallocate( ap )

end scope
%%
{{fbdoc item="lang"}}
	- Utilisable seulement dans le dialecte //[[CompilerOptlang -lang fb]]//.

{{fbdoc item="diff"}}
	- Nouveau pour ""FreeBASIC""

{{fbdoc item="see"}}
	- ##[[KeyPgOpDelete Delete]]##
	- ##[[KeyPgOpNew New]]##

{{fbdoc item="back" value="CatPgOpMemory|Memory Operators"}}{{fbdoc item="back" value="CatPgOperators|Operators"}}