{{fbdoc item="title" value="Operator Placement New"}}----
Op&eacute;rateur pour construire un object &agrave; l'adresse m&eacute;moire sp&eacute;cifi&eacute;e.

{{fbdoc item="syntax"}}##
	//result// = **New(//address//)** //[[DataType datatype]]//
		//ou//
	//result// = **New(//address//)** //[[DataType datatype]]// ( //initializers//, ... )
		//ou//
	//result// = **New(//address//)** //[[DataType datatype]]//**[** //count// **]**
##
{{fbdoc item="param"}}
	##//address//## 
		La position m&eacute;moire o&ugrave; construire. Les parenth&egrave;ses **ne sont pas** facultatives.
	##//size//## 
		Le nombre d'octets &agrave; allouer.
	##//initializers//##
		La valeur initiale de la variable.
	##//datatype//##
		Le nom du type de donn&eacute;e &agrave; cr&eacute;er.
	##//count//##
		Le nombre d'&eacute;l&eacute;ments &agrave; allouer.

{{fbdoc item="section" value="Valeur retourn&eacute;e
	Un pointeur du type [[DataType datatype]] vers la nouvelle donn&eacute;e allou&eacute;e.

{{fbdoc item="desc"}}
	L'op&eacute;rateur ##**New (Emplacement m&eacute;moire)**## construit un type de donn&eacute;e sp&eacute;cifique &agrave; l'emplacement m&eacute;moire sp&eacute;cifi&eacute;. 

	Pour des types simples, comme les entiers, une valeur initiale peut &ecirc;tre donn&eacute;e. Pour des types sans constructeur, des valeurs initiales peuvent &ecirc;tre sp&eacute;cifi&eacute;es pour chacun des champs. Pour les types ayant des constructeurs ceux-ci peuvent &ecirc;tre appel&eacute;s par ##**New (Emplacement m&eacute;moire)**##. Si aucun initialiseur n'est fourni, les valeurs par d&eacute;faut seront utilis&eacute;es.

	La m&eacute;moire **n'est pas** allou&eacute;e quand on utilise l'op&eacute;rateur ##**Placement New**##. Au lieu de cela, la m&eacute;moire &agrave; l'##//address//##e sp&eacute;cifi&eacute;e est utilis&eacute;e.  Il est incorrect d'appeler ##[[KeyPgOpDelete Delete]]## pour cette adresse. Voir les exemples ci-dssous pour utiliser correctement //new (emplacement m&eacute;moire)//.

	Sp&eacute;cifier une valeur initiale ##[[KeyPgAny Any]]##, comme dans ##new(address) datatype(any)## n'initialisera pas les donn&eacute;es.  Ceci n'est valide que pour des types de donn&eacute;e n'ayant pas de constructeur.

	Sp&eacute;cifier une valeur initiale ##[[KeyPgAny Any]]##, comme dans ##new(address) datatype[count]{any}## n'initialisera pas les donn&eacute;es.  Ceci n'est valide que pour des types de donn&eacute;e n'ayant pas de constructeur.

	{{fbdoc item="ex"}}

{{fbdoc item="ex"}}
'' "placement new" example
Type Rational

As Integer    numerator, denominator
	End Type
Scope

'' allocate some memory to construct as a Rational
	
	Dim As Any Ptr ap = CAllocate(Len(Rational))
	'' make the placement new call
	
	Dim As Rational Ptr r = New (ap) Rational( 3, 4 )
	'' you can see, the addresses are the same, just having different types in the compiler
	
	Print ap, r
	'' confirm all is okay
	
	Print r->numerator & "/" & r->denominator
	'' destroying must be done explicitly, because delete will automatically free the memory

	'' and that isn't always okay when using placement new. ALWAYS explicitly call the destructor.
	r->Destructor( )
	'' we explicitly allocated, so we explicitly deallocate
	
	Deallocate( ap )
	End Scope

%%
{{fbdoc item="lang"}}
- Utilisable seulement dans le dialecte //[[CompilerOptlang -lang fb]]//.
	{{fbdoc item="diff"}}

- Nouveau pour FreeBASIC
	{{fbdoc item="see"}}

- ##[[KeyPgOpDelete Delete]]##
	- ##[[KeyPgOpNew New]]##
	- ##[[KeyPgOpNew New]]##

{{fbdoc item="back" value="CatPgOpMemory|Memory Operators"}}{{fbdoc item="back" value="CatPgOperators|Operators"}}