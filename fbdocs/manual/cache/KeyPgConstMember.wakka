{{fbdoc item="title" value="CONST (Member)"}}----
Indique qu'un membre d'une procédure est en lecture seule.

{{fbdoc item="syntax"}}##
	[[KeyPgType Type]] //typename//
		[[KeyPgDeclare declare]] **Const** //membertype// //membername// ...
	End Type
##
{{fbdoc item="param"}}
	##//typename//##
		Nom d'un type de donnée défini par l'utilisateur.
	##//membertype//##
		##[[KeyPgMemberSub Sub]]## ou ##[[KeyPgMemberFunction Function]]##.
	##//membername// ...##
		Nom du membre à déclarer ou définir avec liste de paramètres ou valeur de retour.

{{fbdoc item="desc"}}
	Indique que le ##//membertype//## immédiatement à la droite du qualificateur ##**Const**## doit être considéré comme étant en lecture seule.  Les déclarations "En-lecture-seule" (Read-only) (##**Const**##) sont une mesure de sécurité qui peut être comprise comme "promesse d'aucun changement".  Le compilateur utilise les déclarations ##**Const**## pour vérifier les opérations sur les variables et paramètres et générer une erreur lors de la compilation si leurs données pourraient changer.  Il n'y a pas de temps perdu d'exécution en utilisant les qualificateurs ##**Const**## puisque tous les contrôles sont effectués au moment de la compilation.

	##**Const**##, lorsqu'il est utilisé précédant ##//membertype//## au début d'une déclaration indique que le paramètre caché ##[[KeyPgThis This]]## est considéré comme en lecture seule.  La déclaration peut être lue comme l'invocation de la promesse que ##//membertype//## ne changera pas de ##//typename//##, et le compilateur affichera une erreur si le membre de la procédure essaye de changer un champ de données, ou appelle un membre non-##**Const**## de procédure.  Les membres de procédures ne peuvent être à la fois ##**Const**## et ##[[KeyPgStaticMember Static]]## car les membres statiques de procédures n'ont pas de paramètre ##[[KeyPgThis This]]## caché.

{{fbdoc item="ex"}}
{{fbdoc item="filename" value="examples/manual/udt/const-proc.bas"}}%%(freebasic)
'' Const Member Procedures

type foo
  x as integer
  c as const integer = 0
  declare const sub Inspect1()
  declare const sub Inspect2()
  declare sub Mutate1()
  declare sub Mutate2()
end type

''
sub foo.Mutate1()
  '' we can change non-const data fields
  x = 1

  '' but we still can't change const data
  '' fields, they are promised not to change
  '' c = 1 '' Compile error

end sub

''
sub foo.Mutate2()
  '' we can call const members
  Inspect1()

  '' and non-const members
  Mutate1()

end sub

''
sub foo.Inspect1()
  '' can use data members
  dim y as integer
  y = c + x

  '' but not change them because Inspect1()
  '' is const and promises not to change foo
  '' x = 10 '' Compile error

end sub

''
sub foo.Inspect2()
  '' we can call const members
  Inspect1()

  '' but not non-const members
  '' Mutate1() '' Compile error

end sub
%%

{{fbdoc item="diff"}}
	- Nouveau pour ""FreeBASIC""

{{fbdoc item="see"}}
	- ##[[KeyPgConst Const]]##
	- ##[[KeyPgConstQualifier Const (Qualificateur)]]##
	- ##[[KeyPgDim Dim]]##
	- ##[[KeyPgType Type]]##

{{fbdoc item="back" value="CatPgProcedures|Procedures"}}{{fbdoc item="back" value="CatPgUserDefTypes|User Defined Types"}}