{{fbdoc item="title" value="Introduction to the Type Def"}}----<div id="fb_tab_r"> <img src="images/fblogo_mini.gif">
//Ecrit par [[WikiRick rdc]]//<br \=""><br \="">Il y a des moments, lors de la cr&eacute;ation d'un programme, o&ugrave; l'on souhaite d&eacute;finir une structure globale comme un enregistrement personnel ou un ennemi dans un jeu. Alors que vous pouvez faire cela en utilisant des types de donn&eacute;es individuelles, cela est difficile &agrave; g&eacute;rer dans un programme. Les types de donn&eacute;es composites vous permettent de grouper des &eacute;l&eacute;ments de donn&eacute;es connexes dans une structure unique qui peut &ecirc;tre manipul&eacute;e comme une seule entit&eacute;. FreeBasic offre deux types de donn&eacute;es composites, ##**Type**## et ##**Union**##. <br \=""><br \=""><div class="fb_header"> Types 

<br \=""><br \="">FreeBasic vous permet de grouper plusieurs types de donn&eacute;es dans une structure unifi&eacute;e appel&eacute;e une d&eacute;finition de ##**Type**## que vous pouvez utiliser pour d&eacute;crire ces structures de donn&eacute;es agr&eacute;g&eacute;es.<br \=""><br \="">La structure de base d'une d&eacute;finition de ##**Type**## est:<br \=""><br \="">%%(freebasic)

Type typename<br>    Var definition<br>    Var definition<br>    ...<br>End Type<br>

##<br><br \="">Le bloc ##**Type ... Type-End**## d&eacute;finit la port&eacute;e de la d&eacute;finition. Vous d&eacute;finissez les &eacute;l&eacute;ments de la structure ##**Type**## de la m&ecirc;me mani&egrave;re que vous utilisez le mot cl&eacute; ##**Dim**##, sans utiliser ##**Dim**##. L'extrait de code suivant montre comment construire un ##**Type**## d'##//Employee//##.<br \=""><br \="">%%(freebasic)

Type EmployeeType<br>    fname As String * 10<br>    lname As String * 10<br>    empid As Integer<br>    dept As Integer<br>End Type    <br>

##<br><br \="">Vous pouvez utiliser n'importe quel type de donn&eacute;es comme &eacute;l&eacute;ment de donn&eacute;es, y compris des pointeurs et d'autres d&eacute;finitions de ##**Type**##. Lorsque vous cr&eacute;ez la d&eacute;finition d'un ##**Type**##, comme dans l'exemple ci-dessus, vous &ecirc;tes juste en train de cr&eacute;er un mod&egrave;le pour le compilateur. Afin d'utiliser la d&eacute;finition du ##**Type**##, vous devez cr&eacute;er une variable de ce ##**Type**##, comme le montre l'extrait de code suivant.<br \=""><br \="">%%(freebasic)
Dim Employee As EmployeeType<br>
	##<br><br \="">Lorsque vous avez cr&eacute;&eacute; une variable de ce ##**Type**##, vous pouvez acc&eacute;der &agrave; chaque &eacute;l&eacute;ment dans le ##**Type**## l'aide de la notation point&eacute;e  ##//var_name.field_name//##.  <br \=""><br \="">En utilisant l'exemple ci-dessus, pour acc&eacute;der au champ ##//fname//## vous pouvez utiliser: <br \=""><br \="">%%(freebasic)
	Employee.fname = "Susan"<br>
	##<br><br \=""><div class="fb_header"> Utiliser With 
<br \=""><br \="">Pour acc&eacute;der &agrave; des champs multiples au m&ecirc;me moment, vous pouvez utiliser le bloc ##**With-End With**##. Le code suivant montre comment utiliser le bloc ##**With**## avec l'exemple ci-dessus.<br \=""><br \="">%%(freebasic)
With Employee<br>    .fname = "Susan"<br>    .lname = "Jones"<br>    .empid = 1001<br>        .dept = 24<br>End With    <br>

##<br><br \="">Le compilateur lie automatiquement la variable ##//Employee//## avec les &eacute;l&eacute;ments de donn&eacute;es individuels du bloc. Non seulement cela signifie que vous n'avez pas &agrave; &eacute;crire beaucoup plus, mais la structure est optimis&eacute;e et un peu plus rapide que l'utilisation de la notation point&eacute;e compl&egrave;te.<br \=""><br \=""><div class="fb_header"> Transmission de Types aux sous-routines et fonctions 

<br \=""><br \="">Un avantage de l'utilisation de ##**Type**## dans votre programme est que vous pouvez passer la structure &agrave; un sous-programme ou une fonction et op&eacute;rer sur la structure dans son ensemble. Le fragment de code suivant montre une d&eacute;finition partielle de sous-routine.<br \=""><br \="">%%(freebasic)
Sub UpdateEmployeeDept(ByRef Emp As EmployeeType)<br>    .<br>    .<br>    .<br>End Sub<br>
	##<br><br \="">Notez que le param&egrave;tre est qualifi&eacute; avec ##**Byref**##. Ceci est important puisque vous voulez mettre &agrave; jour ce ##**Type**## dans la sous-routine. Il existe deux modes de passage de param&egrave;tres en FreeBasic: ##**ByRef**## et ##**Byval**##. <br \=""><br \="">** Byref et Byval: Pr&eacute;sentation rapide **<br \=""><br \="">##**ByRef**## et ##**Byval**## indiquent au compilateur comment passer une r&eacute;f&eacute;rence &agrave; une sous-routine ou une fonction. Lorsque vous utilisez ##**ByRef**##, ou //Par R&eacute;f&eacute;rence//, vous passez un pointeur de r&eacute;f&eacute;rence au param&egrave;tre et toutes les modifications que vous apportez au param&egrave;tre &agrave; l'int&eacute;rieur de ##**Sub**## ou ##**Function**## sera refl&eacute;t&eacute;e dans la variable r&eacute;elle qui a &eacute;t&eacute; pass&eacute;e. En d'autres termes, le param&egrave;tre ##**ByRef**## pointe sur la variable r&eacute;elle dans la m&eacute;moire.<br \=""><br \="">##**Byval**##, ou //Par Valeur//, d'autre part fait une copie du param&egrave;tre et toutes les modifications apport&eacute;es &agrave; l'int&eacute;rieur de ##**Sub**## ou ##**Function**## sont locales et ne seront pas refl&eacute;t&eacute;es dans la variable r&eacute;elle qui a &eacute;t&eacute; pass&eacute;e. Le param&egrave;tre ##**Byval**## pointe sur une copie de la variable et non sur la variable r&eacute;elle, elle-m&ecirc;me.<br \=""><br \="">Par d&eacute;faut FreeBasic .17 passe les param&egrave;tres en utilisant ##**Byval**##. Pour modifier un param&egrave;tre pass&eacute;, vous devez &agrave; sp&eacute;cifier le qualificatif ##**ByRef**##. Dans cet exemple, la sous-routine met &agrave; jour le //department id// du //Type employee//, donc le param&egrave;tre est qualifi&eacute; par ##**ByRef**## pour que la sous-routine puisse mettre &agrave; jour le champ //dept// de la variable.<br \=""><br \="">En revanche vous n'avez pas besoin de mettre &agrave; jour le ##**Type**## comme dans le fragment de code suivant.<br \=""><br \="">%%(freebasic)
	Sub PrintEmployeeRecord(Emp As EmployeeType)<br>    .<br>    .<br>    .<br>End Sub<br>
	##<br><br \="">Dans cette sous-routine on affiche seulement l'enregistrement de //employee// &agrave; l'&eacute;cran ou on l'envoie vers l'imprimante et on n'a pas a chang&eacute; quoi que ce soit dans la variable ##**Type**##. Ici c'est ##**Byval**## par d&eacute;faut qui est utilis&eacute; pour passer une copie de l'enregistrement de //employee// &agrave; la sous-routine au lieu d'une r&eacute;f&eacute;rence vers la variable. En utilisant ##**Byval**##, dans ce cas, vous &eacute;vitez de changer quelque chose accidentellement dans la variable ##**Type**##, ce que vous ne d&eacute;siriez pas.<br \=""><br \="">Vous ne devez utiliser ##**Byref**## que si vous avez l'intention de modifier les donn&eacute;es des param&egrave;tres. Il est beaucoup plus plus s&ucirc;r d'utiliser ##**Byval**## dans les cas o&ugrave; vous devez avoir les donn&eacute;es des param&egrave;tres, mais que vous souhaitez &eacute;viter toute modification accidentelle de ces donn&eacute;es. Ces modifications accidentelles g&eacute;n&egrave;rent des bugs difficiles &agrave; trouver dans les programmes.<br \=""><br \=""><div class="fb_header"> Types dans les Types 
	<br \=""><br \="">En plus des types de donn&eacute;es intrins&egrave;ques, un champ de Type peut &eacute;galement &ecirc;tre bas&eacute; sur une d&eacute;finition de Type. Pourquoi vouloir faire cela? Une des raisons est l'abstraction de donn&eacute;es. Plus vos structures de donn&eacute;es seront g&eacute;n&eacute;rales, plus vous pourrez en r&eacute;utiliser le code dans d'autres parties de votre programme. Moins vous avez &agrave; &eacute;crire de code, moins les erreurs auront de chance de trouver le chemin de vos programmes. <br \=""><br \="">En utilisant l'exemple d'##//Employee//##, supposons un instant que vous ayez besoin de plus d'informations ##//dept//## que seulement ##//department id//##. Vous pourriez avoir besoin de garder une trace de ##//department manager//##, l'emplacement du d&eacute;partement, comme le ##//floor//## (&eacute;tage) ou le b&acirc;timent ou le num&eacute;ro de t&eacute;l&eacute;phone principal du d&eacute;partement. En mettant ces informations dans une d&eacute;finition de ##**Type**## distincte, vous pouvez utiliser cette information par elle-m&ecirc;me ou comme partie d'une autre d&eacute;finition de ##**Type**## comme ##//Employee//##. En g&eacute;n&eacute;ralisant vos structures de donn&eacute;es, votre programme sera plus petit et beaucoup plus robuste.<br \=""><br \="">L'utilisation d'un ##**Type**## dans un ##**Type**## est identique &agrave; celle de l'un des types de donn&eacute;es intrins&egrave;ques. Les extraits de code suivant illustrent un ##**Type**## ##//department//## &eacute;tendu et un ##**Type**## ##//employee//## mis &agrave; jour.<br \=""><br \="">%%(freebasic)
Type DepartmentType<br>    id As Integer<br>    managerid As Integer<br>    floor As Integer<br>End Type        <br><br>Type EmployeeType<br>    fname As String * 10<br>       lname As String * 10<br>        empid As Integer<br>        dept As DepartmentType<br>End Type<br><br>Dim Employee As EmployeeType<br>
##<br><br \="">Notez que dans la d&eacute;finition de ##//Employee//## le champ ##//dept//## est d&eacute;fini comme ##//DepartmentType//## au lieu d'un des types de donn&eacute;es intrins&egrave;ques. Pour acc&eacute;der &agrave; l'information ##//department//## dans le ##**Type**## ##//Employee//##, on utilise la notation point&eacute;e compos&eacute;e pour acc&eacute;der aux champs de ##//dept//##:<br \=""><br \="">%%(freebasic)

Employee.dept.id = 24<br>Employee.dept.managerid = 1012<br>Employee.dept.floor = 13<br>

##<br><br \="">Le plus haut niveau de la d&eacute;finition du ##**Type**## est ##//Employee//##, donc sa r&eacute;f&eacute;rence vient en premier. Comme ##//dept//## est maintenant une d&eacute;finition de ##**Type**##, vous devez utiliser l'identifieur de ##//dept//## pour acc&eacute;der aux champs individuels de ##//DepartmentType//##. ##//Employee//## se r&eacute;f&egrave;re au ##**Type**## ##//employee//##, ##//dept//## se r&eacute;f&egrave;re au ##**Type**## ##//department//## et ##//id//##, ##//managerid//## et ##//floor//## sont des champs du ##**Type**## ##//department//##.<br \=""><br \="">Vous pouvez m&ecirc;me faire davantage, notamment avec un ##**Type**## dans un ##**Type**## dans un ##**Type**##. Vous utiliserez simplement la notation point&eacute;e du niveau de type suppl&eacute;mentaires au besoin. Bien qu'il n'y ait pas de limite au niveau des d&eacute;finitions de types imbriqu&eacute;s, cela devient un peu lourd lors de l'utilisation de nombreux niveaux.<br \=""><br \=""><div class="fb_header"> With et les Types imbriqu&eacute;s 
<br \=""><br \="">Vous pouvez aussi utiliser un bloc ##**With-End With**## avec des ##**Type**##s imbriqu&eacute;s, en imbriquant le bloc ##**With**##, comme illustr&eacute; dans l'exemple ci-dessous.<br \=""><br \="">%%(freebasic)
With Employee<br>       .fname = "Susan"<br>        .lname = "Jones"<br>        .empid = 1001<br>        With .dept<br>            .id = 24<br>            .managerid = 1012<br>            .floor = 13<br>        End With<br>End With<br>

##<br><br \="">Notez que le second ##**With**## utilise la notation point&eacute;e, ##//.dept//##, pour sp&eacute;cifier le niveau suivant de d&eacute;finition de ##**Type**##. Quand vous utilisez des blocs ##**With**## imbriqu&eacute;s, assurez-vous que toutes les d&eacute;clarations ##**End With**## correspondent correctement &agrave; une d&eacute;claration ##**With**## sinon il y aura un message d'erreur lors de la compilation.<br \=""><br \=""><div class="fb_header"> Affectations de Type 

<br \=""><br \="">Pour aller plus loin dans l'extension de l'id&eacute;e d'abstraction des donn&eacute;es, il serait int&eacute;ressant de s&eacute;parer l'initialisation du ##**Type**## ##//department//## de celle du ##**Type**## ##//employee//##. En s&eacute;parant les deux fonctions, vous pouvez facilement ajouter des informations suppl&eacute;mentaires &agrave; ##//department//## en fonction de vos besoins. C'est l&agrave; que vous pouvez utiliser des assignations de ##**Type**##. <br \=""><br \="">Tout comme vous pouvez affecter un type intrins&egrave;que des donn&eacute;es &agrave; un autre, vous pouvez affecter une variable de ##**Type**## &agrave; une autre variable de ##**Type**##, &agrave; condition qu'elles aient la m&ecirc;me d&eacute;finition de ##**Type**##.<br \=""><br \="">Les extraits de code suivants r&eacute;sument la fonction d'initialisation de ##//department//## et attribue le r&eacute;sultat au ##**Type**## ##//department//## dans le ##**Type**## ##//Employee//##.<br \=""><br \="">%%(freebasic)

'This function will init the dept type and return it to caller<br>Function InitDept(deptid As Integer) As DepartmentType<br>    Dim tmpDpt As DepartmentType<br><br>    Select Case deptid<br>        Case 24 'dept 24<br>        With tmpDpt<br>                    .id = deptid<br>                    .managerid = 1012<br>                    .floor = 13<br>            End With<br>        Case 48 'dept 48<br>             With tmpDpt<br>                    .id = deptid<br>                    .managerid = 1024<br>                    .floor  = 12<br>                End With<br>        Case Else 'In case a bad department id was passed<br>                With tmpDpt<br>                    .id = 0<br>                    .managerid  = 0<br>                    .floor  = 0<br>                End With<br>    End Select<br><br>    'Return the dept info<br>    Return tmpDpt<br>End Function<br><br>'Create an instance of the type<br>Dim Employee As EmployeeType<br><br>'Initialize the Employee type<br>With Employee<br>    .fname = "Susan"<br>    .lname = "Jones"<br>    .empid = 1001<br>    .dept = InitDept(24) 'get dept info<br>End With<br>
##<br><br \="">Comme vous pouvez le voir dans l'extrait ci-dessus, le champ ##//dept//## du ##**Type**## ##//employee//## est initialis&eacute; par un appel &agrave; une fonction. La fonction ##//InitDept//## retourne un ##//DepartmentType//## et le compilateur affectera ce ##**Type**## au champ de l'enregistrement ##//Employee//##. <br \=""><br \="">Par le simple ajout d'une fonction au programme, vous avez rendu le programme plus facile &agrave; maintenir. Si un nouveau ##//department//## est cr&eacute;&eacute;, vous pouvez simplement mettre &agrave; jour la fonction ##//InitDept//## avec le nouveeau ##//department//##, recompiler et le programme est pr&ecirc;t &agrave; red&eacute;marrer.<br \=""><br \=""><div class="fb_header"> Champs de bits 
<br \=""><br \="">Il y a encore un autre ##**Type**## de donn&eacute;es qui peuvent &ecirc;tre utilis&eacute;s dans les d&eacute;finitions de ##**Type**##, le champ de bits. Les champs de bits sont d&eacute;finis ainsi ##//variable_name: bits As DataType//##.Le nom de la variable doit &ecirc;tre suivi de deux-points (:), le nombre de bits, suivi par le type de donn&eacute;es. Seuls les donn&eacute;es de ##**Type**## entier sont autoris&eacute;es dans un champ de bits. Les champs de bits sont utiles lorsque vous avez besoin de garder une trace d'informations de type bool&eacute;en. Un bit peut avoir les valeurs 0 ou 1, ce qui peut repr&eacute;senter Oui ou Non, Marche ou Arr&ecirc;t ou m&ecirc;me Noir et Blanc. <br \=""><br \="">L'extrait de code suivant illustre la d&eacute;finition d'un champ de bits.<br \=""><br \="">%%(freebasic)

Type BitType<br>    b1: 1 As Integer<br>    b2: 4 As Integer<br>End Type<br>

##<br><br \="">b1 est d&eacute;fini comme bit unique et b2 comme ayant quatre bits. Vous initialisez les champs de bits en passant les bits individuels aux champs du ##**Type**##.<br \=""><br \="">%%(freebasic)

myBitType.b1 = 1<br>myBitType.b2 = 1101<br>
##<br><br \="">Le type de donn&eacute;es du champ de bits d&eacute;termine le nombre de bits que vous pouvez d&eacute;clarer, dans un champ de bits. Puisqu' un entier &agrave; une longueur de 32 bits, vous pouvez d&eacute;clarer jusqu'&agrave; 32 bits dans le champ. Cependant, dans la plupart des cas, vous allez d&eacute;clarer un seul bit pour chaque champ et utiliser un certain nombre de champs afin de d&eacute;finir le masque de bits que vous souhaitez utiliser. Utiliser un bit unique simplifie le codage que vous devez &eacute;l&eacute;borer pour d&eacute;terminer si un bit est activ&eacute; ou d&eacute;sactiv&eacute; et vous permet d'identifier facilement ce qu'un bit signifie dans la d&eacute;finition du ##**Type**##.<br \=""><br \=""><div class="fb_header"> La propri&eacute;t&eacute; Field 
	<br \=""><br \="">Lorsque vous cr&eacute;ez une variable d'un ##**Type**## d&eacute;fini, le ##**Type**## est ##//bourr&eacute;//## en m&eacute;moire. Le ##//bourrage//## permet un acc&egrave;s plus rapide des membres de ##**Type**## puisque ses champs sont align&eacute;s dans les limites d'un ##//Word//## de 4 octets. Cependant, cela peut causer des probl&egrave;mes lorsque vous essayez de lire un enregistrement de ##**Type**## &agrave; partir d'un fichier qui n'est pas ##//bourr&eacute;//##. Vous pouvez utiliser la propri&eacute;t&eacute; ##**Field**## d'un champ pour changer le stockage en m&eacute;moire de la d&eacute;finition du ##**Type**##. <br \=""><br \="">Le mot-clef ##**Field**## est utilis&eacute; juste &agrave; droite du nom du ##**Type**## et peut avoir les valeurs 1, pour un alignement sur 1 octet (sans bourrage), 2 un alignement sur 2 octets et 4 un alignement sur 4 octets. Pour d&eacute;finir un ##**Type**## sans ##//bourrage//## vous utiliserez la syntaxe suivante.<br \=""><br \="">%%(freebasic)
	Type myType Field = 1<br>     v1 As Integer<br>    v2 As Byte<br>End Type<br>
	##<br><br \="">Pour un alignement sur 2 octets utilisez ##**Field**## = 2. Si aucune propri&eacute;t&eacute; ##**Field =**## n'est attribu&eacute;e, le ##//bourrage//## est alors de 4 octets. Si vous lisez une d&eacute;finition de ##**Type**## cr&eacute;&eacute;e sous FreeBasic en utilisant l'alignement par d&eacute;faut, vous n'avez pas besoin, dans ce cas, d'utiliser la propri&eacute;t&eacute; ##**Field**##.<br \=""><br \="">{{table columns="" cellpadding="2" cells="<table><tbody> Si vous lisez un enregistrement Quick Basic d'un ##**Type**##, alors vous devez utiliser ##**Field**## = 1, car QB utilisait l'alignement des octets par d&eacutefaut.;</tbody></table>
		<br \=""><br \=""><div class="fb_header"> Initialisation de Type 
<br \=""><br \="">Vous pouvez initialiser une d&eacute;finition de ##**Type**## lorsque vous dimensionnez le ##**Type**## comme vous le feriez avec une variable intrins&egrave;que. L'extrait de code suivant illustre la syntaxe.<br \=""><br \="">%%(freebasic)
Type aType<br>        a As Integer<br>        b As Byte<br>        c As String * 10<br>End Type<br><br>Dim myType As aType => (12345, 12, "Hello")<br>

##<br><br \="">Dans l'instruction ##**Dim**##, l'op&eacute;rateur fl&egrave;che //+>// est utilis&eacute; pour indiquer au compilateur que vous initialisez la variable ##**Type**##. Les valeurs des &eacute;l&eacute;ments de ##**Type**## doivent &ecirc;tre plac&eacute;s entre parenth&egrave;ses et s&eacute;par&eacute;s par des virgules. L'ordre de la liste de valeurs correspond &agrave; l'ordre des &eacute;l&eacute;ments de ##**Type**##, o&ugrave; ##**a**## sera mis &agrave; 12345, ##**b**## &agrave; 12 et ##**c**## &agrave; “Hello”. <br \=""><br \="">{{table columns="" cellpadding="2" cells="<table><tbody> Vous ne pouvez pas initialiser une cha&icircne dynamique au sein d'une d&eacutefinition de ##**Type**## en utilisant cette m&eacutethode. La cha&icircne doit &ecirctre de longueur fixe.;</tbody></table>

<br \=""><br \="">L'initialisation d'une d&eacute;finition de ##**Type**## dans une instruction ##**Dim**## est utile lorsque vous devez disposer d'un ensemble de valeurs initiales pour un ##**Type**##, ou de valeurs qui ne changent pas au cours de l'ex&eacute;cution du programme. Comme les valeurs sont connues au moment de la compilation, le compilateur n'a pas &agrave; perdre des cycles de chargement des valeurs pendant l'ex&eacute;cution.<br \=""><br \=""><div class="fb_header"> Unions 

<br \=""><br \="">Les ##**Union**##s sont similaires aux ##**Type**##s dans leur d&eacute;finition.<br \=""><br \="">%%(freebasic)

Union aUnion<br>    b As Byte<br>    s As Short<br>    i As Integer<br>End Union<br>
##<br><br \="">S'il s'agissait d'un ##**Type**##, vous pourriez acc&eacute;der &agrave; chaque champ de la d&eacute;finition. Pour une ##**Union**## cependant, vous ne pouvez acc&eacute;der qu'&agrave; un seul champ &agrave; un moment donn&eacute;; tous les champs au sein d'une ##**Union**## occupent le m&ecirc;me segment de m&eacute;moire et la taille de l'##**Union**## est la taille du membre le plus important. <br \=""><br \="">Dans ce cas, l'Union occupe quatre octets, la taille d'un ##**Integer**##, avec le champ //b// occupant 1 octet, le champ //s// occupant 2 octets et le champ //i// occupant compl&egrave;tement les 4 octets. Chaque champ commence au premier octet, de sorte que le champ //s// inclurait les champs //b//, et le champ //i// inclurait les deux champs //b// et //s//.<br \=""><br \=""><div class="fb_header"> Des Types dans des Unions 
	<br \=""><br \="">Un bon exemple d'utilisation d'une d&eacute;finition de ##**Type**## dans une ##**Union**## est la d&eacute;finition de ##//Large_Integer//## dans ##//winnt.bi//##. Le type de donn&eacute;e ##//Large_Integer//## est utilis&eacute; dans de nombreuses fonctions Windows au sein de la biblioth&egrave;que C Runtime. L'extrait de code suivant montre la d&eacute;finition de ##//Large_Integer//##.<br \=""><br \="">%%(freebasic)
	Union LARGE_INTEGER<br>    Type<br>        LowPart As DWORD<br>        HighPart As Long<br>    End Type<br>    QuadPart As LONGLONG<br>End Union<br>
	##<br><br \="">Le type de donn&eacute;es ##//Dword//## est d&eacute;fini dans ##//windef.bi//## comme un ##//Uinteger//## FreeBasic et le type ##//Longlong//## est d&eacute;fini comme un ##//Longint//##. Un ##//Long//## est seulement un alias pour le type de donn&eacute;es ##//Integer//##. Souvenez-vous qu'un type occupe des emplacements de m&eacute;moire contigus, de sorte que le champ ##//HighPart//## suit le champ ##//LowPart//## en m&eacute;moire. Comme il s'agit d'une ##**Union**##, le type occupe le m&ecirc;me segment de m&eacute;moire m&ecirc;me que le champ. <br \=""><br \="">Lorsque vous mettez une grande valeur enti&egrave;re dans ##//QuardPart//##, vous d&eacute;finissez aussi en m&ecirc;me temps les valeurs des champs du ##**Type**##, que vous pouvez ensuite extraire comme ##//LowPart//## et ##//HighPart//##. Vous pouvez aussi faire l'inverse; en d&eacute;finissant ##//LowPart//## et ##//HighPart//## du ##**Type**##, vous d&eacute;finissez aussi la valeur du champ ##//QuardPart//##.<br \=""><br \="">Comme vous pouvez le voir, utiliser un ##**Type**## dans une ##**Union**## est un moyen facile de d&eacute;finir ou de r&eacute;cup&eacute;rer des valeurs individuelles d'un composant ##**Type**## de donn&eacute;es sans avoir recours &agrave; beaucoup de code de conversion. La disposition des segments de m&eacute;moire effectue la conversion pour vous, &agrave; condition que les segments de m&eacute;moire aient un sens dans le contexte du composant ##**Type**##. <br \=""><br \="">Dans le cas de ##//Large_Integer//##, ##//LowPart//## et ##//HighPart//## ont &eacute;t&eacute; d&eacute;finis pour renvoyer les valeurs appropri&eacute;es du composant. L'utilisation de valeurs autres que ##//Dword//## et ##//Long//## ne retournera pas de valeurs correctes pour ##//LowPart//## et ##//HighPart//##. Vous devez vous assurer que lorsque vous d&eacute;finissez un ##**Type**## dans une ##**Union**## que vous segmentez correctement la m&eacute;moire du segment ##**Union**## dans la d&eacute;finition du ##**Type**##.<br \=""><br \=""><div class="fb_header"> Unions dans les Types 
<br \=""><br \="">Une ##**Union**## dans une d&eacute;finition de ##**Type**##  est un moyen efficace pour g&eacute;rer les donn&eacute;es quand un champ dans un ##**Type**## ne peut avoir qu'une seule de plusieurs valeurs. L'exemple le plus courant est le type de donn&eacute;es ##//Variant//## dans d'autres langages de programmation.<br \=""><br \="">{{table columns="" cellpadding="2" cells="<table><tbody>FreeBasic n'a pas de type de donn&eacutees ##//Variant//## natif pour le moment. Cependant, en utilisant la syntaxe &eacutetendue de ##**Type**##, vous pouvez cr&eacuteer un type de donn&eacutees ##//Variant//## pour l'utiliser dans vos programmes.;</tbody></table>
<br \=""><br \="">Lorsque vous utilisez une ##**Union**## dans un ##**Type**##, une pratique courante est de cr&eacute;er un champ ##//id//## dans le ##**Type**## qui indique ce que l'##**Union**## contient &agrave; un moment donn&eacute;. L'extrait de code suivant illustre ce concept.<br \=""><br \="">%%(freebasic)

'Union field ids<br>#define vInteger 0<br>#define vDouble 1<br><br>'Define type def with variable data fields<br>Type vType<br>    vt_id As Integer<br>    Union<br>        d As Double<br>        i As Integer<br>    End Union<br>End Type<br>

##<br><br \="">La d&eacute;finition de l'##**Union**## ici est appel&eacute;e une ##**Union**## anonyme car elle n'est pas d&eacute;finie avec un nom. Le champ //vt_id// de la d&eacute;finition du ##**Type**## indique la valeur de l'##**Union**##. Pour initialiser le type vous devez utiliser le code suivant:<br \=""><br \="">%%(freebasic)

Dim myVarianti As vType<br>Dim myVariantd As vType<br><br>myVarianti.vt_id = vInteger<br>myVarianti.i = 300<br><br>myVariantd.vt_id = vDouble<br>myVariantd.d = 356.56<br>

##<br><br \="">//myVarianti// contient une valeur enti&egrave;re donc l'//id// est mis &agrave; //vInteger//. //myVariantd// contient une valeur //double// donc l'//id// est mis &agrave; //vDouble//. Si vous cr&eacute;ez une sous-routine qui a un param&egrave;tre //vType//, vous pouvez examiner le champ //vt_type// pour d&eacute;terminer si c'est un nombre entier ou double qui a &eacute;t&eacute; pass&eacute; &agrave; la sous-routine.<br \=""><br \="">{{table columns="" cellpadding="2" cells="<table><tbody> Vous ne pouvez pas utiliser des cha&icircnes de dynamiques au sein d'une ##**Union**##.;</tbody></table>

<br \=""><br \="">Utiliser une combinaison d'##**Union**##s et de ##**Type**##s dans un programme vous permet de concevoir des types de donn&eacute;es qui ont beaucoup de souplesse, mais il faut veiller &agrave; utiliser correctement les donn&eacute;es construites. Une mauvaise utilisation de ces types de donn&eacute;es peut entra&icirc;ner des bogues tr&egrave;s difficiles &agrave; trouver. Les avantages toutefois, l'emportent sur les risques et une fois ma&icirc;tris&eacute;s, ce sont des outils de programmation puissants.<br \="">

On the other hand you may not need to update the type as in the following code fragment.

%%(freebasic)
Sub PrintEmployeeRecord(Emp as EmployeeType)
	.
	.
	.
End Sub
%%

In this sub you are just printing the employee record to the screen or a printer and do not need to change anything in the type variable. Here the default ##Byval## is used which passes a copy  of the employee record to the sub rather than a reference to the variable. By using ##Byval## in this case, you won't accidentally change something in the type variable that you didn't intend to change.

You should only use ##Byref## if you intend to change the parameter data. It is much safer to use ##Byval## in cases where you need to have the parameter data, but want to prevent accidental changes to the data. These accidental changes generate hard-to-find bugs in your program.

=== Types Within Types ===

In addition to the intrinsic data types, type fields can also be based on a type definition. Why would you want to do this? One reason is data abstraction. The more general your data structures, the more you can reuse the code in other parts of your program. The less code you have to write, the less chance of errors finding their way into your program. 

Using the ##//Employee//## example, suppose for a moment that you needed to track more dept information than just the department id. You might need to keep track of the department manager, the location of the department, such as the floor or the building, or the main telephone number of the department. By putting this information into a separate type definition, you could use this information by itself, or as part of another type definition such as the Employee type. By generalizing your data structures, your program will be smaller, and much more robust.

Using a type within a type is the same as using one of the intrinsic data types. The following code snippets illustrates an expanded department type and an updated employee type.

%%(freebasic)
Type DepartmentType
	id As integer
	managerid as integer
	floor as integer
End Type		

Type EmployeeType
	fname As String * 10
   	lname As String * 10
		empid As Integer
		dept As DepartmentType
End Type

Dim Employee As EmployeeType
%%

Notice that in the Employee definition the dept field is defined as ##//""DepartmentType""//## rather than as one of the intrinsic data types. To access the department information within the ##//Employee//## type, you use the compound dot notation to access the dept fields.

%%(freebasic)
Employee.dept.id = 24
Employee.dept.managerid = 1012
Employee.dept.floor = 13
%%

The top level of the type definition is ##//Employee//##, so that reference comes first. Since dept is now a type definition as well, you need to use the dept  identifier to access the individual fields within the ##//""DepartmentType""//##. ##//Employee//## refers to the ##//employee//## type, ##//dept//## refers to the department type and ##//id//##, ##//managerid//## and ##//floor//## are fields within the ##//department//## type.

You can even carry this further, by including a type within a type within a type. You would simply use the dot notation of the additional type level as needed. While there is no limit on the levels of nested type definitions, it gets to be a bit unwieldy when used with several levels.

=== With and Nested Types ===

You can also use the ##With##-##End With## block with nested types, by nesting the ##With## block, as illustrated in the following code snippet.

%%(freebasic)
With Employee
   	.fname = "Susan"
		.lname = "Jones"
		.empid = 1001
		With .dept
	    	.id = 24
	    	.managerid = 1012
	    	.floor = 13
		End With
End With
%%

Notice that the second ##With## uses the dot notation, ##.//dept//##, to specify the next level of type definitions. When using nested ##With## blocks, be sure that you match all the ##End With## statements with their correct ##With## statements to avoid a compile error.

=== Type Assignments ===

Extending the idea of data abstraction further, it would be nice to be able to separate the initialization of the department type from the initialization of the employee type. By separating the two functions, you can easily add additional department information as needed. This is where you can use type assignments. 

Just as you can assign one intrinsic data type to another, you can assign one type variable to another type variable, providing they share the same type definition.

The following code snippet abstracts the department initialization function and assigns the result to the department type within the ##//Employee//## type.

%%(freebasic)
'This function will init the dept type and return it to caller
Function InitDept(deptid As Integer) As DepartmentType
	Dim tmpDpt As DepartmentType

	Select Case deptid
	    Case 24 'dept 24
		With tmpDpt
	        		.id = deptid
	        		.managerid = 1012
	        		.floor = 13
	    	End With
	    Case 48 'dept 48
	     	With tmpDpt
	        		.id = deptid
	        		.managerid = 1024
	        		.floor  = 12
	        	End With
	    Case Else 'In case a bad department id was passed
	        	With tmpDpt
	        		.id = 0
	        		.managerid  = 0
	        		.floor  = 0
	        	End With
	End Select

	'Return the dept info
	Return tmpDpt
End Function

'Create an instance of the type
Dim Employee As EmployeeType

'Initialize the Employee type
With Employee
	.fname = "Susan"
	.lname = "Jones"
	.empid = 1001
	.dept = InitDept(24) 'get dept info
End With
%%

As you can see in the snippet, the dept field of the ##//employee//## type is initialized with a function call. The ##//""InitDept""//## function returns a ##//""DepartmentType""//## and the compiler will assign that type to the dept field of the ##//Employee//## record. 

By just adding a simple function to the program, you have made the program easier to maintain. If a new department is created, you can simply update the ##//""InitDept""//## function with the new department information, recompile and the program is ready to go.

=== Bit Fields ===

There is yet another data type that can be used in type definitions, the bit field. Bit fields are defined as ##//variable_name//: bits As //""DataType""//##. The variable name must be followed with a colon, the number of bits, followed by the data type. Only integer data types are allowed within a bit field. Bit fields are useful when you need to keep track of boolean type information. A bit can be either ##0## or ##1##, which may represent Yes or No, On or Off or even Black and White. 

The following code snippet illustrates a bit field definition.

%%(freebasic)
Type BitType
	b1: 1 As Integer
	b2: 4 As Integer
End Type
%%

##//b1//## is defined as a single bit, and ##//b2//## is defined as four bits. You initialize the bitfields by passing the individual bits to the type fields.

%%(freebasic)
myBitType.b1 = 1
myBitType.b2 = 1101
%%

The data type of the bit field determines how many bits you can declare in a bit field. Since an ##integer## is 32 bits long, you could declare up to 32 bits in the field. However, in most cases you would declare a single bit for each field, and use a number of fields to define the bit masking that you wish to use. Using a single bit simplifies the coding you need to do to determine if a bit is set or cleared and allows you to easily identify what a bit means within the type definition.

=== The Field Property ===

When you create a variable of a type definition, the type is padded in memory. The padding allows for faster access of the type members since the type fields are aligned on a 4 byte or Word boundary. However, this can cause problems when trying to read a type record from a file that is not padded. You can use the use ##field## property to change the padding of a type definition. 

The ##field## keyword is used right after the type name and can have the values ##1##, for 1 byte alignment (no padding), ##2## for 2 byte alignment and ##4## for 4 byte alignment. To define a type with no padding you would use the following syntax.

%%(freebasic)
Type myType field = 1
 	v1 As Integer
	v2 As Byte
End Type
%%

For 2 byte alignment you would use ##field = 2##. If no ##field = //property//## is assigned, then the padding will be ##4## bytes. If you are reading a type definition created by ""FreeBASIC"" using the default alignment, then you do not need to use the ##field## property.

{{table columns="1" cellpadding="2" cells=" If you are reading a ""Quick Basic"" type record, then you will need to use ##field = 1##, as QB used byte alignment by default."}}

=== Type Initialization ===

You can initialize a type definition when you dimension the type just as you can any of the intrinsic variables. The following code snippet illustrates the syntax.

%%(freebasic)
Type aType
		a As Integer
		b As Byte
		c As String * 10
End Type

Dim myType As aType => (12345, 12, "Hello")
%%

In the ##Dim## statement, the arrow operator ##=>## is used to tell the compiler that you are initializing the type variable. The type element values must be enclosed in parenthesis, and separated by commas. The order of the value list corresponds to the order of the type elements, where ##//a//## will be set to ##12345##, ##//b//## to ##12## and ##//c//## to ##"Hello"##.

{{table columns="1" cellpadding="2" cells=" You cannot initialize a dynamic string within a type definition using this method. The string must be fixed length."}}

Initializing a type definition in a ##Dim## statement is useful when you need to have a set of initial values for a type, or values that will not change during program execution. Since the values are known at compile time, the compiler can doesn't have to spend cycles loading the values during runtime.

==== Unions ====

Unions look similar to Types in their definition.

%%(freebasic)
Union aUnion
	b As Byte
	s As Short
	i As Integer
End Union
%%

If this were a ##Type##, you could access each field within the definition. For a ##Union## however, you can only access one field at any given time; all the fields within a ##Union## occupy the same memory segment, and the size of the ##Union## is the size of the largest member. 

In this case, the ##Union## would occupy four bytes, the size of an ##Integer##, with the ##//b//## field occupying 1 byte, the ##//s//## field occupying 2 bytes, and the ##//i//## occupying the full 4 bytes. Each field starts at the first byte, so the ##//s//## field would include the ##//b//## field, and the ##//i//## field would include both the ##//b//## and ##//s//## fields.

=== Types in Unions ===

A good example of using a type definition in a union is the ##//Large_Integer//## definition found in ##winnt.bi##. The ##//Large_Integer//## data type is used in a number of Windows functions within the C Runtime Library. The following code snippet shows the ##//Large_Integer//## definition.

%%(freebasic)
union LARGE_INTEGER
	type
		LowPart as DWORD
		HighPart as LONG
	end type
	QuadPart as LONGLONG
end union
%%

The ##//Dword//## data type is defined in ##windef.bi## as a ""FreeBASIC"" ##Uinteger##, and the ##//Longlong//## type is defined as a ##//Longint//##. A Long is just an alias for the integer data type. Remember that a type occupies contiguous memory locations, so the ##//""HighPart""//## field follows the ##//""LowPart""//## part field in memory. Since this is a union, the type occupies the same memory segment as the ##//""QuadPart""//## field. 

When you set ##//""QuardPart""//## to a large integer value, you are also setting the values of the type fields, which you can then extract as the ##//""LowPart""//##and ##//""HighPart""//##. You can also do the reverse; that is by setting the ##//""LowPart""//## and ##//""HighPart""//## of the type, you are setting the value of the ##//""QuadPart""//## field.

As you can see, using a type within a union is an easy way to set or retrieve individual values of a component data type without resorting to a lot of conversion code. The layout of the memory segments does the conversion for you, providing that the memory segments make sense within the context of the component type. 

In the ##//Large_Integer case//##, the ##//""LowPart""//## and ##//""HighPart""//## have been defined to return the appropriate component values. Using values other than ##//Dword//## and ##//Long//## would not return correct values for ##//""LowPart""//## and ##//""HighPart""//##. You need to make sure when defining a type within a union, you are segmenting the union memory segment correctly within the type definition.

=== Unions in Types ===

A union within a type definition is an efficient way to manage data when one field within a type can only one of several values. The most common example of this is the Variant data type found in other programing languages.

{{table columns="1" cellpadding="2" cells=" FreeBASIC does not have a native Variant data type at this time. However, by using the extended Type syntax, you could create a Variant data type for use in your program."}}

When using a ##Union## within a type it is common practice to create an ##//id//## field within the type that indicates what the union contains at any given moment. The following code snippet illustrates this concept.

%%(freebasic)
'Union field ids
#define vInteger 0
#define vDouble 1

'Define type def with variable data fields
Type vType
	vt_id As Integer
	Union
	    d As Double
	    i As Integer
	End Union
End Type
%%

The union definition here is called an anonymous union since it isn't defined with a name. The ##//vt_id//## field of the type definition indicates the value of the union. To initialize the type you would use code like the following.

%%(freebasic)
Dim myVarianti As vType
Dim myVariantd As vType

myVarianti.vt_id = vInteger
myVarianti.i = 300

myVariantd.vt_id = vDouble
myVariantd.d = 356.56
%%

##//myVarianti//## contains an ##integer## value so the ##//id//## is set to ##//""vInteger""//##. ##//""myVariantd""//## contains a ##double## so the id is set to ##//""vDouble""//##. If you were to create a subroutine that had a ##//""vType""//## parameter, you could examine the ##//vt_type//## field to determine whether an ##//integer//## or ##//double//## had been passed to the subroutine.

{{table columns="1" cellpadding="2" cells=" You cannot use dynamic strings within a union."}}

Using a combination of ##//unions//## and ##//type//##s within a program allows you to design custom data types that have a lot of flexibility, but care must be taken to ensure that you are using the data constructs correctly. Improper use of these data types can lead to hard-to-find bugs. The benefits however, out-weigh the risks and once mastered, are a powerful programming tool.
