{{fbdoc item="title" value="Introduction to the Type Def"}}----
//Ecrit par [[WikiRick rdc]]//

Il y a des moments, lors de la création d'un programme, où l'on souhaite définir une structure globale comme un enregistrement personnel ou un ennemi dans un jeu. Alors que vous pouvez faire cela en utilisant des types de données individuelles, cela est difficile à gérer dans un programme. Les types de données composites vous permettent de grouper des éléments de données connexes dans une structure unique qui peut être manipulée comme une seule entité. FreeBASIC offre deux types de données composites, ##**Type**## et ##**Union**##. 

=== Types ===

FreeBASIC vous permet de grouper plusieurs types de données dans une structure unifiée appelée une définition de ##**Type**## que vous pouvez utiliser pour décrire ces structures de données agrégées.

La structure de base d'une définition de ##**Type**## est:

%%(freebasic)
Type typename
	var definition
	var definition
	...
End Type
%%

Le bloc ##**Type ... Type-End**## définit la portée de la définition. Vous définissez les éléments de la structure ##**Type**## de la même manière que vous utilisez le mot clé ##**Dim**##, sans utiliser ##**Dim**##. L'extrait de code suivant montre comment construire un ##**Type**## d'##//Employee//##.

%%(freebasic)
Type EmployeeType
	fname As String * 10
	lname As String * 10
	empid As Integer
	dept As Integer
End Type	
%%

Vous pouvez utiliser n'importe quel type de données comme élément de données, y compris des pointeurs et d'autres définitions de ##**Type**##. Lorsque vous créez la définition d'un ##**Type**##, comme dans l'exemple ci-dessus, vous êtes juste en train de créer un modèle pour le compilateur. Afin d'utiliser la définition du ##**Type**##, vous devez créer une variable de ce ##**Type**##, comme le montre l'extrait de code suivant.

%%(freebasic)
Dim Employee As EmployeeType
%%

Lorsque vous avez créé une variable de ce ##**Type**##, vous pouvez accéder à chaque élément dans le ##**Type**## l'aide de la notation pointée  ##//var_name.field_name//##.  

En utilisant l'exemple ci-dessus, pour accéder au champ ##//fname//## vous pouvez utiliser: 

%%(freebasic)
Employee.fname = "Susan"
%%

=== Utiliser With ===

Pour accéder à des champs multiples au même moment, vous pouvez utiliser le bloc ##**With-End With**##. Le code suivant montre comment utiliser le bloc ##**With**## avec l'exemple ci-dessus.

%%(freebasic)
With Employee
	.fname = "Susan"
	.lname = "Jones"
	.empid = 1001
		.dept = 24
End With	
%%

Le compilateur lie automatiquement la variable ##//Employee//## avec les éléments de données individuels du bloc. Non seulement cela signifie que vous n'avez pas à écrire beaucoup plus, mais la structure est optimisée et un peu plus rapide que l'utilisation de la notation pointée complète.

=== Transmission de Types aux sous-routines et fonctions ===

Un avantage de l'utilisation de ##**Type**## dans votre programme est que vous pouvez passer la structure à un sous-programme ou une fonction et opérer sur la structure dans son ensemble. Le fragment de code suivant montre une définition partielle de sous-routine.

%%(freebasic)
Sub UpdateEmployeeDept(Byref Emp as EmployeeType)
	.
	.
	.
End Sub
%%

Notez que le paramètre est qualifié avec ##**Byref**##. Ceci est important puisque vous voulez mettre à jour ce ##**Type**## dans la sous-routine. Il existe deux modes de passage de paramètres en FreeBASIC: ##**ByRef**## et ##**Byval**##. 

== Byref et Byval: Présentation rapide ==

##**ByRef**## et ##**Byval**## indiquent au compilateur comment passer une référence à une sous-routine ou une fonction. Lorsque vous utilisez ##**ByRef**##, ou //Par Référence//, vous passez un pointeur de référence au paramètre et toutes les modifications que vous apportez au paramètre à l'intérieur de ##**Sub**## ou ##**Function**## sera reflétée dans la variable réelle qui a été passée. En d'autres termes, le paramètre ##**ByRef**## pointe sur la variable réelle dans la mémoire.

##**Byval**##, ou //Par Valeur//, d'autre part fait une copie du paramètre et toutes les modifications apportées à l'intérieur de ##**Sub**## ou ##**Function**## sont locales et ne seront pas reflétées dans la variable réelle qui a été passée. Le paramètre ##**Byval**## pointe sur une copie de la variable et non sur la variable réelle, elle-même.

Par défaut FreeBASIC .17 passe les paramètres en utilisant ##**Byval**##. Pour modifier un paramètre passé, vous devez à spécifier le qualificatif ##**ByRef**##. Dans cet exemple, la sous-routine met à jour le //department id// du //Type employee//, donc le paramètre est qualifié par ##**ByRef**## pour que la sous-routine puisse mettre à jour le champ //dept// de la variable.

En revanche vous n'avez pas besoin de mettre à jour le ##**Type**## comme dans le fragment de code suivant.

%%(freebasic)
Sub PrintEmployeeRecord(Emp as EmployeeType)
	.
	.
	.
End Sub
%%

Dans cette sous-routine on affiche seulement l'enregistrement de //employee// à l'écran ou on l'envoie vers l'imprimante et on n'a pas a changé quoi que ce soit dans la variable ##**Type**##. Ici c'est ##**Byval**## par défaut qui est utilisé pour passer une copie de l'enregistrement de //employee// à la sous-routine au lieu d'une référence vers la variable. En utilisant ##**Byval**##, dans ce cas, vous évitez de changer quelque chose accidentellement dans la variable ##**Type**##, ce que vous ne désiriez pas.

Vous ne devez utiliser ##**Byref**## que si vous avez l'intention de modifier les données des paramètres. Il est beaucoup plus plus sûr d'utiliser ##**Byval**## dans les cas où vous devez avoir les données des paramètres, mais que vous souhaitez éviter toute modification accidentelle de ces données. Ces modifications accidentelles génèrent des bugs difficiles à trouver dans les programmes.

=== Types dans les Types ===

En plus des types de données intrinsèques, un champ de Type peut également être basé sur une définition de Type. Pourquoi vouloir faire cela? Une des raisons est l'abstraction de données. Plus vos structures de données seront générales, plus vous pourrez en réutiliser le code dans d'autres parties de votre programme. Moins vous avez à écrire de code, moins les erreurs auront de chance de trouver le chemin de vos programmes. 

En utilisant l'exemple d'##//Employee//##, supposons un instant que vous ayez besoin de plus d'informations ##//dept//## que seulement ##//department id//##. Vous pourriez avoir besoin de garder une trace de ##//department manager//##, l'emplacement du département, comme le ##//floor//## (étage) ou le bÃ¢timent ou le numéro de téléphone principal du département. En mettant ces informations dans une définition de ##**Type**## distincte, vous pouvez utiliser cette information par elle-même ou comme partie d'une autre définition de ##**Type**## comme ##//Employee//##. En généralisant vos structures de données, votre programme sera plus petit et beaucoup plus robuste.

L'utilisation d'un ##**Type**## dans un ##**Type**## est identique à celle de l'un des types de données intrinsèques. Les extraits de code suivant illustrent un ##**Type**## ##//department//## étendu et un ##**Type**## ##//employee//## mis à jour.

%%(freebasic)
Type DepartmentType
	id As integer
	managerid as integer
	floor as integer
End Type		

Type EmployeeType
	fname As String * 10
   	lname As String * 10
		empid As Integer
		dept As DepartmentType
End Type

Dim Employee As EmployeeType
%%

Notez que dans la définition de ##//Employee//## le champ ##//dept//## est défini comme ##//DepartmentType//## au lieu d'un des types de données intrinsèques. Pour accéder à l'information ##//department//## dans le ##**Type**## ##//Employee//##, on utilise la notation pointée composée pour accéder aux champs de ##//dept//##:

%%(freebasic)
Employee.dept.id = 24
Employee.dept.managerid = 1012
Employee.dept.floor = 13
%%

Le plus haut niveau de la définition du ##**Type**## est ##//Employee//##, donc sa référence vient en premier. Comme ##//dept//## est maintenant une définition de ##**Type**##, vous devez utiliser l'identifieur de ##//dept//## pour accéder aux champs individuels de ##//DepartmentType//##. ##//Employee//## se réfère au ##**Type**## ##//employee//##, ##//dept//## se réfère au ##**Type**## ##//department//## et ##//id//##, ##//managerid//## et ##//floor//## sont des champs du ##**Type**## ##//department//##.

Vous pouvez même faire davantage, notamment avec un ##**Type**## dans un ##**Type**## dans un ##**Type**##. Vous utiliserez simplement la notation pointée du niveau de type supplémentaires au besoin. Bien qu'il n'y ait pas de limite au niveau des définitions de types imbriqués, cela devient un peu lourd lors de l'utilisation de nombreux niveaux.

=== With et les Types imbriqués ===

Vous pouvez aussi utiliser un bloc ##**With-End With**## avec des ##**Type**##s imbriqués, en imbriquant le bloc ##**With**##, comme illustré dans l'exemple ci-dessous.

%%(freebasic)
With Employee
   	.fname = "Susan"
		.lname = "Jones"
		.empid = 1001
		With .dept
	    	.id = 24
	    	.managerid = 1012
	    	.floor = 13
		End With
End With
%%

Notez que le second ##**With**## utilise la notation pointée, ##//.dept//##, pour spécifier le niveau suivant de définition de ##**Type**##. Quand vous utilisez des blocs ##**With**## imbriqués, assurez-vous que toutes les déclarations ##**End With**## correspondent correctement à une déclaration ##**With**## sinon il y aura un message d'erreur lors de la compilation.

=== Affectations de Type ===

Pour aller plus loin dans l'extension de l'idée d'abstraction des données, il serait intéressant de séparer l'initialisation du ##**Type**## ##//department//## de celle du ##**Type**## ##//employee//##. En séparant les deux fonctions, vous pouvez facilement ajouter des informations supplémentaires à ##//department//## en fonction de vos besoins. C'est là que vous pouvez utiliser des assignations de ##**Type**##. 

Tout comme vous pouvez affecter un type intrinsèque des données à un autre, vous pouvez affecter une variable de ##**Type**## à une autre variable de ##**Type**##, à condition qu'elles aient la même définition de ##**Type**##.

Les extraits de code suivants résument la fonction d'initialisation de ##//department//## et attribue le résultat au ##**Type**## ##//department//## dans le ##**Type**## ##//Employee//##.

%%(freebasic)
'This function will init the dept type and return it to caller
Function InitDept(deptid As Integer) As DepartmentType
	Dim tmpDpt As DepartmentType

	Select Case deptid
	    Case 24 'dept 24
		With tmpDpt
	        		.id = deptid
	        		.managerid = 1012
	        		.floor = 13
	    	End With
	    Case 48 'dept 48
	     	With tmpDpt
	        		.id = deptid
	        		.managerid = 1024
	        		.floor  = 12
	        	End With
	    Case Else 'In case a bad department id was passed
	        	With tmpDpt
	        		.id = 0
	        		.managerid  = 0
	        		.floor  = 0
	        	End With
	End Select

	'Return the dept info
	Return tmpDpt
End Function

'Create an instance of the type
Dim Employee As EmployeeType

'Initialize the Employee type
With Employee
	.fname = "Susan"
	.lname = "Jones"
	.empid = 1001
	.dept = InitDept(24) 'get dept info
End With
%%

Comme vous pouvez le voir dans l'extrait ci-dessus, le champ ##//dept//## du ##**Type**## ##//employee//## est initialisé par un appel à une fonction. La fonction ##//InitDept//## retourne un ##//DepartmentType//## et le compilateur affectera ce ##**Type**## au champ de l'enregistrement ##//Employee//##. 

Par le simple ajout d'une fonction au programme, vous avez rendu le programme plus facile à maintenir. Si un nouveau ##//department//## est créé, vous pouvez simplement mettre à jour la fonction ##//InitDept//## avec le nouveeau ##//department//##, recompiler et le programme est prêt à redémarrer.

=== Champs de bits ===

Il y a encore un autre ##**Type**## de données qui peuvent être utilisés dans les définitions de ##**Type**##, le champ de bits. Les champs de bits sont définis ainsi ##//variable_name: bits As DataType//##.Le nom de la variable doit être suivi de deux-points (:), le nombre de bits, suivi par le type de données. Seuls les données de ##**Type**## entier sont autorisées dans un champ de bits. Les champs de bits sont utiles lorsque vous avez besoin de garder une trace d'informations de type booléen. Un bit peut avoir les valeurs 0 ou 1, ce qui peut représenter Oui ou Non, Marche ou Arrêt ou même Noir et Blanc. 

L'extrait de code suivant illustre la définition d'un champ de bits.

%%(freebasic)
Type BitType
	b1: 1 As Integer
	b2: 4 As Integer
End Type
%%

b1 est défini comme bit unique et b2 comme ayant quatre bits. Vous initialisez les champs de bits en passant les bits individuels aux champs du ##**Type**##.

%%(freebasic)
myBitType.b1 = 1
myBitType.b2 = 1101
%%

Le type de données du champ de bits détermine le nombre de bits que vous pouvez déclarer, dans un champ de bits. Puisqu' un entier à une longueur de 32 bits, vous pouvez déclarer jusqu'à 32 bits dans le champ. Cependant, dans la plupart des cas, vous allez déclarer un seul bit pour chaque champ et utiliser un certain nombre de champs afin de définir le masque de bits que vous souhaitez utiliser. Utiliser un bit unique simplifie le codage que vous devez éléborer pour déterminer si un bit est activé ou désactivé et vous permet d'identifier facilement ce qu'un bit signifie dans la définition du ##**Type**##.

=== La propriété Field ===

Lorsque vous créez une variable d'un ##**Type**## défini, le ##**Type**## est ##//bourré//## en mémoire. Le ##//bourrage//## permet un accès plus rapide des membres de ##**Type**## puisque ses champs sont alignés dans les limites d'un ##//Word//## de 4 octets. Cependant, cela peut causer des problèmes lorsque vous essayez de lire un enregistrement de ##**Type**## à partir d'un fichier qui n'est pas ##//bourré//##. Vous pouvez utiliser la propriété ##**Field**## d'un champ pour changer le stockage en mémoire de la définition du ##**Type**##. 

Le mot-clef ##**Field**## est utilisé juste à droite du nom du ##**Type**## et peut avoir les valeurs 1, pour un alignement sur 1 octet (sans bourrage), 2 un alignement sur 2 octets et 4 un alignement sur 4 octets. Pour définir un ##**Type**## sans ##//bourrage//## vous utiliserez la syntaxe suivante.

%%(freebasic)
Type myType field = 1
 	v1 As Integer
	v2 As Byte
End Type
%%

Pour un alignement sur 2 octets utilisez ##**Field**## = 2. Si aucune propriété ##**Field =**## n'est attribuée, le ##//bourrage//## est alors de 4 octets. Si vous lisez une définition de ##**Type**## créée sous FreeBASIC en utilisant l'alignement par défaut, vous n'avez pas besoin, dans ce cas, d'utiliser la propriété ##**Field**##.

{{table columns="1" cellpadding="2" cells="Si vous lisez un enregistrement Quick Basic d'un ##**Type**##, alors vous devez utiliser ##**Field**## = 1, car QB utilisait l'alignement des octets par défaut."}}

=== Initialisation de Type ===

Vous pouvez initialiser une définition de ##**Type**## lorsque vous dimensionnez le ##**Type**## comme vous le feriez avec une variable intrinsèque. L'extrait de code suivant illustre la syntaxe.

%%(freebasic)
Type aType
		a As Integer
		b As Byte
		c As String * 10
End Type

Dim myType As aType => (12345, 12, "Hello")
%%

Dans l'instruction ##**Dim**##, l'opérateur flèche //+>// est utilisé pour indiquer au compilateur que vous initialisez la variable ##**Type**##. Les valeurs des éléments de ##**Type**## doivent être placés entre parenthèses et séparés par des virgules. L'ordre de la liste de valeurs correspond à l'ordre des éléments de ##**Type**##, où ##**a**## sera mis à 12345, ##**b**## à 12 et ##**c**## à â€œHelloâ€. 

{{table columns="1" cellpadding="2" cells="Vous ne pouvez pas initialiser une chaîne dynamique au sein d'une définition de ##**Type**## en utilisant cette méthode. La chaîne doit être de longueur fixe."}}

L'initialisation d'une définition de ##**Type**## dans une instruction ##**Dim**## est utile lorsque vous devez disposer d'un ensemble de valeurs initiales pour un ##**Type**##, ou de valeurs qui ne changent pas au cours de l'exécution du programme. Comme les valeurs sont connues au moment de la compilation, le compilateur n'a pas à perdre des cycles de chargement des valeurs pendant l'exécution.

=== Unions ===

Les ##**Union**##s sont similaires aux ##**Type**##s dans leur définition.

%%(freebasic)
Union aUnion
	b As Byte
	s As Short
	i As Integer
End Union
%%

S'il s'agissait d'un ##**Type**##, vous pourriez accéder à chaque champ de la définition. Pour une ##**Union**## cependant, vous ne pouvez accéder qu'à un seul champ à un moment donné; tous les champs au sein d'une ##**Union**## occupent le même segment de mémoire et la taille de l'##**Union**## est la taille du membre le plus important. 

Dans ce cas, l'Union occupe quatre octets, la taille d'un ##**Integer**##, avec le champ //b// occupant 1 octet, le champ //s// occupant 2 octets et le champ //i// occupant complètement les 4 octets. Chaque champ commence au premier octet, de sorte que le champ //s// inclurait les champs //b//, et le champ //i// inclurait les deux champs //b// et //s//.

=== Des Types dans des Unions ===

Un bon exemple d'utilisation d'une définition de ##**Type**## dans une ##**Union**## est la définition de ##//Large_Integer//## dans ##//winnt.bi//##. Le type de donnée ##//Large_Integer//## est utilisé dans de nombreuses fonctions Windows au sein de la bibliothèque C Runtime. L'extrait de code suivant montre la définition de ##//Large_Integer//##.

%%(freebasic)
union LARGE_INTEGER
	type
		LowPart as DWORD
		HighPart as LONG
	end type
	QuadPart as LONGLONG
end union
%%

Le type de données ##//Dword//## est défini dans ##//windef.bi//## comme un ##//Uinteger//## FreeBASIC et le type ##//Longlong//## est défini comme un ##//Longint//##. Un ##//Long//## est seulement un alias pour le type de données ##//Integer//##. Souvenez-vous qu'un type occupe des emplacements de mémoire contigus, de sorte que le champ ##//HighPart//## suit le champ ##//LowPart//## en mémoire. Comme il s'agit d'une ##**Union**##, le type occupe le même segment de mémoire même que le champ. 

Lorsque vous mettez une grande valeur entière dans ##//QuardPart//##, vous définissez aussi en même temps les valeurs des champs du ##**Type**##, que vous pouvez ensuite extraire comme ##//LowPart//## et ##//HighPart//##. Vous pouvez aussi faire l'inverse; en définissant ##//LowPart//## et ##//HighPart//## du ##**Type**##, vous définissez aussi la valeur du champ ##//QuardPart//##.

Comme vous pouvez le voir, utiliser un ##**Type**## dans une ##**Union**## est un moyen facile de définir ou de récupérer des valeurs individuelles d'un composant ##**Type**## de données sans avoir recours à beaucoup de code de conversion. La disposition des segments de mémoire effectue la conversion pour vous, à condition que les segments de mémoire aient un sens dans le contexte du composant ##**Type**##. 

Dans le cas de ##//Large_Integer//##, ##//LowPart//## et ##//HighPart//## ont été définis pour renvoyer les valeurs appropriées du composant. L'utilisation de valeurs autres que ##//Dword//## et ##//Long//## ne retournera pas de valeurs correctes pour ##//LowPart//## et ##//HighPart//##. Vous devez vous assurer que lorsque vous définissez un ##**Type**## dans une ##**Union**## que vous segmentez correctement la mémoire du segment ##**Union**## dans la définition du ##**Type**##.

=== Unions dans les Types ===

Une ##**Union**## dans une définition de ##**Type**##  est un moyen efficace pour gérer les données quand un champ dans un ##**Type**## ne peut avoir qu'une seule de plusieurs valeurs. L'exemple le plus courant est le type de données ##//Variant//## dans d'autres langages de programmation.

{{table columns="1" cellpadding="2" cells="FreeBASIC n'a pas de type de données Variant natif pour le moment. Cependant, en utilisant la syntaxe étendue de Type, vous pouvez créer un type de données Variant pour l'utiliser dans vos programmes."}}

Lorsque vous utilisez une ##**Union**## dans un ##**Type**##, une pratique courante est de créer un champ ##//id//## dans le ##**Type**## qui indique ce que l'##**Union**## contient à un moment donné. L'extrait de code suivant illustre ce concept.

%%(freebasic)
'Union field ids
#define vInteger 0
#define vDouble 1

'Define type def with variable data fields
Type vType
	vt_id As Integer
	Union
	    d As Double
	    i As Integer
	End Union
End Type
%%

La définition de l'##**Union**## ici est appelée une ##**Union**## anonyme car elle n'est pas définie avec un nom. Le champ //vt_id// de la définition du ##**Type**## indique la valeur de l'##**Union**##. Pour initialiser le type vous devez utiliser le code suivant:

%%(freebasic)
Dim myVarianti As vType
Dim myVariantd As vType

myVarianti.vt_id = vInteger
myVarianti.i = 300

myVariantd.vt_id = vDouble
myVariantd.d = 356.56
%%

//myVarianti// contient une valeur entière donc l'//id// est mis à //vInteger//. //myVariantd// contient une valeur //double// donc l'//id// est mis à //vDouble//. Si vous créez une sous-routine qui a un paramètre //vType//, vous pouvez examiner le champ //vt_type// pour déterminer si c'est un nombre entier ou double qui a été passé à la sous-routine.

{{table columns="1" cellpadding="2" cells="Vous ne pouvez pas utiliser des chaînes de dynamiques au sein d'une Union."}}

Utiliser une combinaison d'##**Union**##s et de ##**Type**##s dans un programme vous permet de concevoir des types de données qui ont beaucoup de souplesse, mais il faut veiller à utiliser correctement les données construites. Une mauvaise utilisation de ces types de données peut entraîner des bogues très difficiles à trouver. Les avantages toutefois, l'emportent sur les risques et une fois maîtrisés, ce sont des outils de programmation puissants.
