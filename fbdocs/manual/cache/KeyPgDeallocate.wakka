{{fbdoc item="title" value="DEALLOCATE"}}----
Lib&egrave;re la m&eacute;moire pr&eacute;c&eacute;demment allou&eacute;e

{{fbdoc item="syntax"}}##
	[[KeyPgDeclare declare]] [[KeyPgSub sub]] **Deallocate** [[KeyPgCdecl cdecl]] ( [[KeyPgByval byval]] //pointer// [[KeyPgAs as]] [[KeyPgAny any]] [[KeyPgPtr ptr]] )
##
{{fbdoc item="usage"}}##
	**Deallocate**( //pointer// )
##
{{fbdoc item="param"}}
	##//pointer//##
		l'adresse de la m&eacute;moire tampon pr&eacute;c&eacute;demment allou&eacute;e.

{{fbdoc item="desc"}}
	Cette proc&eacute;dure lib&egrave;re de la m&eacute;moire qui a &eacute;t&eacute; pr&eacute;c&eacute;demment allou&eacute;e avec ##[[KeyPgAllocate Allocate]]##. ##//pointer//## doit &ecirc;tre un pointeur valide. Apr&egrave;s le retour de proc&eacute;dure, ##//pointer//## sera consid&eacute;r&eacute; comme invalide  (pointant vers une adresse m&eacute;moire invalide) et son utilisation se traduira par un comportement non d&eacute;fini.

**##Deallocate##** est un alias pour la biblioth&egrave;que d'ex&eacute;cution C **##libre##**, elle n'est donc pas garantie d'&ecirc;tre "thread-safe" sur toutes les plates-formes.

{{fbdoc item="ex"}}
L'exemple suivant montre comment lib&eacute;rer de la m&eacute;moire pr&eacute;c&eacute;demment allou&eacute;e. Notez que le pointeur a la valeur nulle apr&egrave;s la d&eacute;sallocation:

{{fbdoc item="filename" value="examples/manual/memory/deallocate.bas"}}%%(freebasic)
sub DeallocateExample1()
   dim as integer ptr integerPtr = allocate( len( integer ) )  '' initialize pointer to
	                                                           '' new memory address

   *integerPtr = 420                                     '' use pointer
   print *integerPtr

   deallocate( integerPtr )                              '' free memory back to system
   integerPtr = 0                                        '' and zero the pointer
end sub

   DeallocateExample1()
   end 0
%%

Bien que, dans ce cas, ce ne soit pas n&eacute;cessaire -##// puisque 1&deg;) le pointeur n'est pas une r&eacute;f&eacute;rence &agrave; un autre pointeur, 2&deg;) aucun autre pointeur ne pointe sur la m&eacute;moire lib&eacute;r&eacute;e et 3&deg;) la fonction quitte imm&eacute;diatement apr&egrave;s //##- fixer le pointeur &agrave; NULL est une bonne habitude &agrave; prendre. Si la fonction lib&egrave;re la m&eacute;moire &agrave; partir d'un pointeur qui a &eacute;t&eacute; pass&eacute; par r&eacute;f&eacute;rence, dans cette circonstance, le pointeur qui a &eacute;t&eacute; utilis&eacute; dans l'appel de la fonction sera consid&eacute;r&eacute; comme invalide, et il appartient &agrave; l'appelant soit de le r&eacute;affecter ou de le configurer pour qu'il soit nul. L'exemple 3 montre comment g&eacute;rer correctement ce genre de situation et l'exemple suivant montre les effets de la d&eacute;sallocation de m&eacute;moire avec de multiples r&eacute;f&eacute;rences.

Dans l'exemple suivant, un pointeur diff&eacute;rent est utilis&eacute; pour lib&eacute;rer la m&eacute;moire pr&eacute;c&eacute;demment allou&eacute;e.

{{fbdoc item="filename" value="examples/manual/memory/deallocate2.bas"}}%%(freebasic)
'' WARNING: "evil" example showing how things should NOT be done

sub DeallocateExample2()
   dim as integer ptr integerPtr = allocate( len( integer ) )  
   '' initialize ^^^ pointer to new memory

   dim as integer ptr anotherIntegerPtr = integerPtr
   '' initialize ^^^ another pointer to the same memory

   *anotherIntegerPtr = 69                     '' use other pointer
   print *anotherIntegerPtr

   deallocate( anotherIntegerPtr )             '' free memory back to system
   anotherIntegerPtr = 0                       '' and zero other pointer

'' *integerPtr = 420                           '' undefined behavior; original
	                                           '' pointer is invalid
end sub

   DeallocateExample2()
   end 0
%%

Notez qu'apr&egrave;s la d&eacute;sallocation, //les deux// pointeurs sont invalid&eacute;s. Cela illustre une autre cause de bugs lorsque l'on travaille avec des pointeurs. En r&egrave;gle g&eacute;n&eacute;rale, ne lib&eacute;rez de la m&eacute;moire pr&eacute;c&eacute;demment allou&eacute;e que lorsque vous savez qu'il n'y a qu'un seul (1) pointeur qui pointe actuellement sur elle.

{{fbdoc item="filename" value="examples/manual/memory/deallocate3.bas"}}%%(freebasic)
function createInteger() as integer ptr
   return allocate( len( integer ) )                     '' return pointer to newly
end function                                             '' allocated memory

sub destroyInteger( byref someIntegerPtr as integer ptr )
   deallocate( someIntegerPtr )                          '' free memory back to system
   someIntegerPtr = 0                                    '' null original pointer
end sub

sub DeallocateExample3()
   dim as integer ptr integerPtr = createInteger()       '' initialize pointer to
	                                                     '' new memory address

   *integerPtr = 420                                     '' use pointer
   print *integerPtr

   destroyInteger( integerPtr )                          '' pass pointer by reference
   assert( integerPtr = 0 )                              '' pointer should now be null
end sub

   DeallocateExample3()
   end 0
%%

Dans le programme ci-dessus, un pointeur de r&eacute;f&eacute;rence dans une fonction est fix&eacute; &agrave; null apr&egrave;s lib&eacute;ration de la m&eacute;moire sur laquelle il il pointe. Une macro ##[[KeyPgAssert Assert]]## est utilis&eacute;e pour tester si le pointeur original est en fait nul apr&egrave;s l'appel de la fonction. Cet exemple implique que la bonne fa&ccedil;on de passer des pointeurs de fonctions qui d&eacute;sallouent la m&eacute;moire qu'ils pointent, est par r&eacute;f&eacute;rence.

{{fbdoc item="lang"}}
	- Non disponible dans le dialecte //[[CompilerOptlang -lang qb]]// sauf si r&eacute;f&eacute;renc&eacute; avec l'alias ##**__Deallocate**##.

{{fbdoc item="diff"}}
	- Nouveau pour FreeBASIC

{{fbdoc item="see"}}
	- ##[[KeyPgAllocate Allocate]]##
	- ##[[KeyPgReallocate Reallocate]]##

{{fbdoc item="back" value="CatPgMemory|Memory Functions"}}