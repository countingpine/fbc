{{fbdoc item="title" value="DEALLOCATE"}}----
Libère la mémoire précédemment allouée

{{fbdoc item="syntax"}}##
	[[KeyPgDeclare declare]] [[KeyPgSub sub]] **Deallocate** [[KeyPgCdecl cdecl]] ( [[KeyPgByval byval]] //pointer// [[KeyPgAs as]] [[KeyPgAny any]] [[KeyPgPtr ptr]] )
##
{{fbdoc item="usage"}}##
	**Deallocate**( //pointer// )
##
{{fbdoc item="param"}}
	##//pointer//##
		l'adresse de la mémoire tampon précédemment allouée.

{{fbdoc item="desc"}}
	Cette procédure libère de la mémoire qui a été précédemment allouée avec ##[[KeyPgAllocate Allocate]]##. ##//pointer//## doit être un pointeur valide. Après le retour de procédure, ##//pointer//## sera considéré comme invalide  (pointant vers une adresse mémoire invalide) et son utilisation se traduira par un comportement non défini.

~&**##Deallocate##** est un alias pour la bibliothèque d'exécution C **##libre##**, elle n'est donc pas garantie d'être "thread-safe" sur toutes les plates-formes.

{{fbdoc item="ex"}}
L'exemple suivant montre comment libérer de la mémoire précédemment allouée. Notez que le pointeur a la valeur nulle après la désallocation:

{{fbdoc item="filename" value="examples/manual/memory/deallocate.bas"}}%%(freebasic)
sub DeallocateExample1()
   dim as integer ptr integerPtr = allocate( len( integer ) )  '' initialize pointer to
	                                                           '' new memory address

   *integerPtr = 420                                     '' use pointer
   print *integerPtr

   deallocate( integerPtr )                              '' free memory back to system
   integerPtr = 0                                        '' and zero the pointer
end sub

   DeallocateExample1()
   end 0
%%

Bien que, dans ce cas, ce ne soit pas nécessaire -##// puisque 1ø) le pointeur n'est pas une référence à un autre pointeur, 2ø) aucun autre pointeur ne pointe sur la mémoire libérée et 3ø) la fonction quitte immédiatement après //##- fixer le pointeur à NULL est une bonne habitude à prendre. Si la fonction libère la mémoire à partir d'un pointeur qui a été passé par référence, dans cette circonstance, le pointeur qui a été utilisé dans l'appel de la fonction sera considéré comme invalide, et il appartient à l'appelant soit de le réaffecter ou de le configurer pour qu'il soit nul. L'exemple 3 montre comment gérer correctement ce genre de situation et l'exemple suivant montre les effets de la désallocation de mémoire avec de multiples références.

Dans l'exemple suivant, un pointeur différent est utilisé pour libérer la mémoire précédemment allouée.

{{fbdoc item="filename" value="examples/manual/memory/deallocate2.bas"}}%%(freebasic)
'' WARNING: "evil" example showing how things should NOT be done

sub DeallocateExample2()
   dim as integer ptr integerPtr = allocate( len( integer ) )  
   '' initialize ^^^ pointer to new memory

   dim as integer ptr anotherIntegerPtr = integerPtr
   '' initialize ^^^ another pointer to the same memory

   *anotherIntegerPtr = 69                     '' use other pointer
   print *anotherIntegerPtr

   deallocate( anotherIntegerPtr )             '' free memory back to system
   anotherIntegerPtr = 0                       '' and zero other pointer

'' *integerPtr = 420                           '' undefined behavior; original
	                                           '' pointer is invalid
end sub

   DeallocateExample2()
   end 0
%%

Notez qu'après la désallocation, //les deux// pointeurs sont invalidés. Cela illustre une autre cause de bugs lorsque l'on travaille avec des pointeurs. En règle générale, ne libérez de la mémoire précédemment allouée que lorsque vous savez qu'il n'y a qu'un seul (1) pointeur qui pointe actuellement sur elle.

{{fbdoc item="filename" value="examples/manual/memory/deallocate3.bas"}}%%(freebasic)
function createInteger() as integer ptr
   return allocate( len( integer ) )                     '' return pointer to newly
end function                                             '' allocated memory

sub destroyInteger( byref someIntegerPtr as integer ptr )
   deallocate( someIntegerPtr )                          '' free memory back to system
   someIntegerPtr = 0                                    '' null original pointer
end sub

sub DeallocateExample3()
   dim as integer ptr integerPtr = createInteger()       '' initialize pointer to
	                                                     '' new memory address

   *integerPtr = 420                                     '' use pointer
   print *integerPtr

   destroyInteger( integerPtr )                          '' pass pointer by reference
   assert( integerPtr = 0 )                              '' pointer should now be null
end sub

   DeallocateExample3()
   end 0
%%

Dans le programme ci-dessus, un pointeur de référence dans une fonction est fixé à null après libération de la mémoire sur laquelle il il pointe. Une macro ##[[KeyPgAssert ASSERT]]## est utilisée pour tester si le pointeur original est en fait nul après l'appel de la fonction. Cet exemple implique que la bonne façon de passer des pointeurs de fonctions qui désallouent la mémoire qu'ils pointent, est par référence.

{{fbdoc item="lang"}}
	- Non disponible dans le dialecte //[[CompilerOptlang -lang qb]]// sauf si référencé avec l'alias ##**""__Deallocate""**##.

{{fbdoc item="diff"}}
	- Nouveau pour ""FreeBASIC""

{{fbdoc item="see"}}
	- ##[[KeyPgAllocate Allocate]]##
	- ##[[KeyPgReallocate Reallocate]]##

{{fbdoc item="back" value="CatPgMemory|Memory Functions"}}