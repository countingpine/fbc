{{fbdoc item="title" value="SELECT CASE"}}----
Bloc d'instructions conditionnelles

{{fbdoc item="syntax"}}##
	**Select Case** //expression//
	[ **Case** //expressionlist//] 
		[//statements//]
	[ **Case Else** ]
		[//statements//]
	**End Select**
//ou//
	**Select Case** As Const //integer_expression//
	[ **Case** //constant// | //enumeration// ]
		[ //statements// ]
	[ **Case Else** ]
		[ //statements// ]
	**End Select**
##
{{fbdoc item="desc"}}

	##**Select Case**## ex&eacute;cute le code sp&eacute;cifique en fonction de la valeur d'une expression. L'expression est &eacute;valu&eacute;e une fois et compar&eacute;e ensuite &agrave; chaque ##**Case**##, dans l'ordre, jusqu'&agrave; ce qu'une expression qui correspond soit trouv&eacute;e. Le code &agrave; l'int&eacute;rieur de la branche ##**Case**## correspondant est ex&eacute;cut&eacute; et le programme saute vers le bas &agrave; la fin du bloc ##**Select Case**##. ##**Case Else**## sera choisi si aucune autre ##**Case**## ne correspond, donc si il y a un ##**Case Else**##, au moins un ##**Case**## est assur&eacute; d'&ecirc;tre ex&eacute;cut&eacute;. Si aucun ##**Case**## ne correspond, le bloc ##**Select Case**## entier sera saut&eacute;.
	
	##**End Select**## est utilis&eacute; pour terminer le bloc ##**Select Case...End Select**##.

	Note pour les utilisateurs du langage C: En FreeBASIC, ##**Select Case**## fonctionne comme un bloc ##switch## o&ugrave; tous les ##**Case**## ont un ##break## &agrave; la fin. Comme il n'y a pas d'&eacute;chec, des options multiples doivent &ecirc;tre plac&eacute;es dans une liste d'expressions dans un unique ##**Case**##.

	Outre les types entiers, des expressions en virgule flottante et cha&icirc;ne sont &eacute;galement prises en charge avec la premi&egrave;re syntaxe.  

	Syntaxe d'une liste d'expressions:
	##{ //expression// | //expression// **To** //expression// | **Is** //relational operator// //expression// }[, ...]##

	- ##//expr//##: &eacute;value ##//expr//## et la compare pour voir si elle est &eacute;gale &agrave; l'expression d'origine.  Si elles sont &eacute;gales, alors une correspondance a &eacute;t&eacute; trouv&eacute;e.  Cela pourrait &ecirc;tre consid&eacute;r&eacute; comme un raccourci pour "##**Is** = //expr//##" (voir plus loin).
	- ##//expr1// **To** //expr2//##: &eacute;value ##//expr1//## et d&eacute;termine si elle est inf&eacute;rieure ou &eacute;gale &agrave; l'expression originale.  Si c'est le cas, elle &eacute;value ##//expr2//## et d&eacute;termine si elle est sup&eacute;rieure ou &eacute;gale &agrave; l'expression originale.  Si c'est le cas, alors une correspondance a &eacute;t&eacute; trouv&eacute;e.
	- ##**Is** //relational_operator// //expr//##: &eacute;value ##//expr//## et compare l'op&eacute;ration d'origine sur elle, en utilisant le ##//relational_operator//## (##=##, ##>##, ##<##, ##<>##, ##<=##, ##>=##).  Si la comparaison est vraie, alors une correspondance a &eacute;t&eacute; trouv&eacute;e.

	Des v&eacute;rifications multiples peuvent &ecirc;tre faites dans chaque ##**Case**##, en les s&eacute;parant par une virgule (##,##).  Une fois qu'une correspondance est trouv&eacute;e, le programme termine ses contr&ocirc;les et continue d'ex&eacute;cuter les instructions de code pour ce bloc ##**Case**##.  Aucune autre expression n'est &eacute;valu&eacute;e ou v&eacute;rifi&eacute;e.

	Exemples de listes d'expressions:
	{{table columns="" cellpadding="2" cells="<table>Case 1 ;constante;Case 5.4 To 10.1;plage: de ... &agrave ...;Case Is &gt 3;plus grand que - plus petit que;Case 1, 3, 5, 7 to 9;correspondance dans un ensemble de valeurs;Case x ;valeur d'une variable;</table>

	Si ##**As Const**## est utilis&eacute;, seules des constantes ##[[KeyPgInteger Integer]]## peuvent &ecirc;tre &eacute;valu&eacute;es et la liste expressions ne prend en charge que les constantes et les &eacute;num&eacute;rations. Les plages "##**To**##" sont prises en charge, mais les op&eacute;rateurs relationnels "##**Is**##" ne le sont pas.

	Avec ##**As Const**##, une table de sauts est cr&eacute;&eacute;e pour contenir l'ensemble des entiers ##**Case**## tra&icirc;t&eacute;s.  Cela rend ##**Select Case As Const**## plus rapide que ##**Select Case**##.  Toutefois, la taille de la plage de valeurs est limit&eacute;e, et la plus grande valeur dans la gamme ne peut &ecirc;tre plus &eacute;lev&eacute;e que la plus petite valeur + 4096.

{{fbdoc item="ex"}}

	%%(freebasic)
dim choice as integer

input "Choose a number between 1 and 10: "; choice

select case as const choice
case 1
	print "number is 1"
case 2
	print "number is 2"
case 3, 4
	print "number is 3 or 4"
case 5 to 10
	print "number is in the range of 5 to 10"
case else
	print "number is outside the 1-10 range"
end select
%%
	
	{{fbdoc item="diff"}}
- ##**Select Case As Const**## n'existait pas dans QB

- Dans le cas "##//expr1// TO //expr2//##", QB voulait toujours &eacute;valuer les deux expressions, m&ecirc;me si ##//expr1//## &eacute;tait sup&eacute;rieure &agrave; l'exression d'origine.

{{fbdoc item="see"}}
- ##[[KeyPgIfthen If...Then]]##

for i as integer = 1 to N
	select case i
	case 1, 3, 5, 7, 9
		dummy += 1
	case 2, 4, 6, 8, 10
		dummy += 1
	case 11 to 20
		dummy += 1
	case 21 to 30
		dummy += 1
	case 31
		dummy += 1
	case 32
		dummy += 1
	case 33
		dummy += 1
	case is >= 34
		dummy += 1
	case else
		print "can't happen"
	end select
next

print using "SELECT CASE: ##.### seconds"; timer() - t
t = timer()

for i as integer = 1 to N
	select case as const i
	case 1, 3, 5, 7, 9
		dummy += 1
	case 2, 4, 6, 8, 10
		dummy += 1
	case 11 to 20
		dummy += 1
	case 21 to 30
		dummy += 1
	case 31
		dummy += 1
	case 32
		dummy += 1
	case 33
		dummy += 1
	case else
		if( i >= 34 ) then
			dummy += 1
		else
			print "can't happen"
		end if
	end select
next

print using "SELECT CASE AS CONST: ##.### seconds"; timer() - t
sleep
%%

{{fbdoc item="diff"}}
	- ##**Select Case As Const**## did not exist in QB
	- in an "##//expr1// TO //expr2//##" case, QB would always evaluate both expressions, even if ##//expr1//## was higher than the original expression.

{{fbdoc item="see"}}
	- ##[[KeyPgIfthen If...Then]]##

{{fbdoc item="back" value="CatPgControlFlow|Control Flow"}}