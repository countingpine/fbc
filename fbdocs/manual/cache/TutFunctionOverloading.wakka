{{fbdoc item="title" value="Surcharge de fonction"}}----
//Ecrit par [[LaananFisher :stylin:]]//

----

===Qu'est-ce que c'est?===


La surcharge de fonction est aussi près que vous pouvez venir à la programmation générique sans avoir de modèles. En programmation fonctionnelle (ou modulaire), l'accent est mis sur la valeur, tandis que dans la programmation générique, l'accent est mis sur le //type//. Des fonctions similaires sont appelées en fonction du type de l'argument passé. La surcharge de fonction est un pas de côté dans la programmation générique, permettant à un identifiant de fonction d'être associé à une variété de fonctions qui fonctionnent avec une variété de types différents - et de le rendre totalement transparent pour le client (vous).

Autrement dit, la surcharge de fonction consiste à définir des fonctions qui ont le même nom, mais des //signatures// différentes. La signature d'une fonction est une combinaison de toutes les informations nécessaires pour référencer correctement la fonction et inclut la liste des paramètres de la fonction et le type de retour. Ceci est ce que nous redéfinissons, ou de surchargeons. Commençons avec un petit exemple. Supposons que nous avons besoin de fonctions affichant la chaîne représentatant un certain nombre. Nous écrivons tout simplement:


##%%(freebasic)
option explicit      '' force explicit declaration of variables
option byval         '' default passing convention as by value

'' to declare functions with similar functionality but that accept different argument types,
'' we 'simply' create new function names :(
declare function print_byte( as byte )      '' outputs a stringified byte
declare function print_short( as short )    '' outputs a stringified short

dim as byte b = 102
dim as short s = 10240

print_byte( b )
print_short( s )

sleep : end 0

'' function definitions squished for brevity - don't do this outside a space-constrained  tutorial ;}
function print_byte( n as byte ) : print str( n ) : return : end function
function print_short( n as short ) : print str( n ) : return : end function
%%##

----

===Que fait-elle pour moi?===


Le problème ici est que non seulement nous avons deux signatures de fonction différentes, mais nous avons deux //identifiants// de fonction différents, ainsi, nous - et non le compilateur - devons nous souvenir d'appeler la fonction convenable. Comme vous l'imaginez peut-être, cela peut être assez déroutant si vous décidez que vous voulez manipuler des INTEGER, SINGLE et DOUBLE. De plus, pour être complet, vous pouvez avoir des fonctions qui acceptent à la fois les versions signées et non signées de chacun de ces cas. De toute évidence, vous allez avoir une sorte de nommage de configuration système à faire pour rendre ceci plus facile pour vous-même. Et, bien sûr, vous aurez envie de manipuler aussi vos propres types, et - oh, attendez, nous avons oublié les pointeurs. OK, maintenant vous aurez besoin de doubler la liste des noms de fonction, vous devez non seulement trouver ces noms, mais aussi essayer de vous en souvenir quand vous écrirez le code qui utilisera ces fonctions. Et puis, après tout, vous avez les conversions implicites disponibles / imposées à vous, et le compilateur se fera un plaisir de vous laisser glisser un DOUBLE dans votre fonction "print_integer" - woops! Bug-ville, nous voilà! Il doit sûrement y avoir une meilleure méthode?

Ceci étant, ne m'appelez pas Shirley. J'ai déjà mentionné que le compilateur utilise deux composants principaux pour établir une signature de fonction: la liste des paramètres et le type de retour. J'ai aussi mentionné que grâce à la surcharge, on peut définir des fonctions multiples avec des signatures différentes, en gardant toujours le même nom de fonction pour chacun d'elles. Vous pouvez penser que c'est notre moyen de sortir de notre dilemme, espace de nom alambiqué et autres. Eh bien, vous avez raison - jetez un oeil sur ceci:


##%%(freebasic)
option explicit      '' force explicit declaration of variables
option byval         '' default passing convention as by value

'' to overload function print_numeric that we can redefine to accept different argument
'' types while keeping the name intact, we use the OVERLOAD keyword on our intial function:
declare function print_numeric overload( as byte )      '' outputs a stringified byte
declare function print_numeric( as short )              '' outputs a stringified short
declare function print_numeric( as integer )            '' outputs a stringified integer
declare function print_numeric( as longint )            '' outputs a stringified longint

'' define some variables
dim as byte b = 102
dim as short s = 10240
dim as integer i = 1024000000
dim as longint li = 1024000000000000000

'' enter the wonderful world of function overloading :)
print_numeric( b )
print_numeric( s )
print_numeric( i )
print_numeric( li )

sleep : end 0

'' define our function overloads
function print_numeric( n as byte ) : print str( n ) : return : end function
function print_numeric( n as short ) : print str( n ) : return : end function
function print_numeric( n as integer ) : print str( n ) : return : end function
function print_numeric( n as longint ) : print str( n ) : return : end function
%%##

----

===Qu'est-ce que cela signifie?===


Une chose qui devrait se remarquer d'emblée est de voir comment il est incroyablement facile de faire cela. Cela peut sembler étrange compte tenu de la liberté, la flexibilité et la sécurité de type, qui s'offre à vous, mais là encore les constructions de niveau le plus élevé sont comme ça. En un mot, en utiliser des méthodes comme celle-ci ne rendra pas seulement de votre vie beaucoup plus facile, mais vous passerez moins de temps dans le débogage et c'est une bonne chose, peu importe le type de code que vous écriviez.

Cela signifie //flexibilité//. La surcharge de fonction offre la possibilité d'ajouter plus de fonctionnalités (print_numeric( f as fraction)) tout en gardant intact votre code actuel. Votre code ne casse pas parce que vous voulez soutenir l'impression de la représentation numérique d'un mouchoir, d'une armure ou de tout autre chose. Vous pourriez maintenant penser que le code ci-dessus n'est pas si trivial que ça et que ce qui semble très simple - parce que ça l'est - est vraiment le fondement de l'écriture d'un meilleur code. Et vous auriez raison.

Cela signifie //maintenabilité//: Donc, vous avez vos 80 fonctions d'écriture_d'un_certain_nom_que_vous_devez_vérifier_chaque_fois_que_vous_en_avez_besoin_pour_l'écriture_ou_le_débogage. Tout est grand dans votre petit monde tortueux et d'auto-dégoût. Qu'est-ce qui se passe quand quelque chose doit changer? Si seulement une de ces fonctions doit changer, BAM! Un cauchemar de maintenance. Vous allez avoir à rechercher dans l'ensemble code de base pour être //complètement// sûr que vous n'avez pas raté une fonction ici ou là; triste façon de passer un samedi soir, mon ami.

Cela signifie //sécurité//: Vous pouvez remarquer que j'utilise deux options dans ces exemples: [[KeyPgOptionexplicit OPTION EXPLICIT]] et [[KeyPgOptionbyval OPTION BYVAL]]. Je suis fort sur la sécurité, et je le suis encore plus en demandant au compilateur de surveiller mes arrières. J'utilise ceci parce que c'est plus sûr et je vais demander toute la sécurité que je peux obtenir. La surcharge de fonction met également en sécurité - sécurité contre le mal (lire: accidentelle) les conversions implicites. Considérez que nous sommes réellement en mesure de retourner, à partir de ces fonctions, une valeur qui repose sur l'argument que nous lui passons. Comme précédemment, si un double a été autorisé à être tronquer à notre insu, cela signifie que de nombreux comprimés d'Excedrin essaieront de faire disparaître les maux de tête débogage. C'est tout au sujet de la chose de sécurité de type, quelque chose qui force certains à se moquer de C//pp//.

----

===Conclusion===


J'espère que vous avez appris au moins les rudiments de la surcharge de fonction (puisque c'est tout ce que je couvert). Et j'espère que vous commencez à penser à des thèmes que j'ai soulevé, si ce n'était pas le cas auparavant. La prochaine fois je discuterai des fonctions surchargées avec différents nombres de paramètres, différents types de retour, ainsi que des joies et des pièges des deux. Restez à l'écoute.

