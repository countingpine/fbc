{{fbdoc item="title" value="THREADCREATE"}}----
Démarre une procédure définie par l'utilisateur dans un "thread" d'exécution distinct

{{fbdoc item="syntax"}}##
	[[KeyPgDeclare declare]] [[KeyPgFunction function]] **Threadcreate** ( [[KeyPgByval byval]] //proc// [[KeyPgAs as]] [[KeyPgSub sub]] ( [[KeyPgByval byval]] [[KeyPgAs as]] [[KeyPgAny any]] [[KeyPgPtr ptr]] ), [[KeyPgByval byval]] //param// [[KeyPgAs as]] [[KeyPgAny any]] [[KeyPgPtr ptr]] = 0, [[KeyPgByval byval]] //stack_size// [[KeyPgAs as]] [[KeyPgInteger integer]] = 0 ) [[KeyPgAs as]] [[KeyPgAny any]] [[KeyPgPtr ptr]]
##
{{fbdoc item="usage"}}##
	//result// = **Threadcreate** ( //proc// [, [ //param// ] [, //stack_size// ] ] )
##
{{fbdoc item="param"}}
	##//proc//##
		Un pointeur vers le ##[[KeyPgSub Sub]]## prévue pour travailler comme un "thread".
	##//param//##
		Argument facultatif [[KeyPgAny any]] [[KeyPgPtr ptr]] pour la ##[[KeyPgSub Sub]]## pointée par ##//proc//## (peut être un pointeur vers une structure ou un tableau si plusieurs arguments sont nécessaires).
	##//stack_size//##
		Nombre (facultatif) d'octets à réserver pour la pile de ce "thread".

{{fbdoc item="ret"}}
	**Threadcreate** retourne un "handle" ##[[KeyPgAny any]] [[KeyPgPtr ptr]]## vers le "thread" créé, ou le pointeur nul (0) en cas d'échec.

{{fbdoc item="desc"}}
	La fonction utilisateur est lancée comme un "thread" exécuté en parallèle avec la partie principale du programme. Le système d'exploitation atteint cet objectif en l'assignant à un processeur différent si il existe, ou en utilisant les temps d'attente dans le programme principal.

	Avant fermeture, un programme doit attendre l'achèvement de tous les "threads" qu'il a lancés; voir ##[[KeyPgThreadWait Threadwait]]##.

	Pour éviter l'accès simultané aux ressources partagées à partir de "threads" différents, FreeBASIC met en œuvre les "mutex", les verrous d'exclusion mutuelle qui peuvent être "possédés" par un seul "thread" lors d'un travail critique. Voir ##[[KeyPgMutexCreate Mutexcreate]]##, ##[[KeyPgMutexLock Mutexlock]]##, ##[[KeyPgMutexUnlock Mutexunlock]]##, ##[[KeyPgMutexDestroy Mutexdestroy]]##.

	Sur certains systèmes, la pile augmente automatiquement au-delà de ##//stack_size//## si plus d'espace est nécessaire; sur les autres, c'est le maximum permis. Le comportement est imprévisible en cas de dépassement de pile, par rapport à ce qui était réservé, dans les cas où la pile n'est pas capable de s'agrandir.

{{fbdoc item="ex"}}
{{fbdoc item="filename" value="examples/manual/threads/threadcreate.bas"}}%%(freebasic)
Dim Shared terminate As Integer = 0

Sub mythread (param As Any Ptr)	
	
	dim as double t = timer
	While( 1 )
		
		Print "*";
		
		'' pause for .1 second
		while( abs( timer - t ) < .1 )
			sleep 1, 1
		wend
		t = timer
		
		If terminate=1 Then Exit Sub
	Wend
	
End Sub

Dim thread As Any Ptr
Dim b As Integer
dim as double t

Print "Main program prints dots"
Print "Thread prints asterisks"
thread = ThreadCreate( @mythread, 0 )
Print "Thread launched";

While b < 30
	
	Print ".";
	
	'' pause for .1 second
	while( abs( timer - t ) < .1 )
		sleep 1, 1
	wend
	t = timer
	
	b += 1
	
Wend

terminate=1
Print "Terminate launched";
ThreadWait (thread)
Print "Thread terminated"
Sleep
%%

{{fbdoc item="lang"}}
	- Les "Thread" n'existent pas dans le dialecte //[[CompilerOptlang -lang qb]]//.

{{fbdoc item="target"}}
	- La version DOS de FreeBASIC ne permet pas les "threads", car l'OS ne les supporte pas.
	- Dans Linux les "threads" sont toujours démarrés dans l'ordre de leur création, ceci n'est pas possible sous Win32. Il s'agit de l'OS, pas une question FreeBASIC. 

{{fbdoc item="diff"}}
	- Nouveau pour ""FreeBASIC""

{{fbdoc item="see"}}
	- ##[[KeyPgThreadWait Threadwait]]##
	- ##[[KeyPgMutexCreate Mutexcreate]]##
	- ##[[KeyPgMutexLock Mutexlock]]##
	- ##[[KeyPgMutexUnlock Mutexunlock]]##
	- ##[[KeyPgMutexDestroy Mutexdestroy]]##

{{fbdoc item="back" value="CatPgThreading|Threading Support Functions"}}

