{{fbdoc item="title" value="Const Qualifiers and You"}}----
Remarque: Comme pour tout ce qui concerne la portée, les qualificatifs Const peuvent être un peu difficile à comprendre. Vous devriez avoir une compréhension approfondie de la portée des variables avant de tenter de comprendre les qualficateurs Const.

A noter également mon titre cliché, que j'ai choisi à cause de sa "clichetitude".

Que diable sont les qualificatifs Const? Les qualificatifs Const sont une caractéristique ajoutée récemment au langage (FBC 0.18.3), ils sont un élément standard du C""++"" et maintenant, ils existent aussi dans FreeBASIC. Les qualificatifs Const sont encore une autre forme de protection - ils permettent à certaines "variables" d'agir comme des constantes dans certaines parties de votre programme, en d'autres termes certaines parties du programme sont autorisés à accéder à eux (en lecture), mais pas de les modifier. Juste un autre genre de type de sécurité, vraiment, mais extrêmement utile. Ils sont très utiles, en particulier, dans les situations de OO (Orientée Objet), mais vous pouvez probablement en bénéficier à un certain degré, même si vous n'êtes pas intéressé à la POO (Programmation Orientée Objet).

Le qualificatif Const dans FreeBASIC est essentiellement un prolongement des déclarations de type de données, et il peut être utilisé avec Dim, les membres UDT (définis par l'utilisateur) et les paramètres de procédure. En général, vous le mettez juste après le ##//AS//## faisant partie de la déclaration des variables de type de données:

%%(freebasic)
Dim As Const Integer my_const_int = 5
%%

(A propos, dans ce tutoriel, je n'utilise que des entiers et des pointeurs d'entiers comme exemples - cependant, les qualificatifs Const // doivent// fonctionner de la même façon avec tous les autres types de variables, y compris les types, énumérations et bien d'autres qui déclarent quelque chose. Si pour quelque raison ce n'est pas pas le cas, c'est probablement un bug et vous devez le signaler.)

Notez que dans ce cas, nous sommes autorisés à modifer sa valeur une fois - lors de la création. Mais après cela, vous ne pouvez pas le changer plus. En fait, vous //devez// l'initialiser - le compilateur donnera une erreur si vous ne l'avez pas fait (fait intéressant, vous êtes autorisés à le fixer à elle égale à "//Any//", dans lequel le contenu n'est pas garanti et pourrait être n'importe quoi). Mais vous ne pouvez pas faire quelque chose qu'il le modifie par la suite. Il vous donnera vraiment une erreur si, par exemple, vous essayez de faire quelque chose comme ceci:

%%(freebasic)
my_const_int = 3
%%

Pourtant, puisque cela ne change pas la variable existante, vous pouvez le faire.

%%(freebasic)
Print my_const_int
%%

Maintenant tout cela est très bon, mais ne semble pas très différent de l'utilisation normale de Const. Autrement dit, les deux lignes suivantes semblent dire jusqu'à présent, à toutes fins pratiques, la même chose:

%%(freebasic)
Dim As Const Integer my_const_int = 5
Const my_int As Integer = 5
%%

Est-ce vrai? Pas tout à fait. Vous voyez, le qualificatif Const vous permet de créer des constantes qui agissent comme des variables, sauf qu'elles ne peuvent pas être modifiées. Cela signifie que vous pouvez les mettre à l'intérieur de Types et d'autres endroits. De plus, vous pouvez les mettre à l'intérieur de déclarations de Sub / Function - et c'est une raison très essentielle de leur existence:

%%(freebasic)
Sub my_sub (some_num As Integer)
End Sub
%%

Normalement les fonctions sont autorisées à modifier les variables que vous leur envoyez. Bien sûr, soit elles modifient la variable d'origine, soit tout simplement une copie locale de la variable; cela dépend de l'utilisation de ByVal ou ByRef (et bien sûr de pointeurs, ce qui est tout à fait différent), mais elles sont normalement autorisées à modifier une variable. Cela peut être indésirable, pour une raison quelconque, et le qualificatif Const existe pour empêcher cela. Dans la fonction ci-dessus, some_num peut être modifié par la fonction. Normalement, ce ne serait qu'une copie locale qui serait modifiée, ce qui est bien, car elle n'affecte pas l'"Integer Const" original, mais si nous déclarion la fonction comme cela?

%%(freebasic)
Sub my_sub (ByRef some_num As Integer)
End Sub
%%

Maintenant my_sub a un accès direct à toute variable que vous lui passez, et pour cette raison vous n'êtes pas autorisé à faire ce genre de chose

%%(freebasic)
my_sub(my_const_int)
%%

Pourquoi? Tout simplement parce que la fonction peut modifier la variable. Nous ne sommes pas certain qu'elle le fera, bien sûr, mais elle le pourrait, donc nous ne pouvons pas faire cela. En fait, l'erreur que vous obtiendrez si vous essayez de compiler est "affectation / conversion invalide". C'est presque comme si l'entier Const était un autre type de variable, mais seulement quand il est ByRef. Dans ce cas, il agit comme s'il essayait de passer une chaîne à un argument entier (ou vice-versa). Pourtant, s'il n'est pas passé ByRef, nous n'avons pas de problème, car il n'y a aucun moyen pour que la fonction puisse éventuellement modifier la variable!

Et bien sûr, si nous faisions quelque chose comme ceci:

%%(freebasic)
Sub my_sub (ByRef some_num As Const Integer)
End Sub
%%

Ensuite la compilation se passe très bien, mais si vous essayez de faire ce qui suit dans la fonction, vous obtiendrez une erreur:

%%(freebasic)
some_num = 3
%%

Pourquoi? Une fois encore, la variable d'origine a été transmise ByRef à la Sub. Nous avons maintenant une portée locale, mais parce que c'est ByRef, toute modification de la variable modifierait l'original, ce qui ne peut pas être fait. Une fois encore, il est tout à fait possible de créer une copie de la variable et de la modifier tant que vous voulez:

%%(freebasic)
Dim As Integer copy_of_some_num = some_num
copy_of_some_num = 3
%%

Mais vous ne pouvez pas modifier some_num lui-même!

Nous arrivons maintenant aux pointeurs. Qu'est-ce qui se passe pour eux? Pour les pointeurs, c'est un peu plus compliqué, il est possible de déclarer le pointeur //lui-même// comme const OU ce que le pointeur pointe - ou même LES DEUX! Donc toutes les déclarations suivantes sont valables:

%%(freebasic)
Declare Sub my_sub_a (ByRef ptr_A As Const Byte Ptr)

Declare Sub my_sub_b (ByRef ptr_B As Byte Const Ptr)

Declare Sub my_sub_c (ByRef ptr_C As Const Byte Const Ptr)
%%

La première fait en sorte que vous pouvez changer le pointeur lui-même comme vous voulez, mais pas les données vers lesquelles il pointe (même si vous changez *ce que* le pointeur pointe). La seconde vous permet de changer ce que le pointeur pointe, mais vous ne pouvez pas le faire pointer vers autre chose. Le troisième ne vous laissera pas changer ce que le pointeur pointe OU le pointeur lui-même! Dans tous les cas vous pouvez faire une copie du pointeur - // mais il doit être un Ptr Integer Const ou un Const Integer Const Ptr car sinon vous seriez en mesure de modifier le contenu de ce vers quoi le pointeur original pointe!// Ceci est une excellente protection contre quoi que ce soit en cours de modification!

In case the behaviour of the Const qualifier seems a bit strange to you, I'll explain exactly how it decides what's safe to allow and what isn't.  It can actually be summed up pretty quickly:  The Const qualifier aims to protect the original data.  It doesn't care if you make a copy of the data, or change that copy, it just doesn't want you to be able to change the original data.  Remembering this will help you a great deal.  Of course, it needs to know //what// the original data is, which is why when there's pointers involved there are so many different places to put the Const qualifier (and you can even put it in twice - or more, depending on how many pointers there are!)  So long as you remember what the Const qualifier is for, you'll never have any difficulty figuring out where to put it - or even if you need it at all (or if you need to //not// use it).

Vous pouvez également utiliser le qualificatif Const dans types définis par l'utilisateur. En fait, c'est vraiment une chose très importante pour la POO (de façon similaire aux espaces de noms, qui tout en n'étant pas directement partie de la POO sont néanmoins très liés) - mais même si vous n'utilisez pas la POO, vous pouvez toujours utiliser des qualificatifs Const dans vos types. Je n'ai même pas vraiment besoin de vous montrer un exemple, maintenant que leur fonctionnement est assez évident, mais voici quand même un exemple pour vous:

%%(freebasic)
Type my_type
  As Const Integer t_int= 5
End Type

Dim As my_type t

t.t_int = 3
%%

Et, évidemment, la compilation échouera, puisque le membre t_int est Const. En outre, vous pouvez aussi déclarer la variable de ce type (dans ce cas, t) avec le qualificatif Const. Ce qui suit ne se compilera pas non plus, puisque TOUS les membres de t sont Const:

%%(freebasic)
Type my_type
  As Integer t_int= 5
End Type

Dim As Const my_type t

t.t_int = 3
%%

Comme pour le côté POO des choses (et si vous n'êtes pas intéressé par la POO, vous pouvez sauter cette partie) - vous vous posez peut-être des questions sur les méthodes. Les méthodes implicitement passe l'objet ByRef lorsqu'elles sont appelées. Y-a-t-il un moyen de créer des objets constants? Bien sûr! Nous avons déjà vu cela. Mais certaines méthodes modifieront l'objet, et d'autres non. Y-a-t-il une distinction? La réponse est oui. Le 23 Novembre 2007, nous avons maintenant des procs Const. Cela signifie que vous pouvez faire ceci:

%%(freebasic)
Type my_object
  Public:
	Declare Sub modifier_sub ()
	
	'Subs that do not modify the object are declared Const...
	Declare Const Sub non_modifier_sub ()
  Private:
	some_num As Integer = 3
End Type

Sub my_object.modifier_sub ()
  this.some_num = 3
End Sub

Sub my_object.non_modifier_sub()
  Print this.some_num
End Sub

'Note that only Const objects must be initialized (though in this case the non-Const object will also be),
'just like variables.  Thus, you must either have a Constructor for the object, or else you must give all variables
'default initial values (as I did here), in which case the compiler makes a default constructor for you.
Dim As Const my_object t = my_object
Dim As my_object u

'Both of these will compile:
t.non_modifier_sub()
u.non_modifier_sub()

'...but the first of these will not compile, since non-Const methods of Const objects may not be called!
t.modifier_sub()
u.modifier_sub()

'Sleep so we can see the results
Sleep
%%

Une fois encore, la façon dont cela fonctionne est basé sur la règle simple. Comme la copie implicite est passée ByRef, toute méthode est normalement capable de modifier le contenu de l'objet - et si l'objet est déclaré As Const, ce n'est pas censé se produire! Ainsi, il existe essentiellement deux types de méthode. Les deux types ont des noms donnés dans la page de documentation C""++"" (listées ci-dessous dans les références): il y a des manipulateurs et des inspecteurs. Les mutateurs peuvent modifier les objets, mais les inspecteurs ne le peuvent pas. Ainsi, pour les objets déclarés As Const, seules les méthodes inspecteurs peuvent être utilisées pour ces objets - alors que toutes les méthodes peuvent être appelées en cas de objets non-Const. Les méthodes inspecteurs sont, bien sûr, celles déclarées comme des méthodes Const. Ainsi, pour les objets Const seules leurs méthodes Const peut être utilisées.


Tout cela est très bien, mais certains d'entre vous se demandent peut-être - Pourquoi dois-je connaître cela? Eh bien, une réponse directe serait hors de la *portée* (hé) de ce tutoriel, je vais donc aller à l'encontre - Pourquoi avons-nous besoin de la portée du tout? La raison des qualificatifs Const (et des méthodes Const futures) est la même que la raison de la portée dans les procédures et les modules, et la raison même pour cacher des objets variables: parce que nous voulons être certains que quelque chose ne changera pas de façon inattendue au milieu du programme, quand on s'y attend le moins. Parfois, nous voulons que les choses changent et c'est pourquoi nous n'utilisons pas le qualificatif Const. Mais quand vous voulez les choses restent ce qu'elles sont, vous utilisez le qualificateur Const, et vous pouvez être certain que rien ne changera (et le compilateur ne compilera pas le code s'il existe un danger que cela se produise!). Ceci est la définition de Const, comment il fonctionne, et c'est la raison pour laquelle vous l'utilisez! Et en général, c'est la raison pour laquelle vous utilisez tout contrôle de portée ou de données cachées.


**Quelques notes finales**
Si vous utilisez le qualificatif Const, n'oubliez pas que c'est un élément relativement nouveau. Il y a très peu de documentation pour nous dire ce qui est "mauvais" ou "correct", aussi généralement il faudra faire quelques expériences. Si vous sentez qu'il fait quelque chose qu'il ne doit pas faire (ou ne pas faire quelque chose qu'il doit faire), par tous moyens signaler-le sur le forum! Si c'est considéré comme un problème par quelqu'un d'autre, soumettez un rapport de bogue. En général, cependant, il devrait fonctionner exactement comme je l'ai dit et tous les exemples donnés devraient s'exécuter comme j'ai dit qu'ils le devraient (compilés si je dis qu'ils le seront, non compilés si je dis qu'ils ne le seront pas). Une chose très importante à se rappeler, bien sûr, c'est qu'ils ne sont pas dans la dernière version officielle - vous devez avoir la dernière version SVN pour en bénéficier (si le compilateur donne une erreur sur l'un des exemples donnés ici que j'ai indiqué comme compilable, alors vous saurez que vous avez besoin d'une version plus récente).

Si vous avez d'autres difficultés avec les qualificatifs Const, n'oubliez pas que même s'il n'y a pas de documentation pour eux il, y a beaucoup de gens sur le forum qui les connaissent et les comprennent, et qui peuvent vous aider pour toutes les questions que vous pourriez poser.

Si vous ne comprenez toujours pas les qualificatifs Const, vous êtes probablement un débutant qui ne connaît pas encore suffisamment la notion de portée - et c'est très bien, vous allez apprendre en pratiquant. Finalement certains documents convenables pour cette fonction seront créés, mais jusque-là c'est tout ce que vous avez. Gardez à l'esprit: si vous ne comprenez pas comment ils fonctionnent, vous n'aurez probablement pas besoin d'eux. Pour ma part, j'ai écrit des programmes corrects longtemps avant qu'ils n'apparaissent, et je vais probablement continuer à le faire sans les utiliser là où ils ne sont pas nécessaires. Il y a des cas spécifiques où ils sont utiles, et si vous comprenez ces cas, alors vous pouvez aussi bien les utiliser quand ces cas se présentent. Mais si vous ne comprenez pas, ce n'est pas grave!

Enfin, voici quelques liens qui devraient être utiles. Le premier est une page de documentation C""++"" sur le qualificatif Const en C""++"" - bien sûr, elle n'a de sens que si vous comprenez le C""++"", et elle parle de notions que nous n'avons pas encore (c'est à dire, les méthodes Const). Néanmoins c'est une bonne façon pour commencer si vous connaissez le C""++"", donc allez vérifier si vous voulez. Il y a aussi un lien vers un sujet du forum dans lequel j'ai questionné sur le développement FreeBASIC (et appris les qualificatifs Const), et un lien vers la page d'origine SourceForge Feature Request dans lequel qualificatifs Const ont initialement été demandés comme une caractéristique:

http://www.parashift.com/c++-faq-lite/const-correctness.html
http://www.freebasic.net/forum/viewtopic.php?t=9975&postdays=0&postorder=asc&start=0
http://sourceforge.net/tracker/index.php?func=detail&aid=1480621&group_id=122342&atid=693199