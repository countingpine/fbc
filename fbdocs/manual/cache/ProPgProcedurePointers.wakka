{{fbdoc item="title" value="Pointers to Procedures"}}----
Pointeurs qui pointent vers des proc&eacute;dures

	Tout comme les pointeurs peuvent &ecirc;tre faits pour pointer vers un type ##[[KeyPgInteger Integer]]## ou ##[[KeyPgSingle Single]]##, les pointeurs peuvent aussi pointer vers des proc&eacute;dures, c'est &agrave; dire qu'ils peuvent stocker l'adresse d'une proc&eacute;dure.

{{fbdoc item="section" value="D&eacute;claration
	Pour d&eacute;clarer un pointeur vers une proc&eacute;dure, utilisez les mots-clefs ##[[KeyPgSub Sub]]## ou ##[[KeyPgFunction Function]]##, suivi de param&egrave;tres et du type de la valeur de retour:

{{fbdoc item="filename" value="examples/manual/proguide/procptrs/dimptr.bas"}}%%(freebasic)
' d&eacute;clare un pointeur vers une proc&eacute;dure Sub qui n'a aucun argument
dim pointerToProcedure as sub
%%
	Les pointeurs de proc&eacute;dure stockent l'adresse de la proc&eacute;dure, qui est r&eacute;cup&eacute;r&eacute;e &agrave; l'aide de ##[[KeyPgOpAt Operator @]]## (Adresse de) ou de ##[[KeyPgOpProcptr Procptr Operator]]##:

{{fbdoc item="filename" value="examples/manual/proguide/procptrs/pfunc.bi"}}%%(freebasic)
function Add (a as integer, b as integer) as integer
	return a + b
end function

dim pFunc as function (as integer, as integer) as integer = @Add
%%

{{fbdoc item="section" value="Appel d'un pointeur de proc&eacute;dure
	La chose int&eacute;ressante &agrave; propos des pointeurs proc&eacute;dure est qu'ils peuvent &ecirc;tre appel&eacute;s tout comme une proc&eacute;dure:

{{fbdoc item="filename" value="examples/manual/proguide/procptrs/calling.bas"}}%%(freebasic)
'' .. Add et pFunc comme avant ..
#include once "pfunc.bi"

print "3 + 4 = " & pFunc(3, 4)
%%

{{fbdoc item="section" value="Passage de pointeur de proc&eacute;dure &agrave; d'autres proc&eacute;dures
	Passage de pointeurs de proc&eacute;dure &agrave; d'autres proc&eacute;dures est similaires &agrave;:

{{fbdoc item="filename" value="examples/manual/proguide/procptrs/passing.bas"}}%%(freebasic)
'' .. Add et pFunc comme avant ..
#include once "pfunc.bi"

function DoOperation (a as integer, b as integer, operation as function (as integer, as integer) as integer) as integer
	return operation(a, b)
end function

print "3 + 4 = " & DoOperation(3, 4, @Add)
%%
	Parce que les d&eacute;clarations de pointeur de proc&eacute;dure peuvent &ecirc;tre longues, il est souvent utile de cr&eacute;er un alias de type pour le pointeur de proc&eacute;dure, dans un effort de clarification du code:

{{fbdoc item="filename" value="examples/manual/proguide/procptrs/alias.bas"}}%%(freebasic)
'' .. Add et pFunc comme avant ..
#include once "pfunc.bi"

type operation as function (as integer, as integer) as integer

function DoOperation (a as integer, b as integer, op as operation) as integer
	return op(a, b)
end function

print "3 + 4 = " & DoOperation(3, 4, @Add)
%%

{{fbdoc item="section" value="Pointeurs de pointeurs de proc&eacute;dure
	Parce que la syntaxe d'un pointeur de proc&eacute;dure ne permet pas de d&eacute;claration d'un pointeur vers un pointeur de proc&eacute;dure, un alias de type est utilis&eacute;. Notez comment il est n&eacute;cessaire d'entourer un pointeur d&eacute;r&eacute;f&eacute;renc&eacute; vers un pointeur de proc&eacute;dure par des parenth&egrave;ses lors de l'appel de la proc&eacute;dure. C'est parce que l'op&eacute;rateur d'appel de fonction "()" a une priorit&eacute; sup&eacute;rieure &agrave; ##[[KeyPgOpValueOf Operator *]]## (Valeur de):

{{fbdoc item="filename" value="examples/manual/proguide/procptrs/procptrs.bas"}}%%(freebasic)
sub Halve (byref i as integer)
	i /= 2
end sub

sub Triple (byref i as integer)
	i *= 3
end sub

type operation as sub (byref as integer)

' an array of procedure pointers, NULL indicates the
' end of the array
dim operations(20) as operation = _
{ @Halve, @Triple, 0 }

dim i as integer = 280

' apply all of the operations to a variable by iterating through the array
' with a pointer to procedure pointer
dim op as operation ptr = @operations(0)
while (0 <> *op)
	' call the procedure that is pointed to, note the extra parenthesis
	(*op)(i)
	op += 1
wend

print "Value of 'i' after all operations performed: " & i
%%

{{fbdoc item="see"}}
	- ##[[KeyPgSub Sub]]##

- ##[[KeyPgFunction Function]]##
- ##[[KeyPgPointer Pointer]]##
 - ##[[KeyPgOpAt Op&eacute;rateur * (Adresse de)]]##
 - ##[[KeyPgOpProcptr Procptr Operator]]##
 '
 ' When this is supported, you will only need to remove the static wrapper
 ' function presented here, to maintain compatibility. 
 '/

type T
	declare function test(byval number as integer) as integer
	declare static function test(byref this as T, byval number as integer) as integer
	dim as integer i = 420
end type

function T.test(byval number as integer) as integer
	return i + number
end function

function T.test(byref this as T, byval number as integer) as integer
	return this.test(number)
end function

dim p as function(byref as T, byval as integer) as integer
p = @T.test

dim as T obj

print p(obj, 69) '' prints 489
%%

{{fbdoc item="see"}}
	- ##[[KeyPgSub Sub]]##
	- ##[[KeyPgFunction Function]]##
	- ##[[KeyPgPointer Pointer]]##
	- ##[[KeyPgOpAt Operator * (Address of)]]##
	- ##[[KeyPgOpProcptr ProcPtr operator]]##

{{fbdoc item="back" value="CatPgProgrammer|Programmer's Guide"}}
   

   
