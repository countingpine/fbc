{{fbdoc item="title" value="Le type pointeur de donn&eacute;es"}}----
//Ecrit par [[WikiRick rdc]]//

Le type pointeur de données est unique parmi les types données numériques de FreeBASIC. Au lieu de contenir des données, comme les autres types numériques, un pointeur contient l'adresse mémoire de données.

Sur un système 32 bits, le type  pointeurde données occupe 4 octets. FreeBASIC utilise des pointeurs pour un certain nombre de fonctions telles que ImageCreate, et ils sont utilisés massivement dans des bibliothèques externes telles que l'API Windows. Les pointeurs sont aussi assez rapides, car le compilateur peut accéder directement à l'emplacement mémoire pointé par le pointeur. Une bonne compréhension des pointeurs est essentielle pour une programmation efficace sous FreeBASIC.

Pour de nombreux programmeurs débutants les pointeurs semblent comme une bête étrange et mystérieuse. Toutefois, si vous gardez à l'esprit une règle, vous ne devriez avoir aucun problème en utilisant des pointeurs dans votre programme. La règle est très simple: un pointeur contient une adresse, pas de données. Si vous gardez cette règle simple à l'esprit, vous devriez avoir aucun problème en utilisant des pointeurs.

=== Pointeurs et mémoire ===

Vous pouvez imaginer la mémoire de votre ordinateur comme un ensemble de boîtes postales (PO Box) de votre bureau de poste local. Quand vous y allez pour louer une boîte postale, le greffier vous donnera un numéro, le 100 par exemple. C'est l'adresse de votre boîte postale. Vous écrivez le nombre sur un feuillet de papier et vous le mettez dans votre portefeuille. Le lendemain, vous allez à la poste et sortez le bout de papier. Vous localisez la boîte 100, regardez à l'intérieur de la boîte et trouvez une bonne pile de courrier indésirable. Bien sûr, vous voulez jeter le courrier indésirable, mais il n'y a pas de poubelle à portée de main, alors vous décidez simplement de remettre le courrier dans la boîte et de le jeter plus tard. Travailler avec des pointeurs sous FreeBASIC est très similaire à l'utilisation d'une boîte postale.

Lorsque vous déclarez un pointeur, il ne pointe pas vers quelque chose ceci est analogue au morceau de papier blanc. Afin d'utiliser un pointeur, il doit être initialisé avec une adresse mémoire, ce qui est identique à l'écriture du numéro 100 sur le bout de papier. Une fois que vous avez l'adresse, trouvez la bonne boîte postale, vous pouvez déréférencer le pointeur, ouvrir la boîte aux lettres, ajouter ou récupérer des données pointées par l'emplacement mémoire. Comme vous pouvez le voir il y a trois étapes de base pour utiliser des pointeurs.

~Déclarer une variable pointeur.
~Initialiser le pointeur vers une adresse mémoire.
~Déréférencement du pointeur pour manipuler les données à l'emplacement mémoire pointé.

Ce n'est pas vraiment différent de l'utilisation d'une variable standard et vous utiliserez les pointeurs en grande partie de la même manière que les variables standard. La seule vraie différence entre les deux est que dans une variable standard, vous pouvez accéder directement aux données, et avec un pointeur, vous devez le déréférencer pour interagir avec les données.

=== Pointeurs typés et non typés ===

FreeBASIC a deux types de pointeurs: typés et non typés. Un pointeur typé est déclaré en association avec un type de données.

%%(freebasic)
Dim myPointer as Integer Ptr
%%

Cela indique au compilateur que ce pointeur sera utilisé pour des données nombres entiers. L'utilisation de pointeurs typés permet au compilateur de faire la vérification du type pour s'assurer que vous n'utilisez pas le mauvais type de données avec le pointeur et simplifie l'arithmétique des pointeurs.

Les pointeurs non typés sont déclarés en utilisant le mot-clé "Any".

%%(freebasic)
Dim myPointer as Any Ptr
%%

Les pointeurs non typés n'ont aucune vérification de type et par défaut la taille d'un octet. Les pointeurs non typés sont utilisés dans la bibliothèque d'exécution C et de nombreuses librairies tierces, telles que l'API Win32, pour accueillir le type pointeur void en C. Sauf si vous avez spécifiquement besoin d'un pointeur non typé, vous devriez utiliser des pointeurs typés afin que le compilateur peut vérifier les affectations pointeur.

=== Les opérateurs pointeur===

FreeBASIC a les [[CatPgOpPoint opérateurs pointeur]] suivants.

Vous remarquerez que l'opérateur @ (Adresse de) non seulement renvoie l'adresse mémoire d'une variable, mais il peut aussi renvoyer l'adresse d'un sous-programme ou d'une fonction. Vous pourriez utiliser l'adresse d'un sous-programme ou d'une fonction pour créer une fonction de rappel telle que celle utilisée dans la fonction CRT qsort.

=== Fonctions mémoire ===

FreeBASIC a également un certain nombre de [[CatPgMemory fonctions mémoire]] qui sont utilisées avec des pointeurs.

Ces fonctions sont utiles pour créer un certain nombre de structures dynamiques comme les listes chaînées, tableaux non-rectangulaires (ragged) ou dynamiques et les tampons utilisés avec des librairies tierces.

Lorsque vous utilisez la fonction "Allocate" vous devez spécifier la taille de stockage basée sur le type de données en utilisant l'équation nombre_d_elements * sizeof (type de données). Pour allouer de l'espace pour 10 entiers votre code devrait ressembler à ceci: myPointer = Allocate (10 * sizeof (Integer)). Un entier occupe 4 octets donc pour allouer 10 entiers 40 octets seront mis de côté en mémoire. "Allocate" n'efface pas le segment de mémoire, donc les données dans le segment seront aléatoires, données sans aucun sens jusqu'à l'initialisation.

"Callocate" fonctionne de la même façon, sauf que le calcul est fait en interne. Pour allouer les 10 mêmes entiers en utilisant "Callocate" votre code ressemblera à cela: myPointer = Callocate(10, Sizeof(Integer)). Contrairement à "Allocate", "Callocate" va effacer le segment de mémoire.

"Reallocate" change la taille d'un segment existant en mémoire, le rendant plus ou moins grand selon les besoins. Si le nouveau segment est plus grand que le segment existant, alors les données dans le segment existant seront conservées. Si le nouveau segment est plus petit que le segment existant, les données existantes dans le segment seront tronquées. "Reallocate" n'efface pas la mémoire ajoutée ou modifie toutes les données existantes.

Toutes ces fonctions renvoient une adresse mémoire en cas de succès. Si les fonctions ne peuvent pas allouer le segment de mémoire, alors un pointeur NULL (0) est retourné. Vous devriez vérifier la valeur retournée chaque fois que vous utilisez ces fonctions pour être sûr que le segment de mémoire a été créé correctement. Tenter d'utiliser un mauvais pointeur se traduira par un comportement indésirable ou plantage du système.

{{table columns="1" cellpadding="2" cells=" Il n'y a pas de méthode intrinsèque pour déterminer la taille d'une allocation. Vous devez garder une trace de cette information vous-même."}}

{{table columns="1" cellpadding="2" cells="Attention à ne pas utiliser la même variable pointeur pour allouer deux ou plusieurs segments de mémoire. Réutiliser un pointeur, sans premièrement le désallouer, se traduira par la perte du segment de mémoire précédent, provoquant une perte de mémoire."}}

=== Arithmétique des pointeurs et d'indexation de pointeur ===

Lorsque vous créez un segment de mémoire en utilisant les fonctions d'allocation, vous aurez besoin d'un moyen pour accéder aux données contenues dans le segment. En FreeBASIC, il existe deux méthodes pour accéder aux données dans le segment; utiliser l'opérateur d'indirection avec l'arithmétique des pointeurs et l'indexation du pointeur.

L'arithmétique des pointeurs, comme son nom l'indique, ajoute et soustrait des valeurs à un pointeur pour accéder aux éléments individuels au sein d'un segment de mémoire. Lorsque vous créez un pointeur typé comme "Dim myPointer as Integer ptr", le compilateur sait que les données utilisées avec ce pointeur ont la taille d'un entier ou 4 octets. Le pointeur, quand il est initialisé, pointe sur le premier élément du segment. Vous pouvez exprimer ceci ainsi *(myPtr+0). Pour accéder au deuxième élément, vous devez ajouter 1 au pointeur, ce qui peut être exprimé *(myPtr+1).

Comme le compilateur sait que le pointeur est un pointeur d'entier, ajouter 1 à la référence pointeur consistera effectivement à incrémenter l'adresse contenue dans "myPtr" de 4 (de la taille d'un Entier). C'est pourquoi l'utilisation de pointeurs typés est préférable à celle des pointeurs non typés. Le compilateur effectue une grande partie du travail pour vous dans l'accès aux données dans le segment de mémoire.

Notez que la construction est *(myPtr+1) et non *myPtr+1. L'opérateur * est plus prioritaire que +, donc *myPtr+1  incrémentera effectivement le contenu de l'adresse pointée par myPtr, et non l'adresse du pointeur.

~-myPtr sera évalué en premier, il renverra le contenu de l'emplacement mémoire, puis +1 sera évalué, ajoutant 1 à l'emplacement de la mémoire. En encapsulant myPtr+1 entre parenthèses, vous forcez le compilateur à évaluer myPtr+1 d'abord, ce qui incrémente l'adresse du pointeur, puis le * est appliqué pour retourner le contenu de la nouvelle adresse.

L'indexation de pointeurs fonctionne de la même manière que l'arithmétique des pointeurs, mais les détails sont traîtés par le compilateur. *(myPtr+1) est équivalent à myPtr[1]. Encore une fois, puisque le compilateur sait que myPtr est un pointeur d'entier, il peut calculer les décalages mémoire corrects pour retourner les valeurs correctes à l'aide de l'indice. Quel est le format que vous utiliserez, la réponse vous appartient, mais la méthode avec indice ressemble à la méthode standard d'accès aux tableau et est visuellement plus facile à comprendre que l'opérateur d'indirection.

=== Fonctions pointeur ===

FreeBASIC a un ensemble de fonctions pointeur pour compléter les opérateurs pointeur.

~- [[KeyPgCptr Cptr]] Convertit une expression en un pointeur data_type. L'expression peut être un autre pointeur ou un entier.
~- [[KeyPgPeek Peek]] Peek retourne le contenu de l'emplacement mémoire pointé par le pointeur. Data_type spécifie le type de données attendues.
~- [[KeyPgPoke Poke]] Met la valeur de l'expression dans l'emplacement mémoire pointé par le pointeur. data_type spécifie le type de données à placer dans l'emplacement mémoire.
~- [[KeyPgSadd Sadd]] Renvoie l'emplacement mémoire où les données de la chaîne d'une chaîne dynamique sont situées.
~- [[KeyPgOpStrptr Strptr]] Comme Sadd.
~- [[KeyPgOpProcptr Procptr]] Renvoie l'adresse d'une fonction. Fnctionne de la même manière que l'opérateur @ (adresse de).
~- [[KeyPgOpVarptr Varptr]] Cette fonction fonctionne de la même manière que l'opérateur @ (adresse de).

Les fonctions Sadd et StrPtr travaillent avec les données des types chaînes pour retourner l'adresse de données de la chaîne. Les fonctions Peek et Poke ont été ajoutées aux fins de soutenir le code hérité. Procptr et Varptr fonctionnent toutes les deux exactement comme l'opérateur @ (adresse de), mais Proptr fonctionnent seulement sur les sous-programmes et  fonctions et Varptr seulement sur les variables. Cptr est utile pour changer (cast) un pointeur non typé en un pointeur typé, comme la valeur retournée d'une bibliothèque tierce partie.

=== Pointeurs de sous-programmes et de fonctions ===

Les sous-programmes et fonctions, comme les variables, résident en mémoire et ont une adresse associée à leur point d'entrée. Vous pouvez utiliser ces adresses pour créer des événements dans vos programmes, pour créer des pseudo-objets et sont utilisés dans des fonctions de rappel. Vous créez un pointeur de sous-programme ou de fonction comme tout autre pointeur, sauf vous déclarez votre variable comme un pointeur vers un sous-programme ou une fonction, plutôt que comme un pointeur vers un type de données.

Avant d'utiliser un pointeur de fonction, il doit être initialisé à l'adresse d'un sous-programme ou d'une fonction en utilisant "Procptr" ou @. Une fois initialisé, vous utilisez le pointeur de la même manière que pour appeler le sous-programme ou la fonction original.

Vous déclarez un pointeur de fonction en utilisant la syntaxe de déclaration anonyme.

%%(freebasic)
Dim FuncPtr As Function(x As Integer, y As Integer) As Integer
%%

Vous devez ensuite associer ce pointeur de fonction avec un sous-programme ou une fonction réel au sein de votre code.

%%(freebasic)
Function Power(number As Integer, pwr As Integer) As Integer
Return number^pwr
End Function

FuncPtr = @Power

%%

Vous pouvez alors appeler le pointeur de fonction un peu comme vous appelez la fonction réelle.

%%(freebasic)
FuncPtr(2, 4)
%%

Même si cela peut ne pas être utile à première vue, vous pouvez utiliser cette technique pour mettre en oeuvre des fonctions polymorphes, où une seule instance variable peut pointer vers l'un des sous-programmes ou l'une des fonctions choisi(e)s parmi une série de sous-programmes ou de fonctions différent(e)s.

Par exemple, supposons que vous avez des objets chien et de chat. Les deux objets ont besoin d'une méthode Speak. En définissant Speak comme un pointeur de fonction et en associant Speak avec un sous-programme Bark (aboyer) pour un chien et un sous-programme Meow (miauler) pour un chat, vous pouvez faire parler et émettre un "Woof!" ou "Miaou!" selon le type d'objet.

=== Création d'une fonction de rappel (callback) ===

Une des utilisations principales pour les pointeurs de fonction est de créer des fonctions de rappel (callback). Une fonction de rappel (callback) est une fonction que vous avez créée dans votre programme qui est appelée par une autre fonction ou un sous-programme, soit dans votre propre espace de code ou dans une bibliothèque externe. Windows utilise des fonctions de rappel (callback) pour dénombrer des objets Windows comme les polices, les imprimantes et les formes.

La fonction qsort contenue dans la Bibliothèque C Runtime trie les éléments d'un tableau en utilisant une fonction de rappel (callback) pour déterminer l'ordre de tri. Le prototype de la fonction qsort est contenu dans stdlib.bi:

%%(freebasic)
declare sub qsort cdecl alias "qsort" (byval as any ptr, byval as size_t, byval as size_t, byval as function cdecl(byval as any ptr, byval as any ptr) as integer)
%%

La liste suivante énumère les informations sur les paramètres du sous-programme qsort.

~Le premier paramètre est l'adresse du premier élément du tableau. La meilleure façon de transmettre cette information à qsort est d'ajouter l'opérateur "adresse de" à l'indice du premier élément: @myArray(0).
~Le deuxième paramètre est le nombre d'éléments dans le tableau, c'est le compte des éléments du tableau.
~Le troisième paramètre est la taille de chaque élément en octets. Pour un tableau d'entiers, la taille de l'élément serait de 4 octets.
~Le quatrième paramètre est un pointeur de fonction vers la fonction de comparaison créé par l'utilisateur. La fonction doit être déclarée avec le modèle de pasage Cdecl, comme indiqué dans ce paramètre.


En utilisant cette information, vous pouvez voir comment qsort fonctionne. En passant l'adresse du premier élément avec le compte des éléments et la taille de chaque élément, qsort peut parcourir le tableau en utilisant l'arithmétique des pointeurs.

Qsort prend deux éléments du tableau, les transmet à votre fonction de comparaison et utilise de valeur de retour de la fonction de comparaison pour trier les éléments du tableau. Elle répète cela jusqu'à ce que chaque élément du tableau soit dans l'ordre.

Vous devez déclarer le prototype de fonction Cdecl qui garantit la transmission des paramètres dans le bon ordre.

%%(freebasic)
Declare Function QCompare Cdecl (Byval e1 As Any Ptr, Byval e2 As Any Ptr) As Integer
%%

Vous pouvez ensuite définir la fonction comme ceci.

%%(freebasic)
'The qsort function expects three numbers
'from the compare function:
'-1: if e1 is less than e2
'0: if e1 is equal to e2
'1: if e1 is greater than e2
Function QCompare Cdecl (Byval e1 As Any Ptr, _
Byval e2 As Any Ptr) As Integer
Dim As Integer el1, el2
Static cnt As Integer

'Get the call count and items passed
cnt += 1
'Get the values, must cast to integer ptr
el1 = *(Cptr(Integer Ptr, e1))
el2 = *(Cptr(Integer Ptr, e2))
Print "Qsort called";cnt;" time(s) with";el1;" and";el2;"."
'Compare the values
If el1 < el2 Then
Return -1
Elseif el1 > el2 Then
Return 1
Else
	    Return 0
End If
End Function
%%

Vous pouvez ensuite appeler la fonction qsort en passant l'adresse de la fonction de rappel (callback).

%%(freebasic)
qsort @myArray(0), 10, Sizeof(Integer), @QCompare
%%

=== Pointeur vers un pointeur ===

En FreeBASIC vous pouvez créer un pointeur vers un des types de données pris en charge, y compris le type de données pointeur. Un pointeur vers un pointeur est utile dans les situations où vous devez retourner un pointeur vers une fonction ou dans la création de structures spécialisées de données tels que les listes liées et des tableaux non-rectangulaires. Un pointeur vers un pointeur est appelé indirection multi-niveau.

Une application d'un pointeur vers un pointeur est la création d'un segment de mémoire qui se comporte exactement comme un tableau. Par exemple, supposons que vous voulez créer un segment de mémoire pour contenir un nombre inconnu d'entiers. Vous pouvez créer un segment de mémoire dynamique que vous pouvez redimensionner si nécessaire en cours d'exécution pour traiter  autant d'entiers que nécessaire. Vous commencez par créer une variable pointeur-vers-pointeur.

%%(freebasic)
Dim myMemArray As Integer Ptr Ptr
%%

Vous pouvez ensuite initialiser la référence pointeur en utilisant Allocate ou Callocate.

%%(freebasic)
'Create 10 rows of integer pointers
myMemArray = Callocate(10, Sizeof(Integer Ptr))
%%

Notez que la variable est initialisée ave un //Integer Ptr// car cette liste va pointer vers une autre liste; c'est le pointeur qui pointe vers un autre pointeur. Vous pouvez ensuite initialiser les références individuelles des pointeurs qui viennent d'être créés pour pointer vers les segments de mémoire nécessaires.

%%(freebasic)
'Add 10 columns of integers to each row
For i = 0 To 9
myMemArray[i] = Callocate(10, Sizeof(Integer))
Next
%%

Dans cet extrait de code, les pointeurs individuels de la liste sont initialisés à 10 segments de mémoire qui contiendront des données entières réelles.

%%(freebasic)
'Add some data to the memory segment
For i = 0 To 9
For j = 0 To 9
myMemArray[i][j] = Int(Rnd * 10)
Next
Next
%%

Cet extrait de code utilise la méthode de l'indice pour charger les données réelles dans les segments de mémoire. Remarquez que cela ressemble et agit comme un tableau à deux dimensions. Tout cela ne semble pas utile dans ce contexte, vous pouvez utiliser ce code pour créer un tableau dynamique dans une définition de type. Puisque vous ne pouvez pas avoir un tableau standard dynamique au sein d'un type, ceci vous permet d'obtenir la même fonctionnalité.

Une chose dont vous devez être conscient est de savoir comment libérer une telle structure. La règle est de simplement faire l'inverse des opérations d'allocation. Depuis la dernière opération d'allocation qui a initialisé les segments de mémoire de données, vous désallouez d'abord ces segments de mémoire, puis vous pouvez désallouer le pointeur de base.

%%(freebasic)
'Free memory segment
For i = 0 To 9
Deallocate myMemArray[i]
Next

'Free the pointer to pointer
Deallocate myMemArray
%%

Vous devez être sûr que la désallocation se fait dans le bon ordre, sinon vous allez vous retrouver avec des segments de mémoire qui ne seront pas libérés, mais inaccessibles. Ce seront des fuites de mémoire et pourront causer une multitude de problèmes dans votre programme.

