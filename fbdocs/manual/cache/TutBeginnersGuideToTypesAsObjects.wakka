{{fbdoc item="title" value="Guide pour d&eacute;butants, de types en tant qu'objets (Partie 1)"}}----

**Introduction**

  Ce tutoriel est destiné aux personnes qui veulent en savoir plus sur les nouvelles fonctionnalités ajoutées à ##**Type**##, communément dénommées '//types comme des objets//' et '//du genre POO//' (Programmation Orientée Objets).  Il vise à vous guider à travers ces nouvelles fonctionnalités, ainsi est il destiné aux personnes qui ne comprennent pas vraiment encore, mais qui veulent apprendre.  Un ##**Type**## en FreeBASIC est un type de données agrégées, comme une structure en C ou un '//record//' en Pascal.  Voici un court exemple d'utilisation typique de ##**Type**##.

%%(freebasic)
Type person_info
  first_name As String
  last_name As String
  house_number As Integer
  street_name As String
  town As String
End Type
%%

Dans cette utilisation, il est employé comme un type de conteneur pour les données relatives; dans cet exemple, il pourrait être aussi une entrée dans un carnet d'adresses.  Avec les nouvelles fonctionnalités, cependant, il peut être utilisé plus comme une classe en ""C++"", car il peut faire beaucoup plus que contenir de simples champs de données.  Il devient un moyen d'exprimer une idée d'un objet, ce qui rend la programmation orientée objet beaucoup plus simple.  Nous allons maintenant examiner ces nouvelles fonctionnalités.

**Property**

Nous allons commencer par examiner la ##**Property**## (propriété).  Quand vous ajoutez une ##**Property**## à un ##**Type**##, vous y accéder comme s'il s'agissait d'un membre ordinaire, mais que se passe-t-il, est-ce seulement pour obtenir ou définir une variable comme d'habitude, au lieu de cela il appelle une fonction.  Jetez un oeil à cet exemple:

%%(freebasic)
Type bar
  Declare Property x() As Integer
  Declare Property x(ByVal n As Integer)
  p_x As Integer
End Type

Property bar.x() As Integer
  Print "bar.x()"
  Property = p_x
End Property

Property bar.x(ByVal n As Integer)
  Print "bar.x(ByVal n As Integer)"
  p_x = n
End Property

'---

Dim foo As bar

foo.x = 5
Print foo.x
%%

Nous incluons dans notre ##**Type**## certaines déclarations de ##**Property**##; elles sont très semblables aux déclarations de fonction ordinaires.  La première déclare un procureur (getter), la seconde un fixeur (setter).  Le membre ##p_x## est simplement un nombre ##**Integer**##.

Ensuite, nous écrivons le code pour les ##**Property**##; encore une fois, la syntaxe est très similaire à celle des fonctions normales.  Notez la manière dont nous retournons une valeur: au lieu de ##**Function = valeur**##, nous faisons ##**Property = valeur**##.  Vous pouvez faire aussi ##**Return valeur**##.  Notez également que vous pouvez vous référer directement au membre ##**p_x**##; vous pouvez également utiliser le mot-clé ##**this**##, par exemple ##**this.p_x = n**##; utiliser ##**this**## n'est généralement pas nécessaire, mais il peut aider dans certaines circonstances ambiguës.

Vient ensuite un peu de code de test; cela montre comment nous pouvons utiliser ##**Property**## comme s'il s'agissait d'un membre ordinaire.  Lorsque vous exécutez le programme, il sera également affiché à l'écran pour montrer quel code de ##**Property**## "get/set" a été appelé.

Maintenant, ce code est assez trivial, mais comme on s'habitue à l'idée vous verrez qu'il peut être utilisé pour certains bons usages.  Imaginez, comme un exemple, que vous écrivez une interface graphique (GUI) et que le ##**Type**## représente un bouton sur l'écran, vous pourriez avoir ##**button.text = "Hello World!"**##, et faire que le code de ##**Property**## mette à jour l'écran pour montrer les changements.  Ou peut-être que vous utilisez ##**Type**## pour maintenir une sorte de liste; vous pouvez avoir ##**list.size += 10**## et puis mettre un peu de code dans votre ##**Property**## de rendre la liste plus grande.

**Constructeur/Destructeur**

Les ##**Constructor**##s sont des fonctions qui sont appelées quand le ##**Type**## est créé - lorsque vous utilisez ##**Dim**##, par exemple.  Un ##**Destructor**## est une fonction appelée quand ##**Type**## sort de la portée; il peut s'agir de la fin du programme, pour un ##**Type**## dans le code principal ou quand une fonction se termine, pour un ##**Type**## local.  Regardez l'exemple suivant, expansion du précédent.

%%(freebasic)
Type bar
  Declare Constructor()
  Declare Destructor()
  Declare Property x() As Integer
  Declare Property x(ByVal n As Integer)
  p_x As Integer ptr
End Type

Constructor bar()
  Print "Constructor bar()"
  p_x = Allocate(sizeof(Integer))
  *p_x = 10
End Constructor

Destructor bar()
  Print "Destructor bar()"
  DeAllocate(p_x)
End Destructor

Property bar.x() As Integer
  Print "bar.x()"
  Property = *p_x
End Property

Property bar.x(ByVal n As Integer)
  Print "bar.x(ByVal n As Integer)"
  *p_x = n
End Property

'---

Dim foo As bar

Print foo.x
foo.x = 5
Print foo.x
%%

Encore une fois la syntaxe est quelque peu semblable à toutes les fonctions normales.  Notez que cette fois j'ai modifié ##**p_x**## pour un ##**Integer ptr**##.  Le ##**Constructor**##, ensuite ##**Allocate**## de la mémoire pour lui quand ##**foo**## est créé, et lui donne une valeur par défaut; puis le ##**Destructor**## ##**Deallocate**## cette mémoire.  Ainsi, vous pouvez utiliser ##**Constructor**##s et ##**Destructor**##s pour mettre les choses en place pour vous, puis nettoyer une fois terminé.  Retour sur un exemple trivial, ramenant l'exemple d'une certaine liste, la mettant en place pour vous et la nettoyant lorsque tout est fini, cela peut être très pratique.

**Méthodes**

Vous pouvez également avoir des ##**Sub**##s et ##**Function**##s ordinaires dans votre ##**Type**##; dans une certaine terminologie, ce sont des méthodes.  Nous allons poursuivre notre exemple:

%%(freebasic)
Type bar
  Declare Constructor()
  Declare Destructor()
  Declare Property x() As Integer
  Declare Property x(ByVal n As Integer)
  Declare Sub Mul5()
  Declare Function Addr() As Integer ptr
  p_x As Integer ptr
End Type

Constructor bar()
  Print "Constructor bar()"
  p_x = Allocate(sizeof(Integer))
  *p_x = 10
End Constructor

Destructor bar()
  Print "Destructor bar()"
  DeAllocate(p_x)
End Destructor

Property bar.x() As Integer
  Print "bar.x()"
  Property = *p_x
End Property

Property bar.x(ByVal n As Integer)
  Print "bar.x(ByVal n As Integer)"
  *p_x = n
End Property

Sub bar.mul5()
  *p_x *= 5
End Sub

Function bar.Addr() As Integer ptr
  Function = p_x
End Function

'---

Dim foo As bar

Print foo.x
foo.x = 5
Print foo.x
foo.mul5()
Print foo.x
Print "address p_x points to", foo.Addr()
%%

Alors, cette fois nous avons ajouté une ##**Sub**##, qui multiplie par 5 l'entier pointé par ##**p_x**## et une fonction qui récupère l'adresse mémoire contenue dans ce pointeur.

**Private/Public**

Par défaut, tous les membres du ##**Type bar**## sont ##**Public**##; cela signifie que nous pouvons les lire/écrire ou appeler.  Cependant, parfois, vous voudrez peut-être les rendre ##**Private**##.  Prenons l'exemple de notre membre ##**p_x**##; alors nous pouvons faire ##**Print *foo.p_x**## et cela nous permettra d'afficher la valeur vers laquelle il pointe.  Nous pourrions vouloir le rendre ##**Private**##, de sorte que seuls les membres du ##**Type bar**## (##**Constructor**##, ##**Destructor**##, ##**Property**## et ##**Méthodes**##) peuvent y accéder.  De cette façon, nous pouvons nous assurer que nous ne traîtons avec ##**p_x**## que par les moyens que nous avons choisis.  Si par exemple on '##**Deallocate(foo.p_x)**##' dans notre code principal, lorsque le ##**Destructor**## fonctionnera, il essaiera de le libérer à nouveau, ce qui est connu sous le nom de "double libération".  Modifiez la déclaration de ##**Type**## comme suit:

%%(freebasic)
Type bar
  Declare Constructor()
  Declare Destructor()
  Declare Property x() As Integer
  Declare Property x(ByVal n As Integer)
  Declare Sub Mul5()
  Declare Function Addr() As Integer ptr
private:
  p_x As Integer ptr
End Type
%%

Maintenant, essayez d'ajouter ##**Print *foo.p_x**## dans le code principal et compilez-le.  Vous recevrez un message de fbc ##**error 173: Illegal member access, found 'p_x' in 'Print *foo.p_x'**##, montrant bien que le compilateur est maintenant obligé de faire respecter le fait que nous avons déclaré ##**p_x Private**##.  Quand vous utilisez ##**Private:**## ou ##**Public:**##, tous les membres suivant cette déclaration suivent la règle.  Voici un exemple, assez inutile, juste pour montrer la syntaxe:

%%(freebasic)
Type bar
private:
  a As Integer
  b As Integer
public:
  c As Integer
  d As Integer
private:
  e As Integer
End Type
%%

Dans le ##**Type**## ci-dessus, les membres ##a##, ##b## et ##e## sont ##**Private**##; ##c## et ##d## sont ##**Public**##.

**Surcharge des opérateurs**

La surcharge d'opérateur est une façon de dire au compilateur ce qu'il faut faire dans le cas où nous voulons effectuer une certaine sorte d'opération impliquant notre ##**Type**##.  Prenez cet exemple:

%%(freebasic)
Type bar
  n As Integer
End Type

Dim As bar x, y, z

z = x + y
%%

Maintenant, normalement le compilateur génère une erreur lorsqu'il voit cela, car il n'a aucune idée de comment ajouter ensemble deux ##**Type**##s, mais nous pouvons définir ce que nous voulons qu'il se produise.  Voici comment:

%%(freebasic)
Type bar
  n As Integer
End Type

Operator +(ByRef lhs As bar, ByRef rhs As bar) As bar
  Operator = type(lhs.n + rhs.n)
End Operator

Dim As bar x, y, z

x.n = 5
y.n = 10
z = x + y
Print z.n
%%

Dans ce code, j'utilise ##**lhs**## (left-hand) et ##**rhs**## (right-hand) pour désigner les opérandes du côté gauche et du côté droit de l'opérateur.  Notez aussi l'expression ##**type(lhs.n + rhs.n)**##; ceci construit le ##**Type**## qui sera retourné.  Si vous aviez un ##**Type**## comme:

%%(freebasic)
Type bar
  x As Integer
  y As Integer
  z As Integer
End Type
%%

Vous l'auriez construit ainsi ##**type(xpart, ypart, zpart)**##.

La plupart ou tous les opérateurs peuvent être surchargés, et la plupart d'entre eux sont des opérateurs binaires, ce qui signifie qu'ils ont deux opérandes comme dans l'exemple **+** ci-dessus.  Certains sont des opérateurs unaires ayant seulement le côté droit, comme ##**Not**## et ##**- unaire**##.  Ils seraient obtenus comme ceci ##**Operator Not(ByRef rhs As bar) As bar**##.

Il y a quelques cas particuliers où ils doivent être déclarés à l'intérieur du ##**Type**##; ce sont les opérateurs d'affectation et les "cast".

Les opérateurs d'affectation sont comme ceci ##**+= -= mod=**## etc, et aussi ##**Let**##.  ##**Let**## est utilisé lorsque vous faites une tâche d'affectation comme:

%%(freebasic)
Dim As bar foo
Dim As Integer x
foo = x
%%

Et "casts" sont des cas inverses, ils sont utilisés lorsque vous "cast" vers un autre type de données comme ceci:

%%(freebasic)
Dim As bar foo
Dim As Integer x
x = foo
%%

Voici un court exemple utilisant ##**Let**## et ##**Cast**##:

%%(freebasic)
Type bar
  n As Integer
  Declare Operator Let(ByRef rhs As Integer)
  Declare Operator Let(ByRef rhs As String)
  Declare Operator Cast() As String
End Type

Operator bar.Let(ByRef rhs As Integer)
  n = rhs
End Operator

Operator bar.Let(ByRef rhs As String)
  n = Val(rhs)
End Operator

Operator bar.Cast() As String
  Operator = Str(n)
End Operator

Operator +(ByRef lhs As bar, ByRef rhs As bar) As bar
  Operator = type(lhs.n + rhs.n)
End Operator

Dim As bar x, y, z

x = 5
y = "10"
z = x + y
Print z
%%

Vous devez avoir séparé les **let**s et **cast**s pour chaque type de données que vous voulez supporter. Les opérateurs qui doivent être déclarés dans le ##**Type**## sont connus comme non-statiques et ceux qui ne sont pas connus comme globals.  Il y a une raison technique pour cela; les non-statiques doivent savoir à quelle instance (dans le jargon technique, dans notre exemple précédent, nous dirions que ##**x**## est une instance de ##**bar**##) de ##**Type**## ils font référence et ceci est accompli par la référence cachée ##**this**##.  Cette référence cachée ##**this**## est le moyen pour que les autres membres comme les opérateurs et les méthodes sachent à quelle instance de ##**Type**## se réfère l'appel.  La plupart des opérateurs peuvent être surchargés; voici une liste de ceux qui actuellement peuvent l'être:

opérateurs d'affectation:
  ##let##, ##+=##, ##-=##, ##*=##, ##/=##, ##\=##, ##mod=##, ##shl=##, ##shr=##, ##and=##, ##or=##, ##xor=##, ##imp=##, ##eqv=##, ##^=##
opérateurs unaires:
  ##-##, ##not##, ##@##, ##*##, ##->##
opérateurs binaires:
  ##+##, ##-##, ##*##, ##/##, ##\##, ##mod##, ##shl##, ##shr##, ##and##, ##or##, ##xor##, ##imp##, ##eqv##, ##^##, ##=##, ##<>##, ##<##, ##>##, ##<=##, ##>=##

**Constructeurs/Méthodes surchargés**

Comme pour les fonctions normales, le ##**Constructor**## et les méthodes de notre ##**Type**## peuvent être surchargés.  Pour les ##**Constructor**##s, cela fournit un moyen de spécifier les détails sur la façon dont l'instance doit l'être construite.  Voici un court exemple:

%%(freebasic)
Type bar
  Declare Constructor()
  Declare Constructor(ByVal initial_val As Integer)
  x As Integer
End Type

Constructor bar()
  x = 10
End Constructor

Constructor bar(ByVal initial_val As Integer)
  x = initial_val
End Constructor

Dim foo As bar
Print foo.x

Dim baz As bar = bar(25)
Print baz.x
%%

Le premier ##**Constructor**##, qui n'a aucun argument, est appelé le ##**Constructor**## par défaut.  Il définit ##foo.x## avec une valeur initiale de 10.  Cependant, nous avons aussi spécifié un autre ##**Constructor**## qui accepte une valeur initiale.  Notez la manière avec laquelle nous l'appelons ##**Dim baz As bar = bar(25)**##.  Vous pouvez également omettre le ##**Constructor**## par défaut et alors vous devrez toujours spécifier une valeur initiale en utilisant le ##**Constructor**## qui nécessite un argument. Vous ne pouvez pas avoir un ##**Destructor**## surchargé, parce qu'il n'existe aucun moyen manuel de choisir celui que vous désirez appeler.

Les méthodes surchargées sont très similaires:

%%(freebasic)
Type bar
  Declare Sub foo()
  Declare Sub foo(ByVal some_value As Integer)
  Declare Sub foo(ByRef some_value As String, ByVal some_other As Integer)
  x As Integer
End Type
%%

Elles fonctionnent de la même façon que les fonctions normales surchargées.

**Clôture**

J'espère que ce tutoriel vous a été utile, mais il y a encore quelques petites choses à apprendre; si vous avez pu aller jusqu'ici, il ne devrait pas être trop difficile pour vous de les intégrer.  Il y a quelques informations disponibles dans le wiki et sur les forums, et aussi dans la partie 2 de ce tutoriel qui est disponible ici - [[TutBeginnersGuideToTypesAsObjects2 Guide pour débutants, de types en tant qu'objets (Partie 2)]]

**Lectures supplémentaires**

	- ##[[KeyPgProperty Property]]##
	- ##[[KeyPgConstructor Constructor]]##
	- ##[[KeyPgDestructor Destructor]]##
	- ##[[KeyPgOperator Operator]]##
	- ##[[KeyPgThis This]]##
	- [[KeyPgTypeTemp Types anonymes]]
	- [[ProPgTypeObjects Types comme objets]]
	- ##[[KeyPgVisPublic Public:]]##
	- ##[[KeyPgVisPrivate Private:]]##
	- ##[[KeyPgVisProtected Protected:]]##

