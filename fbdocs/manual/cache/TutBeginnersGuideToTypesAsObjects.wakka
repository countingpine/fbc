{{fbdoc item="title" value="Beginners Guide to Types as Objects"}}----

**Introduction**

  Ce tutoriel est destin&eacute; aux personnes qui veulent en savoir plus sur les nouvelles fonctionnalit&eacute;s ajout&eacute;es &agrave; ##**Type**##, commun&eacute;ment d&eacute;nomm&eacute;es '//types comme des objets//' et '//du genre POO//' (Programmation Orient&eacute;e Objets).  Il vise &agrave; vous guider &agrave; travers ces nouvelles fonctionnalit&eacute;s, ainsi est il destin&eacute; aux personnes qui ne comprennent pas vraiment encore, mais qui veulent apprendre.  Un ##**Type**## en FreeBASIC est un type de donn&eacute;es agr&eacute;g&eacute;es, comme une structure en C ou un '//record//' en Pascal.  Voici un court exemple d'utilisation typique de ##**Type**##.

%%(freebasic)
Type person_info
  first_name As String
  last_name As String
  house_number As Integer
  street_name As String
  town As String
End Type
%%

Dans cette utilisation, il est employ&eacute; comme un type de conteneur pour les donn&eacute;es relatives; dans cet exemple, il pourrait &ecirc;tre aussi une entr&eacute;e dans un carnet d'adresses.  Avec les nouvelles fonctionnalit&eacute;s, cependant, il peut &ecirc;tre utilis&eacute; plus comme une classe en C++, car il peut faire beaucoup plus que contenir de simples champs de donn&eacute;es.  Il devient un moyen d'exprimer une id&eacute;e d'un objet, ce qui rend la programmation orient&eacute;e objet beaucoup plus simple.  Nous allons maintenant examiner ces nouvelles fonctionnalit&eacute;s.

**Property**

Nous allons commencer par examiner la ##**Property**## (propri&eacute;t&eacute;).  Quand vous ajoutez une ##**Property**## &agrave; un ##**Type**##, vous y acc&eacute;der comme s'il s'agissait d'un membre ordinaire, mais que se passe-t-il, est-ce seulement pour obtenir ou d&eacute;finir une variable comme d'habitude, au lieu de cela il appelle une fonction.  Jetez un oeil &agrave; cet exemple:

%%(freebasic)
Type bar
  Declare Property x() As Integer
  Declare Property x(ByVal n As Integer)
  p_x As Integer
End Type

Property bar.x() As Integer
  Print "bar.x()"
  Property = p_x
End Property

Property bar.x(ByVal n As Integer)
  Print "bar.x(ByVal n As Integer)"
  p_x = n
End Property

'---

Dim foo As bar

foo.x = 5
Print foo.x
%%

Nous incluons dans notre ##**Type**## certaines d&eacute;clarations de ##**Property**##; elles sont tr&egrave;s semblables aux d&eacute;clarations de fonction ordinaires.  La premi&egrave;re d&eacute;clare un procureur (getter), la seconde un fixeur (setter).  Le membre ##p_x## est simplement un nombre ##**Integer**##.

Ensuite, nous &eacute;crivons le code pour les ##**Property**##; encore une fois, la syntaxe est tr&egrave;s similaire &agrave; celle des fonctions normales.  Notez la mani&egrave;re dont nous retournons une valeur: au lieu de ##**Function = valeur**##, nous faisons ##**Property = valeur**##.  Vous pouvez faire aussi ##**Return valeur**##.  Notez &eacute;galement que vous pouvez vous r&eacute;f&eacute;rer directement au membre ##**p_x**##; vous pouvez &eacute;galement utiliser le mot-cl&eacute; ##**this**##, par exemple ##**this.p_x = n**##; utiliser ##**this**## n'est g&eacute;n&eacute;ralement pas n&eacute;cessaire, mais il peut aider dans certaines circonstances ambigu&euml;s.

Vient ensuite un peu de code de test; cela montre comment nous pouvons utiliser ##**Property**## comme s'il s'agissait d'un membre ordinaire.  Lorsque vous ex&eacute;cutez le programme, il sera &eacute;galement affich&eacute; &agrave; l'&eacute;cran pour montrer quel code de ##**Property**## "get/set" a &eacute;t&eacute; appel&eacute;.

Maintenant, ce code est assez trivial, mais comme on s'habitue &agrave; l'id&eacute;e vous verrez qu'il peut &ecirc;tre utilis&eacute; pour certains bons usages.  Imaginez, comme un exemple, que vous &eacute;crivez une interface graphique (GUI) et que le ##**Type**## repr&eacute;sente un bouton sur l'&eacute;cran, vous pourriez avoir ##**button.text = "Hello World!"**##, et faire que le code de ##**Property**## mette &agrave; jour l'&eacute;cran pour montrer les changements.  Ou peut-&ecirc;tre que vous utilisez ##**Type**## pour maintenir une sorte de liste; vous pouvez avoir ##**list.size += 10**## et puis mettre un peu de code dans votre ##**Property**## de rendre la liste plus grande.

**Constructeur/Destructeur**

Les ##**Constructor**##s sont des fonctions qui sont appel&eacute;es quand le ##**Type**## est cr&eacute;&eacute; - lorsque vous utilisez ##**Dim**##, par exemple.  Un ##**Destructor**## est une fonction appel&eacute;e quand ##**Type**## sort de la port&eacute;e; il peut s'agir de la fin du programme, pour un ##**Type**## dans le code principal ou quand une fonction se termine, pour un ##**Type**## local.  Regardez l'exemple suivant, expansion du pr&eacute;c&eacute;dent.

%%(freebasic)
Type bar
  Declare Constructor()
  Declare Destructor()
  Declare Property x() As Integer
  Declare Property x(ByVal n As Integer)
  p_x As Integer ptr
End Type

Constructor bar()
  Print "Constructor bar()"
  p_x = Allocate(sizeof(Integer))
  *p_x = 10
End Constructor

Destructor bar()
  Print "Destructor bar()"
  DeAllocate(p_x)
End Destructor

Property bar.x() As Integer
  Print "bar.x()"
  Property = *p_x
End Property

Property bar.x(ByVal n As Integer)
  Print "bar.x(ByVal n As Integer)"
  *p_x = n
End Property

'---

Dim foo As bar

Print foo.x
foo.x = 5
Print foo.x
%%

Encore une fois la syntaxe est quelque peu semblable &agrave; toutes les fonctions normales.  Notez que cette fois j'ai modifi&eacute; ##**p_x**## pour un ##**Integer ptr**##.  Le ##**Constructor**##, ensuite ##**Allocate**## de la m&eacute;moire pour lui quand ##**foo**## est cr&eacute;&eacute;, et lui donne une valeur par d&eacute;faut; puis le ##**Destructor**## ##**Deallocate**## cette m&eacute;moire.  Ainsi, vous pouvez utiliser ##**Constructor**##s et ##**Destructor**##s pour mettre les choses en place pour vous, puis nettoyer une fois termin&eacute;.  Retour sur un exemple trivial, ramenant l'exemple d'une certaine liste, la mettant en place pour vous et la nettoyant lorsque tout est fini, cela peut &ecirc;tre tr&egrave;s pratique.

**M&eacute;thodes**

Vous pouvez &eacute;galement avoir des ##**Sub**##s et ##**Function**##s ordinaires dans votre ##**Type**##; dans une certaine terminologie, ce sont des m&eacute;thodes.  Nous allons poursuivre notre exemple:

%%(freebasic)
Type bar
  Declare Constructor()
  Declare Destructor()
  Declare Property x() As Integer
  Declare Property x(ByVal n As Integer)
  Declare Sub Mul5()
  Declare Function Addr() As Integer ptr
  p_x As Integer ptr
End Type

Constructor bar()
  Print "Constructor bar()"
  p_x = Allocate(sizeof(Integer))
  *p_x = 10
End Constructor

Destructor bar()
  Print "Destructor bar()"
  DeAllocate(p_x)
End Destructor

Property bar.x() As Integer
  Print "bar.x()"
  Property = *p_x
End Property

Property bar.x(ByVal n As Integer)
  Print "bar.x(ByVal n As Integer)"
  *p_x = n
End Property

Sub bar.mul5()
  *p_x *= 5
End Sub

Function bar.Addr() As Integer ptr
  Function = p_x
End Function

'---

Dim foo As bar

Print foo.x
foo.x = 5
Print foo.x
foo.mul5()
Print foo.x
Print "address p_x points to", foo.Addr()
%%

Alors, cette fois nous avons ajout&eacute; une ##**Sub**##, qui multiplie par 5 l'entier point&eacute; par ##**p_x**## et une fonction qui r&eacute;cup&egrave;re l'adresse m&eacute;moire contenue dans ce pointeur.

**Private/Public**

Par d&eacute;faut, tous les membres du ##**Type bar**## sont ##**Public**##; cela signifie que nous pouvons les lire/&eacute;crire ou appeler.  Cependant, parfois, vous voudrez peut-&ecirc;tre les rendre ##**Private**##.  Prenons l'exemple de notre membre ##**p_x**##; alors nous pouvons faire ##**Print *foo.p_x**## et cela nous permettra d'afficher la valeur vers laquelle il pointe.  Nous pourrions vouloir le rendre ##**Private**##, de sorte que seuls les membres du ##**Type bar**## (##**Constructor**##, ##**Destructor**##, ##**Property**## et ##**M&eacute;thodes**##) peuvent y acc&eacute;der.  De cette fa&ccedil;on, nous pouvons nous assurer que nous ne tra&icirc;tons avec ##**p_x**## que par les moyens que nous avons choisis.  Si par exemple on '##**Deallocate(foo.p_x)**##' dans notre code principal, lorsque le ##**Destructor**## fonctionnera, il essaiera de le lib&eacute;rer &agrave; nouveau, ce qui est connu sous le nom de "double lib&eacute;ration".  Modifiez la d&eacute;claration de ##**Type**## comme suit:

%%(freebasic)
Type bar
  Declare Constructor()
  Declare Destructor()
  Declare Property x() As Integer
  Declare Property x(ByVal n As Integer)
  Declare Sub Mul5()
  Declare Function Addr() As Integer ptr
private:
  p_x As Integer ptr
End Type
%%

Maintenant, essayez d'ajouter ##**Print *foo.p_x**## dans le code principal et compilez-le.  Vous recevrez un message de fbc ##**error 173: Illegal member access, found 'p_x' in 'Print *foo.p_x'**##, montrant bien que le compilateur est maintenant oblig&eacute; de faire respecter le fait que nous avons d&eacute;clar&eacute; ##**p_x Private**##.  Quand vous utilisez ##**Private:**## ou ##**Public:**##, tous les membres suivant cette d&eacute;claration suivent la r&egrave;gle.  Voici un exemple, assez inutile, juste pour montrer la syntaxe:

%%(freebasic)
Type bar
private:
  a As Integer
  b As Integer
public:
  c As Integer
  d As Integer
private:
  e As Integer
End Type
%%

Dans le ##**Type**## ci-dessus, les membres ##a##, ##b## et ##e## sont ##**Private**##; ##c## et ##d## sont ##**Public**##.

**Surcharge des op&eacute;rateurs**

La surcharge d'op&eacute;rateur est une fa&ccedil;on de dire au compilateur ce qu'il faut faire dans le cas o&ugrave; nous voulons effectuer une certaine sorte d'op&eacute;ration impliquant notre ##**Type**##.  Prenez cet exemple:

%%(freebasic)
Type bar
  n As Integer
End Type

Dim As bar x, y, z

z = x + y
%%

Maintenant, normalement le compilateur g&eacute;n&egrave;re une erreur lorsqu'il voit cela, car il n'a aucune id&eacute;e de comment ajouter ensemble deux ##**Type**##s, mais nous pouvons d&eacute;finir ce que nous voulons qu'il se produise.  Voici comment:

%%(freebasic)
Type bar
  n As Integer
End Type

Operator +(ByRef lhs As bar, ByRef rhs As bar) As bar
  Operator = type(lhs.n + rhs.n)
End Operator

Dim As bar x, y, z

x.n = 5
y.n = 10
z = x + y
Print z.n
%%

Dans ce code, j'utilise ##**lhs**## (left-hand) et ##**rhs**## (right-hand) pour d&eacute;signer les op&eacute;randes du c&ocirc;t&eacute; gauche et du c&ocirc;t&eacute; droit de l'op&eacute;rateur.  Notez aussi l'expression ##**type(lhs.n + rhs.n)**##; ceci construit le ##**Type**## qui sera retourn&eacute;.  Si vous aviez un ##**Type**## comme:

%%(freebasic)
Type bar
  x As Integer
  y As Integer
  z As Integer
End Type
%%

Vous l'auriez construit ainsi ##**type(xpart, ypart, zpart)**##.

La plupart ou tous les op&eacute;rateurs peuvent &ecirc;tre surcharg&eacute;s, et la plupart d'entre eux sont des op&eacute;rateurs binaires, ce qui signifie qu'ils ont deux op&eacute;randes comme dans l'exemple **+** ci-dessus.  Certains sont des op&eacute;rateurs unaires ayant seulement le c&ocirc;t&eacute; droit, comme ##**Not**## et ##**- unaire**##.  Ils seraient obtenus comme ceci ##**Operator Not(ByRef rhs As bar) As bar**##.

Il y a quelques cas particuliers o&ugrave; ils doivent &ecirc;tre d&eacute;clar&eacute;s &agrave; l'int&eacute;rieur du ##**Type**##; ce sont les op&eacute;rateurs d'affectation et les "cast".

Les op&eacute;rateurs d'affectation sont comme ceci ##**+= -= mod=**## etc, et aussi ##**Let**##.  ##**Let**## est utilis&eacute; lorsque vous faites une t&acirc;che d'affectation comme:

%%(freebasic)
Dim As bar foo
Dim As Integer x
foo = x
%%

Et "casts" sont des cas inverses, ils sont utilis&eacute;s lorsque vous "cast" vers un autre type de donn&eacute;es comme ceci:

%%(freebasic)
Dim As bar foo
Dim As Integer x
x = foo
%%

Voici un court exemple utilisant ##**Let**## et ##**Cast**##:

%%(freebasic)
Type bar
  n As Integer
  Declare Operator Let(ByRef rhs As Integer)
  Declare Operator Let(ByRef rhs As String)
  Declare Operator Cast() As String
End Type

Operator bar.Let(ByRef rhs As Integer)
  n = rhs
End Operator

Operator bar.Let(ByRef rhs As String)
  n = Val(rhs)
End Operator

Operator bar.Cast() As String
  Operator = Str(n)
End Operator

Operator +(ByRef lhs As bar, ByRef rhs As bar) As bar
  Operator = type(lhs.n + rhs.n)
End Operator

Dim As bar x, y, z

x = 5
y = "10"
z = x + y
Print z
%%

Vous devez avoir s&eacute;par&eacute; les **let**s et **cast**s pour chaque type de donn&eacute;es que vous voulez supporter. Les op&eacute;rateurs qui doivent &ecirc;tre d&eacute;clar&eacute;s dans le ##**Type**## sont connus comme non-statiques et ceux qui ne sont pas connus comme globals.  Il y a une raison technique pour cela; les non-statiques doivent savoir &agrave; quelle instance (dans le jargon technique, dans notre exemple pr&eacute;c&eacute;dent, nous dirions que ##**x**## est une instance de ##**bar**##) de ##**Type**## ils font r&eacute;f&eacute;rence et ceci est accompli par la r&eacute;f&eacute;rence cach&eacute;e ##**this**##.  Cette r&eacute;f&eacute;rence cach&eacute;e ##**this**## est le moyen pour que les autres membres comme les op&eacute;rateurs et les m&eacute;thodes sachent &agrave; quelle instance de ##**Type**## se r&eacute;f&egrave;re l'appel.  La plupart des op&eacute;rateurs peuvent &ecirc;tre surcharg&eacute;s; voici une liste de ceux qui actuellement peuvent l'&ecirc;tre:

op&eacute;rateurs d'affectation:
  ##let##, ##+=##, ##-=##, ##*=##, ##/=##, ##\=##, ##mod=##, ##shl=##, ##shr=##, ##and=##, ##or=##, ##xor=##, ##imp=##, ##eqv=##, ##^=##
op&eacute;rateurs unaires:
  ##-##, ##not##, ##@##, ##*##, ##->##
op&eacute;rateurs binaires:
  ##+##, ##-##, ##*##, ##/##, ##\##, ##mod##, ##shl##, ##shr##, ##and##, ##or##, ##xor##, ##imp##, ##eqv##, ##^##, ##=##, ##<>##, ##<##, ##>##, ##<=##, ##>=##

**Constructeurs/M&eacute;thodes surcharg&eacute;s**

Comme pour les fonctions normales, le ##**Constructor**## et les m&eacute;thodes de notre ##**Type**## peuvent &ecirc;tre surcharg&eacute;s.  Pour les ##**Constructor**##s, cela fournit un moyen de sp&eacute;cifier les d&eacute;tails sur la fa&ccedil;on dont l'instance doit l'&ecirc;tre construite.  Voici un court exemple:

%%(freebasic)
Type bar
  Declare Constructor()
  Declare Constructor(ByVal initial_val As Integer)
  x As Integer
End Type

Constructor bar()
  x = 10
End Constructor

Constructor bar(ByVal initial_val As Integer)
  x = initial_val
End Constructor

Dim foo As bar
Print foo.x

Dim baz As bar = bar(25)
Print baz.x
%%

Le premier ##**Constructor**##, qui n'a aucun argument, est appel&eacute; le ##**Constructor**## par d&eacute;faut.  Il d&eacute;finit ##foo.x## avec une valeur initiale de 10.  Cependant, nous avons aussi sp&eacute;cifi&eacute; un autre ##**Constructor**## qui accepte une valeur initiale.  Notez la mani&egrave;re avec laquelle nous l'appelons ##**Dim baz As bar = bar(25)**##.  Vous pouvez &eacute;galement omettre le ##**Constructor**## par d&eacute;faut et alors vous devrez toujours sp&eacute;cifier une valeur initiale en utilisant le ##**Constructor**## qui n&eacute;cessite un argument. Vous ne pouvez pas avoir un ##**Destructor**## surcharg&eacute;, parce qu'il n'existe aucun moyen manuel de choisir celui que vous d&eacute;sirez appeler.

Les m&eacute;thodes surcharg&eacute;es sont tr&egrave;s similaires:

%%(freebasic)
Type bar
  Declare Sub foo()
  Declare Sub foo(ByVal some_value As Integer)
  Declare Sub foo(ByRef some_value As String, ByVal some_other As Integer)
  x As Integer
End Type
%%

Elles fonctionnent de la m&ecirc;me fa&ccedil;on que les fonctions normales surcharg&eacute;es.

**Cl&ocirc;ture**

J'esp&egrave;re que ce tutoriel vous a &eacute;t&eacute; utile, mais il y a encore quelques petites choses &agrave; apprendre; si vous avez pu aller jusqu'ici, il ne devrait pas &ecirc;tre trop difficile pour vous de les int&eacute;grer.  Il y a quelques informations disponibles dans le wiki et sur les forums, et aussi dans la partie 2 de ce tutoriel qui est disponible ici - [[TutBeginnersGuideToTypesAsObjects2 Guide pour d&eacute;butants, de types en tant qu'objets (Partie 2)]]

**Lectures suppl&eacute;mentaires**

	- ##[[KeyPgProperty Property]]##
	- ##[[KeyPgConstructor Constructor]]##
	- ##[[KeyPgDestructor Destructor]]##
	- ##[[KeyPgOperator Operator]]##
	- ##[[KeyPgThis This]]##
	- [[KeyPgTypeTemp Types anonymes]]
	- [[ProPgTypeObjects Types comme objets]]
	- ##[[KeyPgVisPublic Public:]]##
	- ##[[KeyPgVisPrivate Private:]]##
	- ##[[KeyPgVisProtected Protected:]]##