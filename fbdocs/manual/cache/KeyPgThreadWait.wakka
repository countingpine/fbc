{{fbdoc item="title" value="THREADWAIT"}}----
Attend jusqu'&agrave; ce que le "thread" d&eacute;sign&eacute; ait termin&eacute; son ex&eacute;cution avant de retourner

{{fbdoc item="syntax"}}##
	[[KeyPgDeclare declare]] [[KeyPgSub sub]] **Threadwait** ( [[KeyPgByval byval]] //id// [[KeyPgAs as]] [[KeyPgAny any]] [[KeyPgPtr ptr]] )
##
{{fbdoc item="usage"}}##
	**Threadwait**( //id// )
##
{{fbdoc item="param"}}
	##//id//##
		Le handle ##[[KeyPgAny Any]] [[KeyPgPtr Ptr]]## d'un "thread" cr&eacute;&eacute; par ##[[KeyPgThreadCreate ThreadCreate]]##

{{fbdoc item="desc"}}
	##Threadwait## ne retourne pas tant que le "thread" d&eacute;sign&eacute; par ##//id//## se termine. ##Threadwait## ne force pas le "thread" &agrave; terminer son ex&eacute;cution; si un "thread" a besoin d'un signal pour terminer son ex&eacute;cution, un m&eacute;canisme tel qu'une variable partag&eacute;e doit &ecirc;tre utilis&eacute;.

	Les "threads" sont lanc&eacute;s par la fonction ##[[KeyPgThreadCreate ThreadCreate]]##.

	Pour &eacute;viter l'acc&egrave;s simultan&eacute; aux ressources partag&eacute;es &agrave; partir de "threads" diff&eacute;rents, FreeBASIC met en &oelig;uvre les mutex, les verrous d'exclusion mutuelle qui peut &ecirc;tre "poss&eacute;d&eacute;" par un seul "thread" lors d'une t&ocirc;che critique. Voir ##[[KeyPgMutexCreate MutexCreate]]##, ##[[KeyPgMutexLock MutexLock]]##, ##[[KeyPgMutexUnlock MutexUnlock]]##, ##[[KeyPgMutexDestroy MutexDestroy]]##

{{fbdoc item="ex"}}
	%%(freebasic)

Dim Shared printsync As Any Ptr
	Sub mythread(ByVal idp As Any Ptr)

Var id = CInt(idp)
	Dim As Double t, w
	Dim As Integer i, n

If( id = 1 ) Then
	w = 1

n = 10
	Else
	w = 0.3
	n = 5
	End If
	For i = 1 To n

MutexLock printsync