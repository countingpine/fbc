{{fbdoc item="title" value="THREADWAIT"}}----
Attend jusqu'à ce que le "thread" désigné ait terminé son exécution avant de retourner

{{fbdoc item="syntax"}}##
	[[KeyPgDeclare declare]] [[KeyPgSub sub]] **Threadwait** ( [[KeyPgByval byval]] //id// [[KeyPgAs as]] [[KeyPgAny any]] [[KeyPgPtr ptr]] )
##
{{fbdoc item="usage"}}##
	**Threadwait**( //id// )
##
{{fbdoc item="param"}}
	##//id//##
		Le handle ##[[KeyPgAny any]] [[KeyPgPtr ptr]]## d'un "thread" créé par ##[[KeyPgThreadCreate Threadcreate]]##

{{fbdoc item="desc"}}
	##Threadwait## ne retourne pas tant que le "thread" désigné par ##//id//## se termine. ##Threadwait## ne force pas le "thread" à terminer son exécution; si un "thread" a besoin d'un signal pour terminer son exécution, un mécanisme tel qu'une variable partagée doit être utilisé.

	Les "threads" sont lancés par la fonction ##[[KeyPgThreadCreate Threadcreate]]##.

	Pour éviter l'accès simultané aux ressources partagées à partir de "threads" différents, FreeBASIC met en œuvre les mutex, les verrous d'exclusion mutuelle qui peut être "possédé" par un seul "thread" lors d'une tôche critique. Voir ##[[KeyPgMutexCreate Mutexcreate]]##, ##[[KeyPgMutexLock Mutexlock]]##, ##[[KeyPgMutexUnlock Mutexunlock]]##, ##[[KeyPgMutexDestroy Mutexdestroy]]##

{{fbdoc item="ex"}}
{{fbdoc item="filename" value="examples/manual/threads/threadwait.bas"}}%%(freebasic)
dim shared printsync as any ptr

sub mythread(byval idp as any ptr)
  var id = cint(idp)
  dim as double t, w
  dim as integer i, n

  if( id = 1 ) then
	w = 1
	n = 10
  else
	w = 0.3
	n = 5
  end if

  for i = 1 to n

	mutexlock printsync
	print "Thread #"; id; ": on step #"; i
	mutexunlock printsync

	'' simulate some work
	t = timer
	while( timer - t ) < w
	wend

  next i

  mutexlock printsync
  print "Thread #"; id; " is done "
  mutexunlock printsync

end sub

dim as any ptr t1, t2

print "Starting threads ... "

'' create a mutex to sync printing
printsync = MutexCreate()

'' create 2 threads, each taking a different
'' amount of time to complete
t1 = threadcreate( @mythread, cast(any ptr, 1) )
t2 = threadcreate( @mythread, cast(any ptr, 2) )

'' wait for threads to complete
threadwait( t1 )
threadwait( t2 )

mutexdestroy printsync

print "All done."
%%

{{fbdoc item="lang"}}
	- Les "Thread" n'existent pas dans le dialecte //[[CompilerOptlang -lang qb]]//.

{{fbdoc item="target"}}
	- La version DOS de FreeBASIC ne permet pas les "threads", car l'OS ne les supporte pas.
	- Dans Linux les "threads" sont toujours démarrés dans l'ordre de leur création, ceci n'est pas possible sous Win32. Il s'agit de l'OS, pas une question FreeBASIC. 

{{fbdoc item="diff"}}
	- Nouveau pour ""FreeBASIC""

{{fbdoc item="see"}}
	- ##[[KeyPgThreadCreate Threadcreate]]##
	- ##[[KeyPgMutexCreate Mutexcreate]]##
	- ##[[KeyPgMutexLock Mutexlock]]##
	- ##[[KeyPgMutexUnlock Mutexunlock]]##
	- ##[[KeyPgMutexDestroy Mutexdestroy]]##

{{fbdoc item="back" value="CatPgThreading|Threading Support Functions"}}