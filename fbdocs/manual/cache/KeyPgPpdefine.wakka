{{fbdoc item="title" value="#DEFINE"}}----
Directive du pr&eacute;processeur pour d&eacute;finir une macro

{{fbdoc item="syntax"}}##
	#define //identifier//( [ //parameters// ] ) //macro_text//
	#define //identifier//( [ //parameters//, ] //variadic_parameter//[[KeyPgDots ...]] ) //macro_text//
	##
{{fbdoc item="desc"}}
Mot-cl&eacute; du pr&eacute;processeur qui d&eacute;finit un identifiant avec un sens personnalis&eacute;:
	- Des ##//define//## non-vides (avec ##//texte//##) sont remplac&eacute;s par leur ##//texte//## lorsque le source est analys&eacute;, permettant une sorte de "raccourci".  ##//text//## peut &ecirc;tre vide, ce qui est utile pour faire des ##//define//## con&ccedil;us pour le contr&ocirc;le des ##[[KeyPgPpifdef #ifdef]]## et ##[[KeyPgPpifndef #ifndef]]##.
	
	- Des ##//define//## avec des param&egrave;tres sont remplac&eacute;s par le ##//macro_text//##, qui contiendra tous les arguments pass&eacute;s remis &agrave; leur place.  **Note:** Le caract&egrave;re ouverture des parenth&egrave;ses ("##(##") doit suivre imm&eacute;diatement l' ##//identifier//##, il ne doit y avoir aucun espace-blanc entre eux, sinon les parenth&egrave;ses seront prises comme faisant partie du ##//text//##.
	- Les ##//define//## ne sont visibles que dans la port&eacute;e o&ugrave; ils sont d&eacute;finis.  S'il est d&eacute;fini au niveau du module, ##//define//## est visible tout au long du module.  Si l'##//identifier//## est d&eacute;fini dans une instruction &agrave; port&eacute;e compos&eacute;e (##[[KeyPgSub Sub]]##, ##[[KeyPgFornext For..Next]]##, ##[[KeyPgWhilewend While..Wend]]##, ##[[KeyPgDoloop Do..Loop]]##, ##[[KeyPgScope Scope..End Scope]]##, etc), l'##//identifier//## n'est visible que dans cette port&eacute;e.
	
	- Les espaces de noms n'ont aucun effet sur la visibilit&eacute; d'un ##//define//##.
	
	Les ##//Identifier//## peuvent &ecirc;tre examin&eacute;s pour voir si ils ont &eacute;t&eacute; d&eacute;finis avec ##[[KeyPgPpifdef #ifdef]]## et ##[[KeyPgPpifndef #ifndef]]##, ce qui peut &ecirc;tre utilis&eacute; pour cacher des parties du code pour le compilateur (compilation conditionnelle).
	
	Pour d&eacute;finir des identificateurs avec des valeurs constantes qui leur sont associ&eacute;es, ##[[KeyPgConst Const]]## peut &ecirc;tre utilis&eacute; comme une m&eacute;thode plus puissante.
	
	Utiliser ##[[KeyPgDots ...]]## (une ellipse) derri&egrave;re le dernier param&egrave;tre d'une macro permet de cr&eacute;er une macro variadique. Cela signifie qu'il est possible de passer n'importe quel nombre d'arguments &agrave; //variadic_parameter//, qui peuvent &ecirc;tre utilis&eacute;s dans //macro_text//, tout comme un param&egrave;tre macro normal. Le //variadic_parameter// sera &eacute;tendu &agrave; la liste compl&egrave;te des arguments pass&eacute;s, y compris les virgules et peut &eacute;galement &ecirc;tre compl&egrave;tement vide.

{{fbdoc item="ex"}}
{{fbdoc item="filename" value="examples/manual/prepro/define.bas"}}%%(freebasic)
'' Definition and check
#define DEBUGGING
#ifdef DEBUGGING
  ' ... statements
#endif

'' Simple definition/text replacement
#define FALSE 0
#define TRUE (not FALSE)

'' Function like definition
#define MyRGB(R,G,B) (((R)SHL 16)  OR ((G)SHL 8) OR (B)) 
print hex( MyRGB(&hff, &h00, &hff) )

'' Line continuation and statements in a definition
#define printval(bar) _
	print #bar; " ="; bar

'' #defines are visible only in the scope where they are defined
scope
	#define LOCALDEF 1
end scope

#ifndef LOCALDEF
#    Print LOCALDEF Is Not defined
#endif

'' namespaces have no effect on the visibility of a define
namespace foo
#    define NSDEF
end namespace

#ifdef NSDEF
#    Print NSDEF Is defined
#endif
%%

{{fbdoc item="diff"}}
	'' Using a variadic macro to wrap a variadic function

#include "crt.bi"
	#define eprintf(Format, args...) fprintf(stderr, Format, args)
	eprintf(!"Hello from printf: %i %s %i\n", 5, "test", 123)
	'' LISP-like accessors allowing to modify comma-separated lists
	#define car(a, b...) a
	#define cdr(a, b...) b
	%%
	{{fbdoc item="diff"}}

- Nouveau pour Freebasic