{{fbdoc item="title" value="Introduction to the Extended Type"}}----
//Written by [[WikiRick rdc]]//

=== Introduction===

FreeBASIC s'oriente vers la mise en oeuvre de la Programmation Orientée Objet (POO). Alors que les classes n'ont pas encore été ajoutées au langage, la définition de type a été élargie pour inclure certaines constructions orientées objet comme une première étape vers le soutien complet de la classe. Cet article présente quelques-uns des concepts de conception orientée objet et explique certaines des constructions de type étendu.

=== Programmation Orientée Objet (POO)===

La Programmation Orientée Objet, habituellement abrégée POO, est une méthodologie qui permet au programmeur de construire des unités de code appelés objets. Un objet est une chose; il s'agit d'une unité de code qui représente quelque chose qui doit être manipulé dans un programme. Vous pouvez penser à un objet comme un substantif: une personne, un lieu ou une chose. Un objet peut être un "sprite", une primitive de dessin ou quelque chose de plus élaboré comme un tank dans un jeu. Toute entité concrète qui a un ensemble de caractéristiques et d'actions peuvt être représentée comme un objet.

Un objet contient à la fois les données nécessaires pour l'objet et les méthodes (des sous-programmes et fonctions) qui agissent sur les données. Ce regroupement de données et méthodes en une seule entité est appelée encapsulation. L'encapsulation permet de créer des unités modulaires qui peuvent être réutilisées dans plusieurs programmes. Cette idée de la réutilisation du code a été la principale motivation de la création du paradigme de la POO.

Une autre conséquence bénéfique de l'encapsulation est de cacher l'information. Les données à l'intérieur de l'objet sont à l'abri du monde extérieur afin que des modifications indésirables des données ne puissent pas se produire. Au lieu d'accéder directement à une variable, l'objet a une interface publique que le programme externe doit utiliser pour accéder et modifier les données membres. En utilisant une interface, vous pouvez contrôler la façon dont l'objet se comporte et vous assurer que son fonctionnement est cohérent à travers de nombreux programmes. 

L'interface vous permet également de faire des changements internes du code, sans changer la façon dont l'objet est accessible. Tant que vous ne changez pas l'interface publiée, c'est à dire de modifier les méthodes publiques existantes, vous pouvez améliorer l'objet sans casser tout le code existant qui repose sur l'objet. Dans le cas où un de vos programmes a besoin d'une méthode améliorée, vous pouvez laisser l'ancienne méthode en place pour maintenir la compatibilité, et il suffit d'ajouter une nouvelle méthode avec la fonctionnalité améliorée. Les nouveaux programmes peuvent utiliser la nouvelle méthode, tandis que les anciens programmes peuvent toujours utiliser l'ancienne méthode.

Un autre avantage d'utiliser une interface publique est que d'autres programmeurs peuvent utiliser votre objet sans se soucier des détails internes de l'objet. Tant que l'interface publiée est stable et bien documentée, n'importe qui devrait être en mesure d'utiliser votre objet, même des débutants.

=== Le contrat de publication===

Comme déjà indiqué, la POO a été conçue pour permettre la réutilisation du code entre les programmeurs. De façon à ce que la réutilisation du code soit utile, l'interface publiée doit rester stable. Ceci dit, une fois qu'un objet a été libéré et est utilisé dans les programmes, l'interface publiée ne devrait pas changer afin que les programmes qui utilisent l'objet continuent à travailler correctement. Il y a un contrat implicite entre vous en tant qu'auteur de l'objet et l'utilisateur final de votre objet que vous maintiendrez l'interface publiée à travers les changements qui peuvent être nécessaires à l'objet. Ce contrat implicite entre l'auteur et l'utilisateur est la principale force du paradigme POO, et c'est la raison principale pour laquelle la POO est devenue une telle méthodologie de programmation puissante.

=== Les caractéristiques d'un objet===

Comme déjà mentionné, un objet contient à la fois des données et des méthodes. Les données décrivent les propriétés d'un objet, tandis que les méthodes de décrivent ce que l'objet peut faire. Un exemple simple et pas vraiment utile pour illustrer ce concept. 

Supposons que vous voulez créer un objet qui dessine un rectangle sur l'écran. Un rectangle peut avoir plusieurs propriétés qui seront contenues dans les données membres de l'objet. Un rectangle a une origine sur l'écran, normalement dans le coin supérieur gauche, qui peut être représenté par les données membres x et y. Un rectangle a une largeur et une hauteur, donc l'objet aura des données membres largeur et la hauteur. Un rectangle peut être vide ou rempli, donc un membre de donnée "drapeau de remplissage" peut être ajouté à l'objet. Bien sûr, si vous dessinez un rectangle, vous voudrez le dessiner dans une couleur particulière, donc l'objet aura besoin d'avoir un membre de données de couleur, et pour avoir un objet qui soit un peu plus flexible, vous pouvez ajouter un membre pour la couleur du contour et un membre de couleur différente pour le remplissage. Bien sûr, vous aurez besoin d'une méthode pour dessiner le rectangle réellement sur l'écran, ainsi vous pouvez ajouter une routine qui le dessinera dans la définition d'objet.

Donc, pour commencer, notre objet rectangle a les propriétés et méthodes suivantes:

~- Propriété: origine x et y
~- Propriété: largeur
~- Propriété: hauteur
~- Propriété: rempli
~- Propriété: la couleur du contour
~- Propriété: la couleur de remplissage
~- Méthode: tracé du rectangle

This list is called the object definition. In FreeBasic you define an object using the extended Type definition. The extended Type is similar to the standard Type, with some added language constructs that implements a subset of OOP features.

=== A Rectangle Type Definition===

Le code suivant est une définition partielle du rectangle:
%%(freebasic)
Type myRect
  Private:
	X_ As Integer
	Y_ As Integer
	Width_ As Integer
	Height_ As Integer
	Filled_ As Integer
	Otlncolor_ As Integer
	Fillcolor_ As Integer
	Public:
	Declare Sub DrawRect()
End Type
%%
Comme vous pouvez le voir, le type étendu ressemble beaucoup à un Type standard, sauf pour Private: et Public: les mots clés et la déclaration de la Sub. Le mot-clé Private: indique au compilateur que les membres de données qui suivent sont du type "privé", et qu'elles ne peuvent pas être accédées en dehors de ce type. L'état "privé" s'étend à tous les membres de l'objet jusqu'à ce qu'un qualificatif nouveau soit rencontré, qui dans ce cas est Public: qualificatif juste au-dessus de la déclaration de la Sub. Tous les membres de données sont cachées du monde extérieur et ne peuvent être changés de l'extérieur de la portée de ce type, un processus appelé "le masquage des information". Le trait de soulignement ajouté aux variables privées est la voie commune pour définir des variables privées.

Le masquage d'information est un moyen de maintenir l'intégrité de l'objet. Vous ne devriez jamais permettre à un processus externe d'accéder directement à un membre de données. Tous les accès aux données doivent se faire par l'utilisation de la propriété des membres de sorte que vous pouvez contrôler ce qui est transmis à votre objet. Un contrôle strict sur les données de votre Object va aider à prévenir de nombreuses erreurs qui peuvent survenir quand un programmeur utilise votre objet.
%%(freebasic)
Type myRect
  Private:
	X_ As Integer
	Y_ As Integer
	Width_ As Integer
	Height_ As Integer
	Filled_ As Integer
	Otlncolor_ As Integer
	Fillcolor_ As Integer
	Public:
	Declare Sub DrawRect()
	Declare Property X(Byval xx_ As Integer)
	Declare Property X() As Integer
	Declare Property Y(Byval yy_ As Integer)
	Declare Property Y() As Integer
	Declare Property Width(Byval w_ As Integer)
	Declare Property Width() As Integer
	Declare Property Height(Byval h_ As Integer)
	Declare Property Height() As Integer
	Declare Property Filled(Byval f_ As Integer)
	Declare Property Filled() As Integer
	Declare Property Otlncolor(Byval oc_ As Integer)
	Declare Property Otlncolor() As Integer
	Declare Property FillColor(Byval fc_ As Integer)
	Declare Property FillColor() As Integer
End Type
%%
Les instructions Declare suivant le qualificatif Public: forment l'interface publique de votre objet. Comme les variables de ce type sont définies avec mot-clé Private:, la seule façon d'accéder à des variables se fait par les membres Property pour maintenir l'intégrité de l'objet. Puisque vous de définissez le code de chaque "Property membre", vous avez le plein contrôle sur ce qui est mis dans votre objet. Un exemple courant de ceci est de mettre une gamme de code de vérification dans votre les "Property membres" de sorte que l'objet ne contienne pas de données invalides.

Dans cet exemple, les variables peuvent être à la fois lues et écrites. Le compilateur fait la distinction entre une "Property en lecture" et une "Property en écriture" d'après le type de la méthode. Une "Property formatée Sub" est une "Property en écriture" puisque vous passez une valeur qui sera enregistrée dans une variable privée. Une "Property formatée Function" est une "Property en lecture" puisqu'une variable privée sera retournée à l'appelant. Vous pouvez créer des "Property en lecture seule" en ajoutant seulement une "Property formatée Function" ou une "Property en écriture seule" en ajoutant seulement une "Property formatée Sub"

=== Création d'objets au comportement correct===

La définition semble complète à ce stade, mais il y a un problème. Que se passera-t-il si une partie ou l'ensemble des variables n'ont pas été initialisées? L'objet ne fonctionnera pas correctement et générera potentiellement une erreur d'exécution. Il serait préférable d'avoir un ensemble de valeurs par défaut pour les variables de l'objet, juste au cas où une ou plusieurs variables ne soient pas initialisées. Vous pouvez initialiser l'objet au moment de la création en utilisant un constructeur (Constructor)

Un constructeur est une fonction qui est appelée lorsque l'objet est créé en utilisant l'instruction Dim (ou New). Les constructeurs sont utiles pour initialiser un objet, soit avec des valeurs par défaut, soit par les valeurs que vous passez au constructeur. La définition du type mise à jour ressemble maintenant à ceci:
%%(freebasic)
Type myRect
  Private:
	X_ As Integer
	Y_ As Integer
	Width_ As Integer
	Height_ As Integer
	Filled_ As Integer
	Otlncolor_ As Integer
	Fillcolor_ As Integer
	Public:
	Declare Sub DrawRect()
	Declare Property X(Byval xx_ As Integer)
	Declare Property X() As Integer
	Declare Property Y(Byval yy_ As Integer)
	Declare Property Y() As Integer
	Declare Property Width(Byval w_ As Integer)
	Declare Property Width() As Integer
	Declare Property Height(Byval h_ As Integer)
	Declare Property Height() As Integer
	Declare Property Filled(Byval f_ As Integer)
	Declare Property Filled() As Integer
	Declare Property Otlncolor(Byval oc_ As Integer)
	Declare Property Otlncolor() As Integer
	Declare Property FillColor(Byval fc_ As Integer)
	Declare Property FillColor() As Integer:    Declare Constructor()
	Declare Constructor(xx_ As Integer, yy_ As Integer, w_ As Integer, _
	                    h_ As Integer, f_ As Integer, oc_ As Integer, _
	                    fc_ As Integer)
	                    
End Type
%%
Vous remarquerez dans la définition que nous avons deux constructeurs, un qui prend un ensemble de paramètres et l'autre non. C'est ce qu'on appelle la surcharge et peut être utilisé non seulement avec les constructeurs, mais aussi avec d'autres sous-programmes et fonctions. La surcharge est utile dans les situations où vous avez besoin de gérer différents types de paramètres avec un seul appel de méthode. Le compilateur détermine la méthode à appeler en fonction des paramètres transmis à la méthode. Vous pouvez surcharger autant de méthodes que vous le souhaitez, tant que le nombre et le type des paramètres de chaque méthode est unique.

Dans ce cas, si le constructeur n'est pas passé des valeurs aux paramètres, il va initialiser les variables à un ensemble de valeurs par défaut. Si le constructeur est appelé avec les paramètres, alors il utilisera les valeurs passées pour initialiser les variables de l' objet.

Il y a aussi une méthode Destructor (destructeur) qui est appelée lorsque l'objet est détruit. Vous pouvez utiliser le destructeur pour effectuer les tâches de nettoyage qui doivent être effectuées avant que l'objet ne éliminé de la mémoire. Si l'objet créé des références pointeur ou ouvre des fichiers, vous pourrez alors nettoyer ces références dans le destructeur. Puisque l'objet Rectangle ne crée pas de références à l'extérieur, un destructeur n'est pas nécessaire.


=== Remplir les méthodes objet===

La définition du type est un modèle pour le type d'objet et indique au compilateur comment mettre en place l'objet en mémoire. Toutefois, afin d'utiliser effectivement l'objet, vous devez créer les appels de méthode réelle, ce qui est indiqué dans la liste suivante.
%%(freebasic)
Type myRect
  Private:
	X_ As Integer
	Y_ As Integer
	Width_ As Integer
	Height_ As Integer
	Filled_ As Integer
	Otlncolor_ As Integer
	Fillcolor_ As Integer
	Public:
	Declare Sub DrawRect()
	Declare Property X(Byval xx_ As Integer)
	Declare Property X() As Integer
	Declare Property Y(Byval yy_ As Integer)
	Declare Property Y() As Integer
	Declare Property Width(Byval w_ As Integer)
	Declare Property Width() As Integer
	Declare Property Height(Byval h_ As Integer)
	Declare Property Height() As Integer
	Declare Property Filled(Byval f_ As Integer)
	Declare Property Filled() As Integer
	Declare Property Otlncolor(Byval oc_ As Integer)
	Declare Property Otlncolor() As Integer
	Declare Property FillColor(Byval fc_ As Integer)
	Declare Property FillColor() As Integer
	Declare Constructor()
	Declare Constructor(xx_ As Integer, yy_ As Integer, w_ As Integer, _
	                    h_ As Integer, f_ As Integer, oc_ As Integer, _
	                    fc_ As Integer)
End Type

Sub myRect.DrawRect()
	Line (this.x_, this.y_)-(this.x_ + Width - 1, this.y_ + this.height_ - 1), this.Otlncolor_, B
	If this.Filled_ <> 0 Then
	    Paint (this.x_ + 1, this.y_ + 1), this.Fillcolor_, this.Otlncolor_
	End If   
End Sub

Property myRect.x(Byval xx_ As Integer)
	this.X_ = xx_
End Property

Property myRect.x() As Integer
	Return this.X_
End Property

Property myRect.y(Byval yy_ As Integer)
	this.Y_ = yy_
End Property

Property myRect.y() As Integer
	 Return this.y_
End Property

Property myRect.Width(Byval w_ As Integer)
	this.Width_ = w_
End Property

Property myRect.Width() As Integer
	Return this.Width_
End Property

Property myRect.Height(Byval h_ As Integer)
	this.Height_ = h_
End Property

Property myRect.Height() As Integer
	Return this.Height_
End Property

Property myRect.Filled(Byval f_ As Integer)
	this.Filled_ = f_
End Property

Property myRect.Filled() As Integer
	Return this.Filled_
End Property

Property myRect.Otlncolor(Byval oc_ As Integer)
	this.Otlncolor_ = oc_
End Property

Property myRect.Otlncolor() As Integer
	Return this.Otlncolor_
End Property

Property myRect.FillColor(Byval fc_ As Integer)
	this.Fillcolor_ = fc_
End Property

Property myRect.FillColor() As Integer
	Return this.Fillcolor_
End Property

Constructor myRect
	this.X_ = 0
	this.Y_ = 0
	this.Width_ = 10
	this.Height_ = 10
	this.Filled_ = 0  
	this.Otlncolor_ = 15
	this.Fillcolor_ = 7
End Constructor

Constructor MyRect (xx_ As Integer, yy_ As Integer, w_ As Integer, _
	                    h_ As Integer, f_ As Integer, oc_ As Integer, _
	                    fc_ As Integer)

	this.X_ = xx_
	this.Y_ = yy_
	this.Width_ = w_
	this.Height_ = h_
	this.Filled_ = f_  
	this.Otlncolor_ = oc_
	this.Fillcolor_ = fc_
End Constructor
%%
Les méthodes et propriétés sont définies en utilisant la syntaxe "Sub/Function/Propriété nom de méthode.TypeName". Cela indique au compilateur comment faire correspondre aux méthodes à la définition du type approprié. Pour la même raison, les constructeurs sont définis avec le nom du type. L'identifiant //this// est un paramètre caché qui est passé aux méthodes qui se réfèrent au type défini. Vous utilisez l'identifiant //this// pour spécifier que vous voulez accéder à des constructions du type.

=== Utilisation de votre objet===

L'objet maintenant complet peut être utilisé dans le programme ci-dessous.
%%(freebasic)
Type myRect
  Private:
	X_ As Integer
	Y_ As Integer
	Width_ As Integer
	Height_ As Integer
	Filled_ As Integer
	Otlncolor_ As Integer
	Fillcolor_ As Integer
	Public:
	Declare Sub DrawRect()
	Declare Property X(Byval xx_ As Integer)
	Declare Property X() As Integer
	Declare Property Y(Byval yy_ As Integer)
	Declare Property Y() As Integer
	Declare Property Width(Byval w_ As Integer)
	Declare Property Width() As Integer
	Declare Property Height(Byval h_ As Integer)
	Declare Property Height() As Integer
	Declare Property Filled(Byval f_ As Integer)
	Declare Property Filled() As Integer
	Declare Property Otlncolor(Byval oc_ As Integer)
	Declare Property Otlncolor() As Integer
	Declare Property FillColor(Byval fc_ As Integer)
	Declare Property FillColor() As Integer
	Declare Constructor()
	Declare Constructor(xx_ As Integer, yy_ As Integer, w_ As Integer, _
	                    h_ As Integer, f_ As Integer, oc_ As Integer, _
	                    fc_ As Integer)
End Type

Sub myRect.DrawRect()
	Line (this.x_, this.y_)-(this.x_ + this.Width_ - 1, this.y_ + this.height_ - 1), this.Otlncolor_, B
	If this.Filled_ <> 0 Then
	    Paint (this.x_ + 1, this.y_ + 1), this.Fillcolor_, this.Otlncolor_
	End If   
End Sub

Property myRect.x(Byval xx_ As Integer)
	this.X_ = xx_
End Property

Property myRect.x() As Integer
	Return this.X_
End Property

Property myRect.y(Byval yy_ As Integer)
	this.Y_ = yy_
End Property

Property myRect.y() As Integer
	 Return this.y_
End Property

Property myRect.Width(Byval w_ As Integer)
	this.Width_ = w_
End Property

Property myRect.Width() As Integer
	Return this.Width_
End Property

Property myRect.Height(Byval h_ As Integer)
	this.Height_ = h_
End Property

Property myRect.Height() As Integer
	Return this.Height_
End Property

Property myRect.Filled(Byval f_ As Integer)
	this.Filled_ = f_
End Property

Property myRect.Filled() As Integer
	Return this.Filled_
End Property

Property myRect.Otlncolor(Byval oc_ As Integer)
	this.Otlncolor_ = oc_
End Property

Property myRect.Otlncolor() As Integer
	Return this.Otlncolor_
End Property

Property myRect.FillColor(Byval fc_ As Integer)
	this.Fillcolor_ = fc_
End Property

Property myRect.FillColor() As Integer
	Return this.Fillcolor_
End Property

Constructor myRect
	this.X_ = 0
	this.Y_ = 0
	this.Width_ = 10
	this.Height_ = 10
	this.Filled_ = 0  
	this.Otlncolor_ = 15
	this.Fillcolor_ = 7
End Constructor

Constructor MyRect (xx_ As Integer, yy_ As Integer, w_ As Integer, _
	                    h_ As Integer, f_ As Integer, oc_ As Integer, _
	                    fc_ As Integer)

	this.X_ = xx_
	this.Y_ = yy_
	this.Width_ = w_
	this.Height_ = h_
	this.Filled_ = f_  
	this.Otlncolor_ = oc_
	this.Fillcolor_ = fc_
End Constructor

'Create a graphic screen
Screen 18

'Create an object using the default constrcutor
Dim aRect As myRect
'Create an object by explicitly setting the constructor values
Dim bRect As myRect = myRect(200, 200, 200, 100, 1, 15, 9)

'Draw the rectangles on the screen
aRect.DrawRect
bRect.DrawRect

'Update aRect properties
aRect.X = 90
aRect.Y = 20
aRect.Filled = 1
aRect.FillColor = 15

'Draw new rect
aRect.DrawRect
Sleep
End
%%

Pour initialiser l'objet avec le constructeur par défaut, il vous suffit de //Dim//ensionner le type étendu comme vous le feriez avec un type standard. Si le constructeur ne prend qu'une seule valeur, alors vous pouvez utiliser la syntaxe //Dim var As TypeName = valeur//. Pour initialiser l'objet avec un ensemble de valeurs, vous //Dim//ensionner le type et ensuite vous utilisez la  syntaxe  //= typename (par1m parm1 ...)//. Vous pouvez voir que l'accès aux membres de l'objet est identique à l'accès au membre d'un type standard.

Merci à cha0s des forums FreeBASIC pour l'information relative aux "Property".
