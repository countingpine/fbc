{{fbdoc item="title" value="Introduction to the Extended Type"}}----
//Written by [[WikiRick rdc]]//

<div class="fb_header"> Introduction

FreeBASIC s'oriente vers la mise en oeuvre de la Programmation Orient&eacute;e Objet (POO). Alors que les classes n'ont pas encore &eacute;t&eacute; ajout&eacute;es au langage, la d&eacute;finition de type a &eacute;t&eacute; &eacute;largie pour inclure certaines constructions orient&eacute;es objet comme une premi&egrave;re &eacute;tape vers le soutien complet de la classe. Cet article pr&eacute;sente quelques-uns des concepts de conception orient&eacute;e objet et explique certaines des constructions de type &eacute;tendu.

<div class="fb_header"> Programmation Orient&eacute;e Objet (POO)

La Programmation Orient&eacute;e Objet, habituellement abr&eacute;g&eacute;e POO, est une m&eacute;thodologie qui permet au programmeur de construire des unit&eacute;s de code appel&eacute;s objets. Un objet est une chose; il s'agit d'une unit&eacute; de code qui repr&eacute;sente quelque chose qui doit &ecirc;tre manipul&eacute; dans un programme. Vous pouvez penser &agrave; un objet comme un substantif: une personne, un lieu ou une chose. Un objet peut &ecirc;tre un "sprite", une primitive de dessin ou quelque chose de plus &eacute;labor&eacute; comme un tank dans un jeu. Toute entit&eacute; concr&egrave;te qui a un ensemble de caract&eacute;ristiques et d'actions peuvt &ecirc;tre repr&eacute;sent&eacute;e comme un objet.

Un objet contient &agrave; la fois les donn&eacute;es n&eacute;cessaires pour l'objet et les m&eacute;thodes (des sous-programmes et fonctions) qui agissent sur les donn&eacute;es. Ce regroupement de donn&eacute;es et m&eacute;thodes en une seule entit&eacute; est appel&eacute;e encapsulation. L'encapsulation permet de cr&eacute;er des unit&eacute;s modulaires qui peuvent &ecirc;tre r&eacute;utilis&eacute;es dans plusieurs programmes. Cette id&eacute;e de la r&eacute;utilisation du code a &eacute;t&eacute; la principale motivation de la cr&eacute;ation du paradigme de la POO.

Une autre cons&eacute;quence b&eacute;n&eacute;fique de l'encapsulation est de cacher l'information. Les donn&eacute;es &agrave; l'int&eacute;rieur de l'objet sont &agrave; l'abri du monde ext&eacute;rieur afin que des modifications ind&eacute;sirables des donn&eacute;es ne puissent pas se produire. Au lieu d'acc&eacute;der directement &agrave; une variable, l'objet a une interface publique que le programme externe doit utiliser pour acc&eacute;der et modifier les donn&eacute;es membres. En utilisant une interface, vous pouvez contr&ocirc;ler la fa&ccedil;on dont l'objet se comporte et vous assurer que son fonctionnement est coh&eacute;rent &agrave; travers de nombreux programmes. 

L'interface vous permet &eacute;galement de faire des changements internes du code, sans changer la fa&ccedil;on dont l'objet est accessible. Tant que vous ne changez pas l'interface publi&eacute;e, c'est &agrave; dire de modifier les m&eacute;thodes publiques existantes, vous pouvez am&eacute;liorer l'objet sans casser tout le code existant qui repose sur l'objet. Dans le cas o&ugrave; un de vos programmes a besoin d'une m&eacute;thode am&eacute;lior&eacute;e, vous pouvez laisser l'ancienne m&eacute;thode en place pour maintenir la compatibilit&eacute;, et il suffit d'ajouter une nouvelle m&eacute;thode avec la fonctionnalit&eacute; am&eacute;lior&eacute;e. Les nouveaux programmes peuvent utiliser la nouvelle m&eacute;thode, tandis que les anciens programmes peuvent toujours utiliser l'ancienne m&eacute;thode.

Un autre avantage d'utiliser une interface publique est que d'autres programmeurs peuvent utiliser votre objet sans se soucier des d&eacute;tails internes de l'objet. Tant que l'interface publi&eacute;e est stable et bien document&eacute;e, n'importe qui devrait &ecirc;tre en mesure d'utiliser votre objet, m&ecirc;me des d&eacute;butants.

<div class="fb_header"> Le contrat de publication

Comme d&eacute;j&agrave; indiqu&eacute;, la POO a &eacute;t&eacute; con&ccedil;ue pour permettre la r&eacute;utilisation du code entre les programmeurs. De fa&ccedil;on &agrave; ce que la r&eacute;utilisation du code soit utile, l'interface publi&eacute;e doit rester stable. Ceci dit, une fois qu'un objet a &eacute;t&eacute; lib&eacute;r&eacute; et est utilis&eacute; dans les programmes, l'interface publi&eacute;e ne devrait pas changer afin que les programmes qui utilisent l'objet continuent &agrave; travailler correctement. Il y a un contrat implicite entre vous en tant qu'auteur de l'objet et l'utilisateur final de votre objet que vous maintiendrez l'interface publi&eacute;e &agrave; travers les changements qui peuvent &ecirc;tre n&eacute;cessaires &agrave; l'objet. Ce contrat implicite entre l'auteur et l'utilisateur est la principale force du paradigme POO, et c'est la raison principale pour laquelle la POO est devenue une telle m&eacute;thodologie de programmation puissante.

<div class="fb_header"> Les caract&eacute;ristiques d'un objet

Comme d&eacute;j&agrave; mentionn&eacute;, un objet contient &agrave; la fois des donn&eacute;es et des m&eacute;thodes. Les donn&eacute;es d&eacute;crivent les propri&eacute;t&eacute;s d'un objet, tandis que les m&eacute;thodes de d&eacute;crivent ce que l'objet peut faire. Un exemple simple et pas vraiment utile pour illustrer ce concept. 

Supposons que vous voulez cr&eacute;er un objet qui dessine un rectangle sur l'&eacute;cran. Un rectangle peut avoir plusieurs propri&eacute;t&eacute;s qui seront contenues dans les donn&eacute;es membres de l'objet. Un rectangle a une origine sur l'&eacute;cran, normalement dans le coin sup&eacute;rieur gauche, qui peut &ecirc;tre repr&eacute;sent&eacute; par les donn&eacute;es membres x et y. Un rectangle a une largeur et une hauteur, donc l'objet aura des donn&eacute;es membres largeur et la hauteur. Un rectangle peut &ecirc;tre vide ou rempli, donc un membre de donn&eacute;e "drapeau de remplissage" peut &ecirc;tre ajout&eacute; &agrave; l'objet. Bien s&ucirc;r, si vous dessinez un rectangle, vous voudrez le dessiner dans une couleur particuli&egrave;re, donc l'objet aura besoin d'avoir un membre de donn&eacute;es de couleur, et pour avoir un objet qui soit un peu plus flexible, vous pouvez ajouter un membre pour la couleur du contour et un membre de couleur diff&eacute;rente pour le remplissage. Bien s&ucirc;r, vous aurez besoin d'une m&eacute;thode pour dessiner le rectangle r&eacute;ellement sur l'&eacute;cran, ainsi vous pouvez ajouter une routine qui le dessinera dans la d&eacute;finition d'objet.

Donc, pour commencer, notre objet rectangle a les propri&eacute;t&eacute;s et m&eacute;thodes suivantes:

Propri&eacute;t&eacute;: origine x et y
Propri&eacute;t&eacute;: largeur
Propri&eacute;t&eacute;: hauteur
Propri&eacute;t&eacute;: rempli
Propri&eacute;t&eacute;: la couleur du contour
Propri&eacute;t&eacute;: la couleur de remplissage
M&eacute;thode: trac&eacute; du rectangle

This list is called the object definition. In FreeBasic you define an object using the extended Type definition. The extended Type is similar to the standard Type, with some added language constructs that implements a subset of OOP features.

<div class="fb_header"> A Rectangle Type Definition

Le code suivant est une d&eacute;finition partielle du rectangle:
%%(freebasic)
Type myRect
  Private:
	X_ As Integer
	Y_ As Integer
	Width_ As Integer
	Height_ As Integer
	Filled_ As Integer
	Otlncolor_ As Integer
	Fillcolor_ As Integer
	Public:
	Declare Sub DrawRect()
End Type
%%
Comme vous pouvez le voir, le type &eacute;tendu ressemble beaucoup &agrave; un Type standard, sauf pour Private: et Public: les mots cl&eacute;s et la d&eacute;claration de la Sub. Le mot-cl&eacute; Private: indique au compilateur que les membres de donn&eacute;es qui suivent sont du type "priv&eacute;", et qu'elles ne peuvent pas &ecirc;tre acc&eacute;d&eacute;es en dehors de ce type. L'&eacute;tat "priv&eacute;" s'&eacute;tend &agrave; tous les membres de l'objet jusqu'&agrave; ce qu'un qualificatif nouveau soit rencontr&eacute;, qui dans ce cas est Public: qualificatif juste au-dessus de la d&eacute;claration de la Sub. Tous les membres de donn&eacute;es sont cach&eacute;es du monde ext&eacute;rieur et ne peuvent &ecirc;tre chang&eacute;s de l'ext&eacute;rieur de la port&eacute;e de ce type, un processus appel&eacute; "le masquage des information". Le trait de soulignement ajout&eacute; aux variables priv&eacute;es est la voie commune pour d&eacute;finir des variables priv&eacute;es.

Le masquage d'information est un moyen de maintenir l'int&eacute;grit&eacute; de l'objet. Vous ne devriez jamais permettre &agrave; un processus externe d'acc&eacute;der directement &agrave; un membre de donn&eacute;es. Tous les acc&egrave;s aux donn&eacute;es doivent se faire par l'utilisation de la propri&eacute;t&eacute; des membres de sorte que vous pouvez contr&ocirc;ler ce qui est transmis &agrave; votre objet. Un contr&ocirc;le strict sur les donn&eacute;es de votre Object va aider &agrave; pr&eacute;venir de nombreuses erreurs qui peuvent survenir quand un programmeur utilise votre objet.
%%(freebasic)
Type myRect
  Private:
	X_ As Integer
	Y_ As Integer
	Width_ As Integer
	Height_ As Integer
	Filled_ As Integer
	Otlncolor_ As Integer
	Fillcolor_ As Integer
	Public:
	Declare Sub DrawRect()
	Declare Property X(Byval xx_ As Integer)
	Declare Property X() As Integer
	Declare Property Y(Byval yy_ As Integer)
	Declare Property Y() As Integer
	Declare Property Width(Byval w_ As Integer)
	Declare Property Width() As Integer
	Declare Property Height(Byval h_ As Integer)
	Declare Property Height() As Integer
	Declare Property Filled(Byval f_ As Integer)
	Declare Property Filled() As Integer
	Declare Property Otlncolor(Byval oc_ As Integer)
	Declare Property Otlncolor() As Integer
	Declare Property FillColor(Byval fc_ As Integer)
	Declare Property FillColor() As Integer
End Type
%%
Les instructions Declare suivant le qualificatif Public: forment l'interface publique de votre objet. Comme les variables de ce type sont d&eacute;finies avec mot-cl&eacute; Private:, la seule fa&ccedil;on d'acc&eacute;der &agrave; des variables se fait par les membres Property pour maintenir l'int&eacute;grit&eacute; de l'objet. Puisque vous de d&eacute;finissez le code de chaque "Property membre", vous avez le plein contr&ocirc;le sur ce qui est mis dans votre objet. Un exemple courant de ceci est de mettre une gamme de code de v&eacute;rification dans votre les "Property membres" de sorte que l'objet ne contienne pas de donn&eacute;es invalides.

Dans cet exemple, les variables peuvent &ecirc;tre &agrave; la fois lues et &eacute;crites. Le compilateur fait la distinction entre une "Property en lecture" et une "Property en &eacute;criture" d'apr&egrave;s le type de la m&eacute;thode. Une "Property format&eacute;e Sub" est une "Property en &eacute;criture" puisque vous passez une valeur qui sera enregistr&eacute;e dans une variable priv&eacute;e. Une "Property format&eacute;e Function" est une "Property en lecture" puisqu'une variable priv&eacute;e sera retourn&eacute;e &agrave; l'appelant. Vous pouvez cr&eacute;er des "Property en lecture seule" en ajoutant seulement une "Property format&eacute;e Function" ou une "Property en &eacute;criture seule" en ajoutant seulement une "Property format&eacute;e Sub" 

<div class="fb_header"> Cr&eacute;ation d'objets au comportement correct

La d&eacute;finition semble compl&egrave;te &agrave; ce stade, mais il y a un probl&egrave;me. Que se passera-t-il si une partie ou l'ensemble des variables n'ont pas &eacute;t&eacute; initialis&eacute;es? L'objet ne fonctionnera pas correctement et g&eacute;n&eacute;rera potentiellement une erreur d'ex&eacute;cution. Il serait pr&eacute;f&eacute;rable d'avoir un ensemble de valeurs par d&eacute;faut pour les variables de l'objet, juste au cas o&ugrave; une ou plusieurs variables ne soient pas initialis&eacute;es. Vous pouvez initialiser l'objet au moment de la cr&eacute;ation en utilisant un constructeur (Constructor)

Un constructeur est une fonction qui est appel&eacute;e lorsque l'objet est cr&eacute;&eacute; en utilisant l'instruction Dim (ou New). Les constructeurs sont utiles pour initialiser un objet, soit avec des valeurs par d&eacute;faut, soit par les valeurs que vous passez au constructeur. La d&eacute;finition du type mise &agrave; jour ressemble maintenant &agrave; ceci:
%%(freebasic)
Type myRect
  Private:
	X_ As Integer
	Y_ As Integer
	Width_ As Integer
	Height_ As Integer
	Filled_ As Integer
	Otlncolor_ As Integer
	Fillcolor_ As Integer
	Public:
	Declare Sub DrawRect()
	Declare Property X(Byval xx_ As Integer)
	Declare Property X() As Integer
	Declare Property Y(Byval yy_ As Integer)
	Declare Property Y() As Integer
	Declare Property Width(Byval w_ As Integer)
	Declare Property Width() As Integer
	Declare Property Height(Byval h_ As Integer)
	Declare Property Height() As Integer
	Declare Property Filled(Byval f_ As Integer)
	Declare Property Filled() As Integer
	Declare Property Otlncolor(Byval oc_ As Integer)
	Declare Property Otlncolor() As Integer
	Declare Property FillColor(Byval fc_ As Integer)
	Declare Property FillColor() As Integer
	Declare Constructor()
	                    Declare Constructor(xx_ As Integer, yy_ As Integer, w_ As Integer, _
	                    h_ As Integer, f_ As Integer, oc_ As Integer, _
	                    
fc_ As Integer)
End Type
%%

Vous remarquerez dans la d&eacute;finition que nous avons deux constructeurs, un qui prend un ensemble de param&egrave;tres et l'autre non. C'est ce qu'on appelle la surcharge et peut &ecirc;tre utilis&eacute; non seulement avec les constructeurs, mais aussi avec d'autres sous-programmes et fonctions. La surcharge est utile dans les situations o&ugrave; vous avez besoin de g&eacute;rer diff&eacute;rents types de param&egrave;tres avec un seul appel de m&eacute;thode. Le compilateur d&eacute;termine la m&eacute;thode &agrave; appeler en fonction des param&egrave;tres transmis &agrave; la m&eacute;thode. Vous pouvez surcharger autant de m&eacute;thodes que vous le souhaitez, tant que le nombre et le type des param&egrave;tres de chaque m&eacute;thode est unique.

Dans ce cas, si le constructeur n'est pas pass&eacute; des valeurs aux param&egrave;tres, il va initialiser les variables &agrave; un ensemble de valeurs par d&eacute;faut. Si le constructeur est appel&eacute; avec les param&egrave;tres, alors il utilisera les valeurs pass&eacute;es pour initialiser les variables de l' objet.


Il y a aussi une m&eacute;thode Destructor (destructeur) qui est appel&eacute;e lorsque l'objet est d&eacute;truit. Vous pouvez utiliser le destructeur pour effectuer les t&acirc;ches de nettoyage qui doivent &ecirc;tre effectu&eacute;es avant que l'objet ne &eacute;limin&eacute; de la m&eacute;moire. Si l'objet cr&eacute;&eacute; des r&eacute;f&eacute;rences pointeur ou ouvre des fichiers, vous pourrez alors nettoyer ces r&eacute;f&eacute;rences dans le destructeur. Puisque l'objet Rectangle ne cr&eacute;e pas de r&eacute;f&eacute;rences &agrave; l'ext&eacute;rieur, un destructeur n'est pas n&eacute;cessaire.

<div class="fb_header"> Remplir les m&eacute;thodes objet
La d&eacute;finition du type est un mod&egrave;le pour le type d'objet et indique au compilateur comment mettre en place l'objet en m&eacute;moire. Toutefois, afin d'utiliser effectivement l'objet, vous devez cr&eacute;er les appels de m&eacute;thode r&eacute;elle, ce qui est indiqu&eacute; dans la liste suivante.
Type myRect
  Type myRect
	Private:
	X_ As Integer
	Y_ As Integer
	Width_ As Integer
	Height_ As Integer
	Filled_ As Integer
	Otlncolor_ As Integer
	Fillcolor_ As Integer
	Public:
	Declare Sub DrawRect()
	Declare Property X(ByVal xx_ As Integer)
	Declare Property X() As Integer
	Declare Property Y(ByVal yy_ As Integer)
	Declare Property Y() As Integer
	Declare Property Width(ByVal w_ As Integer)
	Declare Property Width() As Integer
	Declare Property Height(ByVal h_ As Integer)
	Declare Property Height() As Integer
	Declare Property Filled(ByVal f_ As Integer)
	Declare Property Filled() As Integer
	Declare Property Otlncolor(ByVal oc_ As Integer)
	Declare Property Otlncolor() As Integer
	Declare Property FillColor(ByVal fc_ As Integer)
	Declare Property FillColor() As Integer
	Declare Constructor()
	                    Declare Constructor(xx_ As Integer, yy_ As Integer, w_ As Integer, _
	                    h_ As Integer, f_ As Integer, oc_ As Integer, _
fc_ As Integer)

End Type
	Sub myRect.DrawRect()
	Line (this.x_, this.y_)-(this.x_ + Width - 1, this.y_ + this.height_ - 1), this.Otlncolor_, B
	    If this.Filled_ <> 0 Then
	Paint (this.x_ + 1, this.y_ + 1), this.Fillcolor_, this.Otlncolor_
End If   

End Sub
	Property myRect.x(ByVal xx_ As Integer)
this.X_ = xx_

End Property
	Property myRect.x() As Integer
Return this.X_

End Property
	Property myRect.y(ByVal yy_ As Integer)
this.Y_ = yy_

End Property
	 Property myRect.y() As Integer
Return this.y_

End Property
	Property myRect.Width(ByVal w_ As Integer)
this.Width_ = w_

End Property
	Property myRect.Width() As Integer
Return this.Width_

End Property
	Property myRect.Height(ByVal h_ As Integer)
this.Height_ = h_

End Property
	Property myRect.Height() As Integer
Return this.Height_

End Property
	Property myRect.Filled(ByVal f_ As Integer)
this.Filled_ = f_

End Property
	Property myRect.Filled() As Integer
Return this.Filled_

End Property
	Property myRect.Otlncolor(ByVal oc_ As Integer)
this.Otlncolor_ = oc_

End Property
	Property myRect.Otlncolor() As Integer
Return this.Otlncolor_

End Property
	Property myRect.FillColor(ByVal fc_ As Integer)
this.Fillcolor_ = fc_

End Property
	Property myRect.FillColor() As Integer
Return this.Fillcolor_

End Property
	Constructor myRect
	this.X_ = 0
	this.Y_ = 0
	this.Width_ = 10
	this.Height_ = 10
	this.Filled_ = 0  
	this.Otlncolor_ = 15
this.Fillcolor_ = 7

End Constructor
	                    Constructor MyRect (xx_ As Integer, yy_ As Integer, w_ As Integer, _
	                    h_ As Integer, f_ As Integer, oc_ As Integer, _

	fc_ As Integer)
	this.X_ = xx_
	this.Y_ = yy_
	this.Width_ = w_
	this.Height_ = h_
	this.Filled_ = f_  
	this.Otlncolor_ = oc_
this.Fillcolor_ = fc_
End Constructor
%%

Les m&eacute;thodes et propri&eacute;t&eacute;s sont d&eacute;finies en utilisant la syntaxe "Sub/Function/Propri&eacute;t&eacute; nom de m&eacute;thode.TypeName". Cela indique au compilateur comment faire correspondre aux m&eacute;thodes &agrave; la d&eacute;finition du type appropri&eacute;. Pour la m&ecirc;me raison, les constructeurs sont d&eacute;finis avec le nom du type. L'identifiant //this// est un param&egrave;tre cach&eacute; qui est pass&eacute; aux m&eacute;thodes qui se r&eacute;f&egrave;rent au type d&eacute;fini. Vous utilisez l'identifiant //this// pour sp&eacute;cifier que vous voulez acc&eacute;der &agrave; des constructions du type.

<div class="fb_header"> Utilisation de votre objet
L'objet maintenant complet peut &ecirc;tre utilis&eacute; dans le programme ci-dessous.
Type myRect
  Type myRect
	Private:
	X_ As Integer
	Y_ As Integer
	Width_ As Integer
	Height_ As Integer
	Filled_ As Integer
	Otlncolor_ As Integer
	Fillcolor_ As Integer
	Public:
	Declare Sub DrawRect()
	Declare Property X(ByVal xx_ As Integer)
	Declare Property X() As Integer
	Declare Property Y(ByVal yy_ As Integer)
	Declare Property Y() As Integer
	Declare Property Width(ByVal w_ As Integer)
	Declare Property Width() As Integer
	Declare Property Height(ByVal h_ As Integer)
	Declare Property Height() As Integer
	Declare Property Filled(ByVal f_ As Integer)
	Declare Property Filled() As Integer
	Declare Property Otlncolor(ByVal oc_ As Integer)
	Declare Property Otlncolor() As Integer
	Declare Property FillColor(ByVal fc_ As Integer)
	Declare Property FillColor() As Integer
	Declare Constructor()
	                    Declare Constructor(xx_ As Integer, yy_ As Integer, w_ As Integer, _
	                    h_ As Integer, f_ As Integer, oc_ As Integer, _
fc_ As Integer)

End Type
	Sub myRect.DrawRect()
	Line (this.x_, this.y_)-(this.x_ + this.Width_ - 1, this.y_ + this.height_ - 1), this.Otlncolor_, B
	    If this.Filled_ <> 0 Then
	Paint (this.x_ + 1, this.y_ + 1), this.Fillcolor_, this.Otlncolor_
End If   

End Sub
	Property myRect.x(ByVal xx_ As Integer)
this.X_ = xx_

End Property
	Property myRect.x() As Integer
Return this.X_

End Property
	Property myRect.y(ByVal yy_ As Integer)
this.Y_ = yy_

End Property
	 Property myRect.y() As Integer
Return this.y_

End Property
	Property myRect.Width(ByVal w_ As Integer)
this.Width_ = w_

End Property
	Property myRect.Width() As Integer
Return this.Width_

End Property
	Property myRect.Height(ByVal h_ As Integer)
this.Height_ = h_

End Property
	Property myRect.Height() As Integer
Return this.Height_

End Property
	Property myRect.Filled(ByVal f_ As Integer)
this.Filled_ = f_

End Property
	Property myRect.Filled() As Integer
Return this.Filled_

End Property
	Property myRect.Otlncolor(ByVal oc_ As Integer)
this.Otlncolor_ = oc_

End Property
	Property myRect.Otlncolor() As Integer
Return this.Otlncolor_

End Property
	Property myRect.FillColor(ByVal fc_ As Integer)
this.Fillcolor_ = fc_

End Property
	Property myRect.FillColor() As Integer
Return this.Fillcolor_

End Property
	Constructor myRect
	this.X_ = 0
	this.Y_ = 0
	this.Width_ = 10
	this.Height_ = 10
	this.Filled_ = 0  
	this.Otlncolor_ = 15
this.Fillcolor_ = 7

End Constructor
	                    Constructor MyRect (xx_ As Integer, yy_ As Integer, w_ As Integer, _
	                    h_ As Integer, f_ As Integer, oc_ As Integer, _

	fc_ As Integer)
	this.X_ = xx_
	this.Y_ = yy_
	this.Width_ = w_
	this.Height_ = h_
	this.Filled_ = f_  
	this.Otlncolor_ = oc_
this.Fillcolor_ = fc_

End Constructor
'Create a graphic screen

Screen 18
'Create an object using the default constrcutor
Dim aRect As myRect
'Create an object by explicitly setting the constructor values

Dim bRect As myRect = myRect(200, 200, 200, 100, 1, 15, 9)
'Draw the rectangles on the screen
aRect.DrawRect

bRect.DrawRect
'Update aRect properties
aRect.X = 90
aRect.Y = 20
aRect.Filled = 1

aRect.FillColor = 15
'Draw new rect
aRect.DrawRect
Sleep
End

%%

Pour initialiser l'objet avec le constructeur par d&eacute;faut, il vous suffit de //Dim//ensionner le type &eacute;tendu comme vous le feriez avec un type standard. Si le constructeur ne prend qu'une seule valeur, alors vous pouvez utiliser la syntaxe //Dim var As TypeName = valeur//. Pour initialiser l'objet avec un ensemble de valeurs, vous //Dim//ensionner le type et ensuite vous utilisez la  syntaxe  //= typename (par1m parm1 ...)//. Vous pouvez voir que l'acc&egrave;s aux membres de l'objet est identique &agrave; l'acc&egrave;s au membre d'un type standard.
