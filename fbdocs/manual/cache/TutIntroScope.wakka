{{fbdoc item="title" value="Introduction to Variable Scope"}}----
//Ecrit par [[WikiRick rdc]]//

<div class="fb_header"> Variable Scope 

##**Scope = port&eacute;e**## fait r&eacute;f&eacute;rence &agrave; la visibilit&eacute; d'une variable, o&ugrave; vous pouvez acc&eacute;der &agrave; une variable dans un programme. Avant de pouvoir comprendre les diff&eacute;rents niveaux de port&eacute;e, vous devez comprendre la structure d'un programme en FreeBasic.

** Structure d'un programme **

Un programme complet est compos&eacute; d'un ou plusieurs fichiers **.bas**, appel&eacute;s modules. Chaque module peut contenir, &agrave; la fois, du code de niveau module et du code contenu dans les sous-routines et fonctions. Du code de niveau module est du code qui //**n'est pas**// contenu dans une sous-routine ou une fonction. L'extrait suivant illustre les diff&eacute;rentes parties d'un module.

%%(freebasic)
Dim aInt As Integer 'Variable d&eacute;clar&eacute;e au niveau module

Sub DoSomething
	Dim aInt As Integer 'Variable d&eacute;clar&eacute;e au niveau sous-routine
	
	... 'Ce code est local &agrave; Sub
End Sub

Function DoSomethingElse() as Integer
	Dim aInt As Integer 'Variable d&eacute;clar&eacute;e au niveau fonction
	
	... 'Ce code est local &agrave; Function
End Function

'Code niveau module
aInt = 5
DoSomething
aInt = DoSomethingElse()
%%

** Variables locales **

Si vous d&eacute;finissez une variable au niveau du module (et n'utilisez pas ##**Shared**##), la variable est dite avoir une port&eacute;e au niveau du module local. Elle est visible par le code au niveau du module, mais pas des sous-routines ou fonctions au sein du module. Dans l'exemple ci-dessus la variable du module ##**aInt**## est visible uniquement pour le code de niveau module. 

Les variables d&eacute;finies dans une sous-routine ou une fonction sont locales &agrave; la sous-routine ou fonction et ne sont pas visibles du code de niveau module ou de toute autre sous-programme ou fonction.

** Variables d&eacute;finies au sein de structures de contr&ocirc;le **

Les variables qui sont d&eacute;finies dans des constructions ##**If**##, ##**For-Next**##, ##**While-Wend**## et ##**Do-Loop**## sont locales au code de la structure du bloc de contr&ocirc;le. Autrement dit, ils ne sont pas visibles &agrave; l'ext&eacute;rieur des limites du d&eacute;but et de fin du bloc de contr&ocirc;le, tout comme une variable d&eacute;clar&eacute;e dans une sous-routine ou une fonction. 

** Les variables partag&eacute;es (Shared) **

Dans l'exemple, si vous voulez que ##**aInt**## soit visible au sein de la sous-routine ou de la fonction, vous devez d&eacute;clarer la variable comme &eacute;tant ##**Shared**## et ensuite ne pas d&eacute;clarer une variable avec le m&ecirc;me nom dans des sous-routine, fonction ou bloc de contr&ocirc;le. Les variables ##**Shared**## sont visibles par le code de niveau module, celui de niveau sous-routines ou fonctions et au sein des structures de contr&ocirc;le.

** Les conflits de port&eacute;e**

Dans l'extrait de code ci-dessus, si ##**aInt**## est d&eacute;clar&eacute;e ##**Shared**## et que chaque sous-routine et fonction d&eacute;clare ##**aInt**##, il y aurait un conflit une port&eacute;e, car il y aurait m&ecirc;me un nom de variable utilis&eacute; pour diff&eacute;rents niveaux de port&eacute;e.

Le compilateur r&eacute;sout cela en prenant la port&eacute;e courante en compte et planifie la variable avec cette port&eacute;e. Comme les sous-routines et fonctions ont un niveau de port&eacute;e inf&eacute;rieur &agrave; celui d'un module, ##**aInt**## fait r&eacute;f&eacute;rence soit &agrave; la variable d&eacute;clar&eacute;e dans la sous-routine ou la fonction, et non pas &agrave; celle qui a &eacute;t&eacute; d&eacute;clar&eacute;e au niveau d'un module, m&ecirc;me si elle a &eacute;t&eacute; d&eacute;clar&eacute;e comme une variable partag&eacute;e.

** Plusieurs modules **

La port&eacute;e est limit&eacute;e &agrave; un seul module, c'est &agrave; dire un unique fichier ##**.bas**##. Cependant, il est parfois n&eacute;cessaire d'&eacute;tendre la port&eacute;e d'un module &agrave; un autre. Vous devez utiliser la d&eacute;claration ##**Common**## lorsque vous d&eacute;clarez une variable qui doit &ecirc;tre partag&eacute;e entre plusieurs modules.

Chaque d'un module doit avoir la m&ecirc;me d&eacute;claration ##**Common**## pour que le compilateur de fasse correspondre les variables communes. Si vous d&eacute;clarez une variable ##**Common aInt as Integer**## dans module1 alors le module2 doit aussi avoir ##**Common aInt as Integer**##. Sans cette d&eacute;claration commune ##**aInt**## ne serait pas visible dans le module2.

Vous pouvez ajouter l'attribut ##**Shared**## &agrave; ##**Common**##, c'est &agrave; dire ##**Common Shared**## non seulement pour &eacute;tendre la port&eacute;e &agrave; plusieurs modules, mais pour &eacute;tendre la port&eacute;e au sein d'un module. ##**Common Shared**## fonctionne comme ##**Shared**## dans un seul module. Comme avec ##**Common**##, vous avez besoin d'apparier les d&eacute;clarations dans chaque module qui doit avoir acc&egrave;s &agrave; la variable.

<div class="fb_header"> Scope...End Scope 

Vous pouvez cr&eacute;er un bloc de port&eacute;e temporaire en utilisant les mots-cl&eacute;s ##**Scope**## et ##**End Scope**##. Le bloc de port&eacute;e est tr&egrave;s utile lors de la cr&eacute;ation de macros multi-ligne o&ugrave; vous pouvez avoir besoin de cr&eacute;er des variables de travail temporaires mais en &eacute;vitant de cr&eacute;er des conflits de nom dans le programme. L'extrait suivant montre comment cr&eacute;er un bloc de port&eacute;e.

%%(freebasic)
Scope
	Dim tmp as Integer
	... 'Du code
End Scope
%%

La port&eacute;e d'une variable cr&eacute;&eacute;e dans un bloc de port&eacute;e est limit&eacute;e au bloc lui-m&ecirc;me. Cependant, le bloc de port&eacute;e h&eacute;rite de la visibilit&eacute; de la port&eacute;e environnante, afin que les variables cr&eacute;&eacute;es avec la m&ecirc;me port&eacute;e que le bloc de port&eacute;e soient visibles dans le bloc.

Par exemple, si vous avez ##**aInt**## qui est de port&eacute;e niveau module et le bloc de port&eacute;e qui est de port&eacute;e niveau module, alors ##**aInt**##serait visible &agrave; l'int&eacute;rieur du bloc de port&eacute;e. &Agrave; moins bien s&ucirc;r qu'il n'y ait un conflit de port&eacute;e, auquel cas la variable &agrave; l'int&eacute;rieur du bloc de port&eacute;e aurait pr&eacute;s&eacute;ance sur la variable avec le m&ecirc;me nom mais en dehors du bloc port&eacute;e.

<div class="fb_header"> Dur&eacute;e de vie d'une variable 

La port&eacute;e ne d&eacute;finit pas seulement la visibilit&eacute; d'une variable, elle d&eacute;termine &eacute;galement sa dur&eacute;e de vie. Une variable passe par plusieurs &eacute;tapes dans sa vie; cr&eacute;ation, initialisation, acc&egrave;s et destruction. La port&eacute;e d'une variable d&eacute;pend du moment o&ugrave; cela se produit, c'est &agrave; dire, o&ugrave; la variable a &eacute;t&eacute; d&eacute;finie dans le programme.

** Variables de niveau module **

Les variables au niveau du module existent pour la dur&eacute;e de vie d'un programme, puisqu'elles sont d&eacute;clar&eacute;es dans le corps principal du programme. Le code de niveau module est le code d'ex&eacute;cution principal du programme et se termine lorsque le programme se termine..

** Les variables de niveau sous-routine et fonction **

Les variables d&eacute;clar&eacute;es dans un sous-programme ou une fonction existent aussi longtemps que le programme est dans le corps du sous-programme ou de la fonction. A l'entr&eacute;e dans la ##**Sub/Function**##, la variable est cr&eacute;&eacute;e, initialis&eacute;e et est accessible dans ##**Sub/Function**##. D&egrave;s la sortie de ##**Sub/Function**##, la variable est d&eacute;truite.

** Les variables statiques  **

Une exception aux variables d&eacute;clar&eacute;es dans ##**Sub/Function**## c'est la variable ##**Static**##. Les variables ##Static## conservent leur valeur entre les appels &agrave; ##**Sub/Function**## et ont donc une dur&eacute;e de vie niveau module. 

** Les variables de blocs de contr&ocirc;le **

Les variables d&eacute;clar&eacute;es dans un bloc de contr&ocirc;le, comme un ##**For-Next**## existent tant que le bloc de contr&ocirc;le est ex&eacute;cut&eacute;. Au moment de quitter le bloc de contr&ocirc;le, les variables soient d&eacute;truites.

**  Variables Scope...End Scope **

Les variables d&eacute;clar&eacute;es dans un bloc ##**Scope...End Scope**## existent aussi longtemps que le bloc existe. D&egrave;s que le programme quitte le bloc toutes les variables cr&eacute;&eacute;es dans le bloc sont d&eacute;truites.