{{fbdoc item="title" value="FAQ relative au DOS"}}----

**DOS**

Le portage de ""FreeBASIC"" sous DOS est basé sur le portage [[http://www.delorie.com/djgpp/ DJGPP]] de la chaîne d'outils GNU en DOS mode-protége 32-bit.

Le responsable actuel de ce portage est [[DrV DrV]].

//A écrire: information spécifique à la plateforme, les différences ""Win32""/Linux, les différences avec QB, des tutoriels, etc... //

**Nous RECHERCHONS des TESTEURS** 

La version/cible DOS de ""FreeBASIC"" besoin de plus de testeurs. Si vous êtes intéressé par l'utilisation de ""FreeBASIC"" sous DOS, s'il vous plaît, n'attendez pas la version 1.0, essayez-le dès aujourd'hui. Les tests de fonctionnement sous DOS sur les anciens et nouveaux PC sont les bienvenus (graphiques, E/S fichiers, port série, ...). Si quelque chose ne fonctionne pas, s'il vous plaît placez un rapport de bug détaillé dans le forum ou le traqueur de bogues. Si tout fonctionne bien, vous pouvez aussi écrire sur votre succès. Veillez à tester une version récente de FB (les rapports plus anciens que la version 0,18 de FB seront probablement considérés comme obsolètes et inutiles) et d'étudier ce document **avant** de se plaindre de quelque chose.

**Limitations**

La cible DOS fonctionne correctement et est assez bien soutenue par ""FreeBASIC"" et est mise à jour. Quelques différences existent, cependant, par rapport aux autres plates-formes. Les fonctionnalités manquantes sont principalement celles qui ne sont pas prises en charge par le système d'exploitation ou d'extension DOS ou d'exécution C:
	- Compilation croisée vers une autre cible
	- Multithreading (see FAQ 23)
	- Graphisme en mode fenêtré ou en utilisant ""OpenGL""
	- Réglage de ##[[KeyPgScreenres Screenres]]## à une taille ne correspondant à aucune résolution prise en charge par la carte graphique  
	- Unicode n'est pas supporté sous DOS, ##[[KeyPgWstring Wstring]]## sera le même que ##[[KeyPgZstring Zstring]]##, les jeux de caractères autres que latins ne sont pas pris en charge. (faites-le vous-même)
	- Les bibliothèques partagées (DLL) ne peuvent être créées/utilisées (du moins pas "facilement"), la quantité de bibliothèques externes statiques disponibles et utilisables avec DOS est limitée

**Questions relatives à ""FreeBASIC"" DOS:**

	==- {{anchor name="item1|1. FB est un compilateur 32-bit - ai-je besoin d'un DOS 32 bits?"}}==
	==- {{anchor name="item2|2. 2. Qu'en est-il FreeDOS-32? Est-ce que FB fonctionne/era, y-a/aura-t-il une version?"}}==
	==- {{anchor name="item3|3. Quand j'utilise FreeBASIC sous DOS, j'obtiens un message d'erreur 'Error: No DPMI'!"}}==
	==- {{anchor name="item4|4. Est-il possible se débarrasser de ces CWSDPMI.EXE et CWSDPMI.SWP et comment?"}}==
	==- {{anchor name="item5|5. Puis-je utiliser d'autres DOS "extenders", comme DOS/4GW, Causeway, DOS/32A?"}}==
	==- {{anchor name="item6|6. Où est le bel écran bleu avec tous les ... / Où est l'IDE?"}}==
	==- {{anchor name="item7|7. Comment puis-je consulter la documentation au format CHM ou PDF sous DOS?"}}==
	==- {{anchor name="item8|8. Comment puis-je écrire/modifier mon code source?"}}==
	==- {{anchor name="item9|9. Comment puis-je jouer des sons sous DOS?"}}==
	==- {{anchor name="item10|10. Comment puis-je utiliser un port USB sous DOS?"}}==
	==- {{anchor name="item11|11. Comment puis-je utiliser les graphiques sous DOS?"}}==
	==- {{anchor name="item12|12. DEF SEG est manquant dans FB! Comment puis-je contourner ceci dans mon code?"}}==	
	==- {{anchor name="item13|13. Comment puis-je réécrire CALL INTERRUPT de QB / l'accès aux interruptions DOS et BIOS?"}}==
	==- {{anchor name="item14|14. Comment puis-je réécrire la gestion XMS/EMS de QB?"}}==
	==- {{anchor name="item15|15. FBC gives me a 'cannot find lsupcxx' error!"}}==
	==- {{anchor name="item16|16. Comment puis-je utiliser le port série ou parallèle?"}}==
	==- {{anchor name="item17|17. Comment puis-je utiliser une imprimante?"}}==
	==- {{anchor name="item18|18. Comment puis-je faire une copie d'écran d'un programme DOS fonctionnant en FreeBASIC?"}}==
	==- {{anchor name="item19|19. Le mode graphique ne fonctionne pas (bloquage écran/écran noir/données incorrectes en sortie )!"}}==
	==- {{anchor name="item20|20. Des ennuis de souris! La souris ne fonctionne pas du tout sous DOS/"sauts" de la flèche/etc..."}}==
	==- {{anchor name="item21|21. Qu'en est-il des problèmes des 64K et 640K / quelle quantité de mémoire FB peut-il gérer sous DOS?"}}==
	==- {{anchor name="item22|22. Mon programme se bloque lorsque je tente d'utiliser plus cca 1 MiB de mémoire RAM! Est-ce un bogue dans FreeBASIC?"}}==
	==- {{anchor name="item23|23. Les fonctions de Threading sont invalides dans DOS? A l'aide!"}}==
	==- {{anchor name="item24|24. Les exécutables faits avec FB DOS sont "gonflés"!"}}==
	==- {{anchor name="item25|25. La compilation est très lente avec FB!"}}==
	==- {{anchor name="item26|26. SLEEP ne fonctionne pas! Comment puis-je provoquer un délai?"}}==
	==- {{anchor name="item27|27. Les performances sont très mauvaises sous DOS!"}}==
	==- {{anchor name="item28|28. Puis-je accéder à des secteurs de disque avec FB?"}}==

{{anchor name="item999|Voir aussi"}}

{{fbdoc item="back" value="DocToc|Table of Contents"}}
----

@@**Questions relatives à ""FreeBASIC"" DOS**@@

{{anchor name="item1"}}==1. FB est un compilateur 32-bit - ai-je besoin d'un DOS 32 bits?==
	Non, la version DOS de ""FreeBASIC"" utilise une extension DOS, vous permettant d'exécuter du code 32 bits sur un noyau 16 bits DOS. Vous pouvez utiliser ""FreeDOS"" (16-bit), Enhanced-Dr-DOS, l'ancien D--DOS, ou même MS-DOS jusqu'à la version cca 4.

{{anchor name="item2"}}==2. Qu'en est-il ""FreeDOS-32""? Est-ce que FB fonctionne/era, y-a/aura-t-il une version?==
	""FreeDOS-32"" est expérimental au moment de l'écriture, mais il doit exécuter ""FreeBASIC"" et les applications génèrées sans aucun changement. Alors que le support de FB DOS fonctionne déjà sur ""FreeDOS""(16), il devrait être prêt aussi pour ""FreeDOS-32"". 

{{anchor name="item3"}}==3. Quand j'utilise ""FreeBASIC"" sous DOS, j'obtiens un message d'erreur 'Error: No DPMI'!==
	Vous avez besoin d'un hôte DPMI (DPMI noyau, DPMI serveur), cela signifie "CWSDPMI.EXE" (cca 20 ""KiB"") ou HDPMI32.EXE (cca 34 ""KiB""). Voir les exigences et la FAQ 4 pour plus de détails.  

{{anchor name="item4"}}==4. Est-il possible se débarrasser de ces CWSDPMI.EXE et CWSDPMI.SWP et comment?==
	Oui, il existe 2 possibilités. Pour vous débarrasser de CWSDPMI.EXE et créez un exécutable DOS autonome embarquant CWSDPMI, vous avez besoin du CWSDPMI paquet et du fichier "EXE2COFF.EXE". En utilisant EXE2COFF, vous supprimez le chargeur CWSDPMI.EXE (le fichier perd 2 Kio de taille, il en résulte en un fichier "COFF" sans extension), puis collez le fichier "CWSDSTUB.EXE" avant ce COFF. Le nouvel exécutable est "cca 21 Kio" plus grand que celui d'origine, mais il est autonome, aucun fichier supplémentaire n'est nécessaire. Débarrassez-vous de CWSDPMI.SWP, vous pouvez ensuite modifier votre exécutable avec CWSPARAM.EXE, et désactiver le "swap" (appelé aussi parfois - à tort - "paging").  Notez, cependant, que cela va limiter la mémoire qui peut être attribuée à la quantité de mémoire physique qui est installée dans le système. Ce travail peut être fait à la fois avec le fichier FBC.EXE et tous les exécutables créés par la FBC. La méthode est également décrite dans les docs du le paquet CWSDPMI. Alternativement, vous pouvez utiliser **WDOSX** ou **D3X** extendeur. Ils n'ont pas de swap et de créeent des exécutables autonomes. Puisque qu'ils exécutent votre exécutable dans "Ring 0", leur gestion de "crash" n'est pas très bonne et peut causer des bloquages ou des redémarrages lors des bogues, où d'autres hôtes quitter façon "civile" avec un vidage de registre. De plus, le "spawning" pourrait ne pas bien/pas du tout fonctionner avec WDOSX ou D3X. Enfin, vous pouvez utiliser **HDPMI**. Téléchargez le "HXRT.ZIP" fichier (ici: [[http://japheth.de/HX.html  japheth.de / HX.html ]]), extrayez de "HDPMI32.EXE" (cca 34 Kio) et "HDPMI.TXT" (non requis par le code, juste pour votre information), et incluez-le à votre démarrage DOS ("HDPMI32-r"). Cela rendra HDPMI résident et évitera que tous les programmes ""FreeBASIC"" (également ""FreePASCAL"" et DJGPP) ne protestent du manque de DPMI et "swapping". HDPMI **ne peut pas** être inclus (facilement/encore) dans vos exécutables. L'exécution d'un exécutable contenant D3X, CWSDPMI ou certains hôtes DPMI sous HDPMI ou d'autres hôtes externes est très correcte - l'hôte interne sera tout simplement ignoré. Utiliser DPMI est définitivement nécessaire pour ""FreeBASIC"", car il ne peut pas générer le code 16 bits en mode réel, et il n'y a pas d'autre moyen valable d'exécuter du code 32 bits en mode DOS.

{{anchor name="item5"}}==5. Puis-je utiliser d'autres DOS "extenders", comme DOS/4GW, Causeway, DOS/32A?==
	Aucun "extender". Les soi-disant "WATCOM-like extender" ne peut pas être utilisé en raison de différences importantes dans la gestion de la mémoire et la structure exécutable. WDOSX et D3X doivent fonctionner, car ils ont des "extenders" multi-standard, pas que "WATCOM-like". Vous pouvez aussi utiliser PMODE/DJ (pas "original" Tran's PMODE, ni PMODE/W (!), sauve "cca 5 ""KiB""" comparé à CWSDPMI, peut être inclus dans les EXE, mais peut affecter la sensibilité ou les performances) ou comme le susmentionné, HDPMI.

{{anchor name="item6"}}==6. Où est le bel écran bleu avec tous les ... / Où est l'IDE?==
	Le projet ""FreeBASIC"" se concentre sur le compilateur, générant des exécutables à partir de vos sources BAS. Il semble peu spectaculaire, mais le plus important c'est la qualité des logiciels que vous développez. TLe projet ne comprend pas un IDE. Il existe plusieurs IDE pour ""FreeBASIC"", mais probablement aucune ne dispose actuellement d'une version DOS. Si vous en avez vraiment besoin, vous pouvez essayer "Rhide", mais notez qu'il est compliqué et "buggé", donc utilisez-le à vos propres risques. Voir aussi les FAQ 7 et 8.

{{anchor name="item7"}}==7. Comment puis-je consulter la documentation au format CHM ou PDF sous DOS?==
	Il n'y a pas actuellement de bonne façon d'afficher les fichiers CHM ou PDF sous DOS. Mais, néanmoins, vous pouvez consulter la documentation ""FreeBASIC"". Un des dévellopeurs ""FreeBASIC"", ""coderJeff"" fournit une visionneuse de documentation ""FreeBASIC"" avec les docs incluses dans un format spécial, il y a aussi une version DOS. Elle est semblable à la visionneuse de documentation d'aide intégrée de QB, mais ne contient pas d'éditeur ou d'IDE. Téléchargement: [[http://www.execulink.com/~coder/FreeBASIC/docs.html Downloads coderJeff's Home Page]]

{{anchor name="item8"}}==8. Comment puis-je écrire/modifier mon code source?==
	Il y a de nombreux éditeurs pour DOS, mais seulement peu d'entre eux sont bons - quelques possibilités sont FreeDOS EDIT (utiliser la version 0.7d (!!), limite de 64 Kio, stabilité sous-optimale (enregistrez votre travail régulièrement)), SETEDIT, INFOPAD (livré avec le compilateur CC386, peut éditer aussi les grands textes, a la coloration syntaxique pour le C et ASM, mais pas pour BASIC).

{{anchor name="item9"}}==9. Comment puis-je jouer des sons sous DOS?==
	Il y a 2 manières de jouer du son sous DOS: soit le haut-parleur PC ("archaïque"), célèbre pour son bip si quelque chose se passe mal ou une carte son. Le haut-parleur est facile à contrôler, il a plus de possibilités que l'on pourrait le penser, même de lire des fichiers audio (WAV, avec code de décompression aussi OGG Vorbis, MP3, etc...), vous pouvez ré-utiliser facilement la plupart des codes QB existants (exemple: [[http://www.o-bizz.de/qbdown/qbsound/speaker.zip o-bizz.de/qb...speaker.zip]]) ou du code ASM via inline ASM,  mais fournit seulement un canal et 6 bits, et bien sûr une qualité nettement moins bonne que la carte son, et, sur certains PC plus récents (P4) la qualité du haut-parleur est très mauvaise ou il n'y a pas du tout de haut-parleurs. Pour les anciennes cartes son ISA, il y a beaucoup d'exemples de code, une carte son PCI plus récente peut être utilisée (supposant "bare DOS" dans cette catégorie) soit en utilisant un pilote ("émulation" SB16 compatible), si disponible pour votre carte (malheureusement, ce devient de plus en plus un problème, les pilotes DOS sont pauvres, voire inexistantes), ou accéder à la carte directement (ce qui est de la programmation de bas niveau, liée au matériel, l'assembleur est également nécessaire, et vous avez besoin des docs techniques sur la carte). Il y a quelques sources d'inspiration comme le lecteur audio DOS MPXPLAY (écrit en C avec un peu d'ASM), soutenir les deux méthodes (natif + "emu" pilotes), voir une liste à jour ici: [[http://www.unet.univie.ac.at/~a0503736/php/drdoswiki/index.php?n=Main.SoundCardChip drdos.org/...wiki...SoundCardChip]]. La prise en charge du son sous DOS **n'est pas** l'affaire du portage FB DOS, actuellement FB ne supporte pas le son sur ""Win32"" ni sous Linux - les jeux "se connectent à l'API" plutôt que d'utiliser les commandes ou bibliothèques de ""FreeBASIC"". Pour jouer des fichiers compressés (MP3, OGG Vorbis, FLAC, ...) , vous avez besoin en plus du code décompressé, les portages DJGPP existants de ces bibliothèques devraient être utilisables à cet effet.  

{{anchor name="item10"}}==10. Comment puis-je utiliser un port USB sous DOS?==
	Encore une fois, ce n'est pas le but de FB, vous avez besoin d'un pilote, FB n'a pas de "support" USB sur ""Win32"" et sur Linux non plus, voir  d'autres Wiki: [[http://www.unet.univie.ac.at/~a0503736/php/drdoswiki/index.php?n=Main.USB drdos.org/...wiki...USB]] sur les possibilités d'utilisation de l'USB sous DOS.

{{anchor name="item11"}}==11. Comment puis-je utiliser les graphiques sous DOS?==
	Les GUI ou les graphiques en mode DOS sont tout à fait possibles, il existe plusieurs approches: 
		-Utilisation de la bibliothèque graphique de FB. Elle utilise VESA (préférence linéaire, mais supporte également "banked") pour accéder à la carte vidéo et supporte toutes les résolutions VESA rapportées par le pilote  VESA VBE de la carte, en plus des modes VGA standard.
		Note: utilisez de préférence FB version **0.20** ou plus récente, les graphiques FB DOS ne sont pas très bons sur la version **0.17** et **ne fonctionnent pas du tout** dans les versions précédentes.
		-mode VGA 320x200x8bpp: très simple, une fiabilité et une compatibilité maximales, mais faible résolution et 256 couleurs uniquement, voir exemple.
		-VGA """ModeX""" 320x240x8bpp: similaire à ci-dessus, moins facile, une bonne fiabilité et de compatibilité, mais faible résolution et 256 couleurs uniquement, voir exemple.
		-VGA "planed" mode 640x480x4bpp: difficile d'établir les pixels, une fiabilité et une compatibilité maximales, mais faible résolution et 16 couleurs seulement, encore aucun exemple public (?).
		-Quelques autres modes "odd" VGA """ModeX""" (comme 360x240x8bpp): possible, mais seulement pour les fous ;-)
		-Ã‰crire votre propre code VESA: Plus difficile, bonne compatibilité, haute résolution et couleur vraie possibles, il pourrait y avoir des problèmes de fiabilité si cela n'est pas mis en oeuvre avec soin.
		-Utiliser une bibliothèque externe (DUGL, Allegro, MGL, ""WxWidgets""): Permet de créer des graphiques et GUI "couteux", gonflement de la taille des EXE, obligation de respecter les licences des bibliothèques, perte potentielle de fiabilité.

{{anchor name="item12"}}==12. DEF SEG est manquant dans FB! Comment puis-je contourner ceci dans mon code?==
	DEF SEG est lié à l'adressage 16-bits RM et a été retiré à cause de cela. L'accès "direct" l'accès à VGA ou d'autres zones de  mémoire basse n'est pas possible, parce que le modèle de mémoire de ""FreeBASIC""'s (identique à celui de DJGPP) n'est pas basé sur zéro. Pour accéder à la mémoire basse du DOS, utilisez DOSMEMGET et DOSMEMPUT , voir l'exemple "vga13h.bas" ou "_dos_ds" sélecteur pour "inline ASM", voir exemple:

{{fbdoc item="filename" value="examples/manual/faq/dos/lowmemas.bas"}}%%(freebasic)
'' DOS only example of inline ASM accessing low memory 
'' Run in text mode 80x25 only
''

'' Including dos/go32.bi will define "_dos_ds"
'' "pointing" into GO32 block

#include "dos/go32.bi" 

Dim As UInteger DDS

DDS=_dos_ds

? : ? "Hello world !"
? "_dos_ds=$";Hex$(DDS) 
? "This is just a tEst - abcd ABCD XYZ xyz @[`{ - press any key ..."

Do
  Sleep 1000
  If Inkey$<>"" Then Exit Do
  Asm
	mov  eax,[DDS] '' Directly using "_dos_ds" won't work here !!!
	push eax
	pop  gs        '' Just to get sure, it is usually set anyway
	Xor  ebx,ebx
	aa3:
	mov  al,[gs:0xB8000+2*ebx]
	cmp  al,65  '' "a"
	jb   aa1
	cmp  al,122 '' "z"
	ja   aa1   
	cmp  al,90  '' "Z"
	jbe  aa2
	cmp  al,97  '' "a"    
	jb   aa1 
	aa2: 
	Xor  al,32  '' Swap case
	aa1:
	mov  [gs:0xB8000+2*ebx],al
	inc  ebx
	cmp  ebx,2000
	jne  aa3
  End Asm  
Loop
? : ? "Bye"
End
%%

{{anchor name="item13"}}==13. Comment puis-je réécrire CALL INTERRUPT de QB / l'accès aux interruptions DOS et BIOS?==
	Ces interruptions sont accessibles seulement en utilisant la version/cible DOS de FB.

	L'accès aux interruptions est plus lent que dans QB: avec FB l'hôte DPMI devra faire deux changements de contexte, passer en mode réel et en revenir. Tout cela va "manger" des centaines de cycles d'horloge dans le DOS "raw" et des milliers de cycles d'horloge si emm386 est chargé ou est à l'intérieur d'une "box DOS de Windows". Le ralentissement pourrait être négligeable ou perceptible, ça dépend. Vous devriez essayer de minimiser le nombre de ces appels, et traiter plus de données par appel - au moins plusieurs Kio, et pas seulement un octet ou quelques octets.
 
	Utilisation du "wrapper DPMI de DJGPP":

{{fbdoc item="filename" value="examples/manual/faq/dos/call-int.bas"}}%%(""FreeBASIC"")
#include "dos/dpmi.bi"

type RegTypeX as __dpmi_regs

#define INTERRUPTX(v,r) __dpmi_int( v, @r )
%%

	Sinon, vous pouvez appeler les INT via "inline ASM", 2 choses importantes auxquelles vous devez faire attention sont le fait que le modèle dde mémoire de FB n'est pas basé sur zéro (voir aussi FAQ 12, questions sur "DEF SEG"), et de plus passer "directement" des adresses (comme DS:[E]DX) à une INT will ne fonctionnera pas, sauf que vous avez un hôte DPMI avec "DOS API translation".  

{{anchor name="item14"}}==14. Comment puis-je réécrire la gestion XMS/EMS de QB?==
	Cela dépend pourquoi le code original l'utilise. Si c'est juste pour contourner les limites de la mémoire basse, il suffit de la retirer et d'utiliser des types de données FB "ordinaires"/fonctions de gestion de la mémoire à la place. Si elle est utilisée pour le DMA (son), vous n'avez pas de chance et devez de refondre complètement le code, sur le son voir FAQ 9. Pour le DMA utiliser de préférence la mémoire basse (cela ne devrait pas être un gros problème, puisque le code d'application et la plupart des tampons sont dans la mémoire DPMI), le DMA dans la mémoire DPMI est possible mais plus difficile.  

{{anchor name="item15"}}==15. FBC me donne un ne peut pas trouver "lsupcxx' error"!==
	L'origine de ce problème est le fichier **libsupcxx.a** dans le répertoire **LIB\DOS\**, il a 9 caractères dans son nom. Votre faute est d'avoir extrait le fichier ZIP avec la permission des noms de fichiers longs, généralement sous Windows et puis vous utilisez FB dans le DOS sans prise en charge des noms de fichiers longs, il en résulte que ce fichier apparaît **LIBSUP~1.A** et ne peut être trouvé. Renommez le fichier **LIBSUPCX.A** (un seul **X**) ou extrayez à nouveau le fichier ZIP en DOS. Note: change dans FB 0.18, il est nécessaire de re-tester. 

{{anchor name="item16"}}==16. Comment puis-je utiliser le port série ou parallèle?==
	L'interruption DOS INT14 n'est pas très utile/efficace car elle envoie/lit un seul caractère à chaque appel. Il est donc préférable d'utiliser une bibliothèque externe "DOS32 comms". /* quelqu'un en connaît-il une bonne? */ FB jusqu'à 0.18.2 ne supporte pas OPEN COM sur la cible DOS, ""coderJeff"" a un(e) bibliothèque/pilote expérimental(e) de disponible, inclus(e) dans FB version 0.18.3 et versions suivantes. 

{{anchor name="item17"}}==17. Comment puis-je utiliser une imprimante?==
	Le noyau DOS ne vous aidera pas ici, donc vous avez à préparer vous-même le texte (trivial) ou des données "bitmap" ( facilement acceptable pour les imprimantes compatibles avec le standar "ESC/P") et les envoyer à l'imprimante via le port parallèle ou USB en utilisant un pilote supplémentaire (voir FAQ 10). On ne peut pas faire fonctionner sous DOS, avec un effort raisonnable, les imprimantes dites "GDI" ou "Windows".

{{anchor name="item18"}}==18. Comment puis-je faire une copie d'écran d'un programme DOS fonctionnant en ""FreeBASIC""?==
	L'idéal est inclure cette fonctionnalité dans votre propre code. Les copieurs d'écran DOS basés sur TSR, comme SNARF, pour la plupart vont fonctionner avec des écrans en mode texte, mais probablement aucun d'entre eux avec la bibliothèque ""FreeBASIC"" de GFX. Ce n'est pas vraiment un bug sur un côté ou un autre, c'est un problème "de par leur conception" (by design).

{{anchor name="item19"}}==19. Le mode graphique ne fonctionne pas (bloquage écran/écran noir/données incorrectes en sortie )!==
	Placez un rapport de bogue dans le forum. Pour le rendre aussi utile et productif que possible, s'il vous plaît méfiez-vous de ce qui suit, suivez les étapes données et de fournissez toutes les informations relatives:
		- Les graphiques pourraient ne pas bien (ne pas) fonctionner (du tout) sur de très anciens PC. Si votre CPU a moins de 500 MHz de cca, fournissez des informations exactes à son sujet, si vous ne savez pas, utilisez le programme """RayeR""'s CPUID" ou similaire pour tester. 
		- Des informations exactes sur votre carte graphique sont nécessaires. Testez sur DOS en utilisant VBEDIAG de [[DrV DrV]] (ne rapportez que les informations) et VESATEST de RayeR (essayer aussi de définir le mode, permet l'inspection visuelle du résultat). Déterminez si les modes "utiles" (640x480, 800x600) sont supportés et avec quelles profondeur (8, 16, 24, 32 bpp), et si cela peut être réglé et est visible correctement.  
		- Déterminez et décrivez exactement ce qui est faux ("mode fonctionne avec VESATEST mais pas avec FB", "aucun graphique mais aucune erreur non plus", "écran noir et bloquage écran", "graphismes mauvais/incomplets", ...).
		- Si certains programmes sophistiqués ne fonctionnent pas, essayez aussi un test minimal comme placer un cercle au milieu de l'écran.
		- Essayez sans pilote de la souris (ce qui réduit le "coût" CPU).
		- Déterminez quels modes sont touchés. Si un mode ne fonctionne pas, réduisez la résolution ou la profondeur, veillez à tester les modes les plus sûrs / les moins "lourds" 640x480 avec 32/24/16/8 bpp, 640x480 avec 4 bpp et 320x200 avec 8bpp.
		- Pour certaines cartes anciennes il y a des pilotes VESA disponibles (S3VBE/UVIVBE). Testez avec et sans, et incluez cette information dans votre rapport. 
		- Remove potentially problematic content (memory managers, drivers) from DOS startup files. Nothing of such is required for FB, except a DPMI host (see also FAQ 4.).
		- Postez l'info sur votre carte graphique, processeur (si ancien), le type et la version du DOS, les symptômes de bugs et un exemple de code simple.
	VESATEST et CPUID de ""RayeR"" peuvent être téléchargés ici: [[http://rayer.ic.cz/programm/programe.htm rayer.ic.cz/programm/programe.htm]] et VBEDIAG ici [[http://drv.nu/vbediag/ drv.nu/vbediag/]].

{{anchor name="item20"}}==20. Des ennuis de souris! La souris ne fonctionne pas du tout sous DOS/"sauts" de la flèche/etc...==
	Pour utiliser une souris dans le DOS, vous avez besoin d'un pilote compatible, reconnaissant votre souris et reconnu par une bibliothèque ""FreeBASIC"". Pour des résultats optimaux, il vous faut un **bon** pilote et une souris **adaptée**. 

	Souris: le choix optimal et aujourd'hui facilement disponible, est une souris PS/2. L'ancien type d'une souris série devrait fonctionner lui aussi. Le plus récent est la souris USB - mais n'est pas très approprié pour une utilisation en mode DOS, car serait nécessaire pour la compatibilité un pilote (INT33) de haute qualité natif de souris USB (non disponible à ce jour, seuls quelques expérimentaux), ou compter sur l'émulation du BIOS (pas toujours disponible, ou "imprécise").

	Pilote: le choix préféré est CTMOUSE du projet ""FreeDOS"". Les versions 1.9a1, 2.0a4 et 2.1b4 de Juillet 2008 sont disponibles. Inclus avec (mais non limité à) ""FreeDOS"" ou télécharger une version ici: [[http://www.ibiblio.org/pub/micro/pc-stuff/freedos/files/dos/mouse/ ibiblio.org/pub/...mouse]]. Aucun d'eux n'est parfait, mais ils sont encore très utilisables et meilleurs que la plupart des concurrents. 1.9xx and 2.1xx will collabore avec BIOS, permettant l'émulation USB, 2.0xx ignore le BIOS et ainsi l'émulation USB **NE fonctionne PAS**.Les pilotes de souris Logitech également fonctionnent souvent correctement, à télécharger ici: [[http://www.uwe-sieber.de/util_e.html uwe-sieber.de/util_e.html]] - la version 6.50 est un bon début. Connus pour des problèmes il y a DRMOUSE et certaines versions (anciennes?) de MSMOUSE.

	Si la souris ne fonctionne pas du tout, alors très probablement le pilote n'est pas chargé, ne reconnaît pas la souris (voir les messages du pilote) ou n'est pas compatible avec l'INT33 "standard". Pour la souris USB, l'activation de "l'émulation de la souris USB" dans les paramètres du BIOS peut vous aider. 

	Si le contrôle de la souris est "imprécis", la flèche "saute", alors soit vous avez un mauvais pilote - utilisez-en un meilleur ou l'émulation du BIOS est mauvaise - alors, la solution est d'acheter une souris PS/2.

{{anchor name="item21"}}==21. Qu'en est-il des problèmes des 64K et 640K / quelle quantité de mémoire FB peut-il gérer sous DOS?==
	La gestion de la mémoire est l'affaire de l'hôte DPMI, plutôt que du compilateur. ""FreeBASIC"" et les exécutables qu'il génère **ne** souffre **pas** de ce problème, car du code 32 bits DPMI est utilsé, plutôt que le mode réel. Vous pouvez utiliser presque toute la mémoire de votre PC, avec quelques limitations, mais on est largement **au-dessus** des 64 ou 640 Kio. CWSDPMI **r5** est vérifiée pour bien fonctionner jusqu'à 512 ""MiB"" seulement, toute la mémoire supplémentaire ne plante pas le système (contrairement à certaines anciennes versions), mais est tout simplement ignorée. HDPMI est censé gérer plus: jusqu'à 4 Gio (la limite de l'adressage 32 bits), mais il n'y a pas eu beaucoup d'essais sur ces énormes machines - vérifié jusqu'à cca 1,5 Gio. ""FreeBASIC"" et le code généré **ne** nécessitent **pas** les classiques gestionnaires DOS de mémoire (HIMEM / XMS et EMM386/EMS), mais sont censés coexister avec eux s'ils sont présents. Tout cela s'applique bien sûr seulement au vrai DOS, des choses comme "Dos Box" garderont le contrôle sur la gestion de la mémoire et de fourniront seulement un petit morceau de la mémoire (cela dépend, jusqu'à cca 64 ""MiB"") à votre code DOS. 

{{anchor name="item22"}}==22. Mon programme se bloque lorsque je tente d'utiliser plus cca 1 ""MiB"" de mémoire RAM! Est-ce un bogue dans ""FreeBASIC""?==
	Non, ce n'est pas un bogue dans ""FreeBASIC"" et ce n'est pas vraiment spécifique au DOS, voir aussi [[CompilerFAQ FAQ du Compilateur]]. Pour un débutant, la meilleure solution est d'utiliser ##[[KeyPgShared Shared]]## pour les tableaux. Les utilisateurs plus avancés peuvent envisager d'utiliser les fonctions de gestion de la mémoire, comme ##[[KeyPgAllocate Allocate]]##. Ceci est encore plus important dans le DOS, car cela permet d'exécuter l'application sur les ordinateurs ayant peu de mémoire (tout en permettant au moins d'éditer petits textes, par exemple), ainsi que d'utiliser toute la RAM énorme si disponibles (et éditer des textes énormes, par exemple).  

{{anchor name="item23"}}==23. Les fonctions de Threading sont invalides dans DOS? A l'aide!==
	Les [[CatPgThreading fonctions de gestion du Threading]] ne sont pas prises en charge pour la cible, pour le moment, et très probablement ne le seront pas bientôt/jamais. La raison est simple: ni le noyau DOS, ni le DPMI host/standard, ni "GO32" DOS Extender ne les gèrent, contrairement au noyau ""Win32"" ou Linux. Comme d'habitude, DOS ne vous alertera pas ici, mais d'autre part rien n'est impossible d'autre part dans le DOS: vous pouvez configurer votre "threading" en haut de DPMI, il y a de multiples possibilités: 
		- Mettez en place un ISR, voir l'exemple "ISR_TIMER.BAS". Ce n'est pas un de remplacement "complet", mais suffisant dans certains cas.
		- Il y a une bibliothèque **pthreads** pour DJGPP permettant d'"émuler" un certain degré de threading comme-dans-Linux-like. Il fonctionne de façon acceptable pour le  portage [P]7-ZIP DJGPP (écrit en C++), pas encore de tests avec FB.

{{anchor name="item24"}}==24. Les exécutables faits avec FB DOS sont "gonflés"!==
	C'est vrai, mais il n'y a pas de moyen facile/rapide de correction. FB est un compilateur 32 bits HLL et la plupart de la taille est importée de DJGPP. !à écrire! ( voir le forum: [[http://freebasic.net/forum/viewtopic.php?t=11757 freebasic.net/forum/viewtopic.php?t=11757]] )

{{anchor name="item25"}}==25. La compilation est très lente avec FB!==
	Problème: "FBC prend 10 secondes pour compiler un programme "Hello world" program"! ""TurboBASIC""/QBASIC/VBDOS/""PowerBASIC"" mettent < 1 seconde pour cela..."

	C'est vrai, mais cela est un problème de conception ("by design"): FB compile vos sources en 3 étapes, enregistrement des fichiers intermédiaires, tel que décrit dans CompilerCmdLine, alors que de nombreux compilateurs plus anciens ne font qu'une seule passe en mémoire. Ceci est lié essentiellement aux performances E/S fichiers, voir FAQ 27 ci-dessous sur les possibilités d'améliorations, deplus une petite amélioration peut être obtenue ici en rendant l'hôte DPMI résident (**HDPMI32 -r** ou **CWSDPMI -p** , voir FAQ 4 ci-dessus). Notez que le délai est de essentiellement "additif", de sorte qu'il ne sera pas trop "douloureux" avec les grands projets.

{{anchor name="item26"}}==26. SLEEP ne fonctionne pas! Comment puis-je provoquer un délai?==
	##[[KeyPgSleep Sleep]]## fonctionne ... mais il a seulement une résolution de cca 55ms = 1/18s, ainsi "SLEEP 500" est très bien, tandis que par exemple en utilisant "SLEEP 2" pour 2 millisecondes ne fonctionnera pas. !à écrire! / !à corriger! 
		- Le "timer PIT/BIOS" (tourne à 18.2 Hz par défaut), PEEK le timer BIOS ou définissez le votre propre, voir l'exemple "ISR_TIMER.BAS", augmentez la fréquence PIT (à utiliser avec précaution)
		- Sonder le "timer BIOS + PIT counter", méthode de TIMERHLP.ASM à partir de DKRNL32, permet d'améliorer la précision de ce qui précède, sans élever la fréquence PIT 
		- L'iinstruction RDTSC (Pentium et plus récents)
		- L'horloge RTC
		- Les boucles de délai

{{anchor name="item27"}}==27. Les performances sont très mauvaises sous DOS!==
	Problème: "Les performances sous DOS sont médiocres par rapport aux binaires ""Win32""/Linux compilés à partir de la même source!" ou "Pire encore, le même binaire DOS fonctionne beaucoup plus rapidement dans NTVDM que dans DOS!"

	Les deux effet peuvent arriver, néanmoins, DOS n'est rien prédestiné à être lent, les inefficacités peuvent être corrigées. Vous devez d'abord identifier la zone où le code affaiblit les performanCan I access disk sectors with FBces. 

		**E/S fichier** : DOS utilise par défaut très peu de mémoire pour ses tampons, tandis que d'autres systèmes en utilisent beaucoup plus et sont "agressifs" avec la mise en cache de fichiers. Lorsque vous traitez beaucoup de petits fichiers, il en résulte les performances se dégradent sérieusement. La solution est d'installer un cache de fichiers, par exemple, **LBACache**, ou vous pouvez installer un RAMDISK (un bon: **SRDISK** ) et copier les fichiers "fautifs" à l'intérieur (par exemple l'installation ""FreeBASIC"") et travailler dessus (veillez à sauvegarder votre travail sur un support plus durable régulièrement). Les deux nécessitent un hôte XMS (utilisez **HIMEMX** ). En outre DOS utilise par défaut le BIOS pour accéder aux disques durs, tandis que les autres systèmes s'efforcent de trouver et d'utiliser DMA. Un test utile: IDECHECK de Japheth (Téléchargement: [[http://www.japheth.de/Download/IDECheck.zip japheth.de/Download/IDECheck.zip]]) - lancez-le en modes "I13" et "DMA" et comparez les résultats. Si "DMA" est plus rapider (peut être 1 ... 10 fois, dépend du modèle de PC), puis installer un pilote DOS DMA (par exemple **XDMA 3.1** vaut la peine d're essayé) peut apporter une grande accélération sur de gros fichiers. Assurez-vous également de lire et d'écrire les données par gros fragments (16 Kio au moins), pas seulement quelques octets. Les autres systèmes d'exploitation sont plus indulgents ici, mais sous DOS chaque appel d'E/S fichier provoque un petit délai "additif", donc une conception efficace du code avec mise en tampon mémoire bonne est cruciale.

		**Graphiques** : Pentium 2 et les CPU plus récents ont une fonction cache similaire appelée "MTRR" pour accélérer l'écriture sur la RAM vidéo. Les pilotes des autres systèmes d'exploitation l'active généralement.  Ni DOS (car il ne traite pas des graphismes), ni FB GFX ne le font. Utilisez l'outil "VESAMTRR" de Japheth (contenu dans le paquet "HXGUI.ZIP"), il permettra à l'accélération, survivant aussi aux commutateurs de mode et à la plupart des plantages "non-fatal" d'applications, jusqu'à un redémarrage. Le facteur d' accélération possible varie beaucoup en fonction du modèle de PC, jusqu'à cca 20 fois. En outre la manipulation de la souris mobilise des performances du processeur (trop) sous DOS, c'est un point faible connu (la conception du DOS FB GFX n'est pas "très mauvaise", c'est juste le "standard" commun - ce qui n'est pas très bon), la correction est théoriquement possible mais pas facile, vous pouvez seulement essayer plusieurs pilotes de la souris (voir FAQ 20).

{{anchor name="item28"}}==28. Puis-je accéder à des secteurs de disque avec FB?==
	Vous pouvez ... mais ""FreeBASIC"" ne vous aidera pas trop ici: pas de solution "portable", utilisez une méthode de faible niveau spécifique à l'OS. Pour DOS, 3 méthodes sont possibles: 
		- Utilisez les fonctionnalités logiques d'accès au disque du DOS pour l'accès du secteur en contournant le système de fichiers, voir par exemple dans le forum: [[http://freebasic.net/forum/viewtopic.php?t=11830 freebasic.net/forum/viewtopic.php?t=11830]]
		- Utilisez l'interruption BIOS INT 13 sur les disques physiques, contournant le DOS
		- Utilisez les ports CPU, de niveau le plus bas, contournant à la fois DOS et BIOS (encore aucun exemple FB, voir le source de IDECHECK de la FAQ 27 ci-dessus, le forum FASM ou des ressources de développement des OS)
	Notez que ces expériences sont quelque peu "dangereuses" - vous pouvez facilement perdre des données ou rendre votre PC indémarrable, si quelque chose fonctionne mal.

{{anchor name="item999"}}{{fbdoc item="see"}}
	- [[CompilerFAQ FAQ du compilateur]].
	- [[FaqPgrtlib FAQ de la bibliothèque d'exécution de FB]].
	- [[FaqPggfxlib2 Questions Fréquemment Posées sur la bibliothèque graphique de FreeBASIC]]

{{fbdoc item="back" value="DocToc|Table of Contents"}}

