{{fbdoc item="title" value="DIM"}}----
Déclare une variable

{{fbdoc item="syntax"}}
	Déclaration d'une variable unique:
		##**Dim** [[[KeyPgShared Shared]]] //symbolname// [As [[DataType DataType]]] [, ...]##
		##**Dim** [[[KeyPgShared Shared]]] As [[DataType DataType]] //symbolname// [, ...]##

	Déclaration de tableaux:
		##**Dim** [[[KeyPgShared Shared]]] //symbolname// ( [//lbound// To] //ubound// [, ...] ) [As [[DataType DataType]]] [,...]##
		##**Dim** [[[KeyPgShared Shared]]] As [[DataType DataType]] //symbolname// ( [//lbound// To] //ubound// [, ...] ) [,...]##
	
	Initialisation de variables:
		##**Dim** //scalar_symbol// As [[DataType DataType]]] = //expression// | [[KeyPgAny Any]]##
		##**Dim** //array_symbol// ([//lbound// To] //ubound//) [AS [[DataType DataType]]] => { //expression// [, ...] } | [[KeyPgAny Any]]##
		##**Dim** //udt_symbol// As [[DataType DataType]] = ( //expression// [, ...] ) | [[KeyPgAny Any]]##

{{fbdoc item="desc"}}
	Déclare une variable par son nom et réserve de la mémoire pour la stocker.

	Les variables doivent être déclarées avant leur utilisation dans le dialecte //[[CompilerOptlang -lang fb]]// ou lors de leur utilisation si vous utilisez l'##[[KeyPgOptionexplicit Option Explicit]]## des autres dialectes.  Seuls les dialectes //[[CompilerOptlang -lang qb]]// et //[[CompilerOptlang -lang fblite]]// acceptent que les variables soient utilisées sans déclaration préalable, dans ce cas elles sont appelées en tant que variables implicites.

	##**Dim**## peut être utilisé pour déclarer et affecter des variables de l'un des types de données pris en charge, types définis par l'utilisateur ou énumérations.

	Selon l'endroit, où et comment une variable ou un tableau est déclaré peut changer la façon dont il(elle) est alloué(e) dans la mémoire.  Voir //[[ProPgStorageClasses Classes de stockage]]//.

{{fbdoc item="section" value="Variables explicites avec des données de type explicite"}}
	Dans le dialecte par défaut //[[CompilerOptlang -lang fb]]//, chaque variable doit être explicitement déclarée avec le type de données désiré. Les suffixes de type ne sont pas permis.

	Plus d'une variable peut être déclarée dans un seul ##**Dim**## en séparant les déclarations de variable par des virgules.

{{fbdoc item="filename" value="examples/manual/check/KeyPgDim_1.bas"}}%%(freebasic)
'' Variable declaration examples

'' One variable per DIM statement
dim text as string
dim x as double

'' More than one variable declared, different data types
dim k as single, factor as double, s as string

'' More than one variable declared, all same data types
dim as integer mx, my, mz ,mb

'' Variable having an initializer
dim px as double ptr = @x
%%

{{fbdoc item="section" value="Variables explicites avec des types de données implicites"}}
	Dans les dialectes //[[CompilerOptlang -lang qb]]// et //[[CompilerOptlang -lang fblite]]//, même si la variable est déclarée explicitement, un type sera automatiquement attribué si le type de données n'est pas explicitement donné, soit par le nom, soit par le suffixe.  Le type de données par defaut est ##[[KeyPgSingle Single]]## dans le dialecte //[[CompilerOptlang -lang qb]]// et ##[[KeyPgInteger Integer]]## dans le dialecte //[[CompilerOptlang -lang fblite]]//.  Le type de données par défaut peut être changé au cours du listing du code source par l'utilisation des déclarations du style ##**Def""###""**##. (par exemple, ##[[KeyPgDefint DefInt]]##, ##[[KeyPgDefstr DefStr]]##, ##[[KeyPgDefsng DefSng]]##)

{{fbdoc item="filename" value="examples/manual/check/KeyPgDim_2.bas"}}%%(freebasic)
'' Compile with -lang qb

'$lang: "qb"

'' All variables beginning with A through N default to the INTEGER data type
'' All other variables will default to the SINGLE data type
DefInt I-N

'' I and J are INTEGERs
'' X and Y are SINGLEs
'' T$ is STRING
'' D is DOUBLE

Dim I, J, X, Y, T$, D As Double
%%

{{fbdoc item="section" value="Tableaux"}}
	Comme avec la plupart des dialectes BASIC, ""FreeBASIC"" supporte les tableaux avec des indices allant d'une limite inférieure à une limite supérieure.  Dans les différentes syntaxes ci-dessus, ##//lbound//## se réfère à la limite inférieure, ou au plus petit indice.  Et ##//Ubound//## se réfère à la limite supérieure, ou au plus grand indice.  Si la limite inférieure n'est pas spécifiée, elle sera zéro par défaut, à moins que ##[[KeyPgOptionbase Option Base]]## ne soit utilisée.

{{fbdoc item="filename" value="examples/manual/check/KeyPgDim_3.bas"}}%%(freebasic)
Const upperbound = 10

'' Declare an array with indexes ranging from 0 to upperbound, 
'' for a total of (upperbound + 1) indexes.
Dim array(upperbound) As Single
%%

	Les tableaux multi-dimensionnels peuvent être déclarés ainsi et sont stockés dans l'ordre des lignes: les valeurs avec le même dernier indice sont contiguës. (Ceci est différent de QB par défaut.  Le nombre maximum de dimensions d'un tableau multi-dimensionnel est de 8. 

{{fbdoc item="filename" value="examples/manual/check/KeyPgDim_4.bas"}}%%(freebasic)
'' declare a three-dimensional array of single 
'' precision floating-point numbers.
Dim array(1 To 2, 6, 3 To 5) As Single

'' The first dimension of the declared array 
'' has indices from 1 to 2, the second, 0 to 6, 
'' and the third, 3 to 5.
%%			

	Pour plus d'informations sur les tableaux voir [[ProPgArrays Vue d'ensemble sur les tableaux ]].

	Si les valeurs utilisées avec ##**Dim**## pour déclarer les dimensions d'un tableau sont toutes des constantes, le tableau sera créé ##[[KeyPgOptionstatic Static]]## (sauf si l'##[[KeyPgOptiondynamic Option Dynamic]]## est spécifiée), bien qu'en utilisant une ou plusieurs variables pour déclarer les dimensions d'un tableau cela le rende de longueur variable, même si l'##[[KeyPgOptionstatic Option Static]]## est effective.

	Les tableaux peuvent être déclarés de longueur variable de plusieurs façons: en utilisant ##**Dim**## avec un ensemble vide d'indices (##**Dim** x()##), en utilisant ##**Dim**## avec des indices qui sont des variables ou en utilisant le mot-clef ##[[KeyPgRedim Redim]]##, ou le en déclarant par la méta-commande ##[[KeyPgMetaDynamic $Dynamic]]##. les tableaux de longueur variable ne peuvent pas utiliser des initialiseurs.

	Les tableaux déclarés avec ##**Dim**## ayant des indices constants et non précédés par ##[[KeyPgOptiondynamic Option Dynamic]]## sont de longueur fixe (non redimensionnables pendant l'exécution) et peuvent utiliser des initialiseurs.

	La limite supérieure peut être suggérée (##[[KeyPgDots ...]]##, 3 points).  Ainsi la limite supérieure sera réglée automatiquement en fonction du nombre d'éléments présents lors de l'initialisation.  Lorsque l'ellipse est utilisée de cette manière, un initialiseur doit être utilisé, et il ne peut pas être ##**Any**##.  Voir la page [[KeyPgDots Ellipse - suggestion]] pour un court exemple.

	Voir aussi //[[ProPgFixLenArrays Tableaux de longueur fixe]]// et //[[ProPgVarLenArrays Tableaux de longueur variable]]//.

{{fbdoc item="section" value="Initialiseurs"}}
	Tableaux, variables, chaînes et types définis par l'utilisateur sont initialisés à zéro ou avec des chaînes nulles par défaut lors de leur création.

	Pour éviter la surcharge des variables à l'initialisation, l'initialiseur ##**Any**## peut être utilisé avec ##**Dim**## pour dire au compilateur de seulement réserver de la place en mémoire pour la variable, mais qu'elle ne doit pas être initialisée, de sorte que la variable contiendra n'importe quoi. Dans ce cas, le programmeur ne doit pas tenir compte des valeurs initiales.

	Les tableaux à longueur fixe, les variables, les zstrings et les types définis par l'utilisateur peuvent recevoir une valeur au moment de leur déclaration, en faisantsuivre la déclaration de la variable par un initialiseur.  Notez la différence entre les différents types d'initialisation. Les tableaux, les variables et les types définis par l'utilisateur sont initialisés comme dans une affectation normale, en utilisant un signe d'égalité ( ##=## ).  Le signe ##=>## peut être utilisé avec des chaînes de longueur fixe, pour éviter que la déclaration ne ressemble à une expression.

	 Les valeurs d'un tableau sont données par des valeurs séparées par des virgules, l'ensemble délimité par des accolades, et les valeurs des types utilisateur sont données par des valeurs séparées par des virgules, le tout délimité par des parenthèses.  Ces méthodes d'initialisation des variables peuvent être imbriquées les unes dans les autres pour des tâches complexes. L'imbrication permet l'initialisation de tableaux de n'importe quelle dimension.

{{fbdoc item="filename" value="examples/manual/check/KeyPgDim_5.bas"}}%%(freebasic)
'' Declare an array of 2 by 5 elements
'' and initialize
Dim array(1 To 2, 1 To 5) As Integer => {{1, 2, 3, 4, 5}, {1, 2, 3, 4, 5}}
%%			

	{{fbdoc item="filename" value="examples/manual/check/KeyPgDim_6.bas"}}%%(freebasic)
'' declare a simple UDT
Type mytype
	var1 As Double
	var2 As Integer
End Type

'' declare a 3 element array and initialize the first
'' 2 mytype elements
Dim myvar(0 To 2) As mytype => {(1.0, 1), (2.0, 2)}
%%	
	Au niveau module, de longueur fixe ou variables globales, les valeurs d'initialisation doivent être des expressions constantes.  ""FreeBASIC"" signalera autrement une erreur de compilation.

	Note: L'initialisation de types de données utilisateur avec des chaînes n'est pas supportée pour le moment.

{{fbdoc item="section" value="Variables explicites avec type suffixes"}}
	Dans les dialectes //[[CompilerOptlang -lang qb]]// et //[[CompilerOptlang -lang fblite]]//, le type de données d'une variable peut être indiquée par un suffixe de type ( ""#""#$## ##%## ##### ##!## ##&## ).

{{fbdoc item="filename" value="examples/manual/check/KeyPgDim_7.bas"}}%%(freebasic)
'' Compile with -lang qb or fblite

'$lang: "qb"

'' A string variable using the $ type suffix
Dim strVariable$

'' An integer variable using the % type suffix
Dim intVariable%

'' A long variable using the & type suffix
Dim lngVariable&

'' A single precision floating point variable using the ! type suffix
Dim sngVariable!

'' A double precision floating point variable using the # type suffix
Dim dblVariable#
%%

{{fbdoc item="ex"}}
{{fbdoc item="filename" value="examples/manual/variable/dim.bas"}}%%(freebasic)
Dim a As Byte
Dim b As Short
Dim c As Integer
Dim d As LongInt
Dim au As UByte
Dim bu As UShort
Dim cu As UInteger
Dim du As ULongInt
Dim e As Single
Dim f As Double
Dim g As Integer Ptr
Dim h As Byte Ptr
Dim s1 As String * 10   '' fixed length string
Dim s2 As String        '' variable length string
Dim s3 As ZString Ptr   '' zstring

s1 = "Hello World!"
s2 = "Hello World from FreeBASIC!"
s3 = Allocate( Len( s2 ) + 1 )
*s3 = s2

Print "Byte: "; Len(a)
Print "Short: "; Len(b)
Print "Integer: "; Len(c)
Print "Longint: "; Len(d)
Print "UByte: "; Len(au)
Print "UShort: "; Len(bu)
Print "UInteger: "; Len(cu)
Print "ULongint: "; Len(du)
Print "Single: "; Len(e)
Print "Double: "; Len(f)
Print "Integer Pointer: "; Len(g)
Print "Byte Pointer: "; Len(h)
Print "Fixed String: "; Len(s1)
Print "Variable String: "; Len(s2)
Print "ZString: "; Len(*s3)

Deallocate(s3)
%%

{{fbdoc item="section" value="Differences de dialectes"}}
	- Dans les dialectes //[[CompilerOptlang -lang qb]]// et //[[CompilerOptlang -lang fblite]]//, les variables ont une portée procédure si elles sont définies dans une procédure, et pour l'ensemble du module si elles sont définies avec ##**Dim Shared**##.
	- Dans les dialectes //[[CompilerOptlang -lang fb]]// et //[[CompilerOptlang -lang deprecated]]//, les variables définies à l'intérieur de blocs composés (##[[KeyPgFornext For..Next]]##, ##[[KeyPgWhilewend While..Wend]]##, ##[[KeyPgDoloop Do..Loop]]##, ##[[KeyPgScope Scope..End Scope]]##) ont une [[ProPgVariableScope portée]] locale, et ne sont visibles que dans ces blocs.
	- Dans le dialecte //[[CompilerOptlang -lang fb]]//, la déclaration ##**Option**## (par exemple ##[[KeyPgOptionbase Option Base]]##, ##[[KeyPgOptiondynamic Option Dynamic]]##), les métacommandes (par exemple ##[[KeyPgMetaStatic $Static]]##) et les ##**Def""###""**## (par exemple ##[[KeyPgDefint DefInt]]##) ne sont pas permises.

{{fbdoc item="diff"}}
	- Les initialiseurs de variables sont nouveaux pour ""FreeBASIC""
	- La syntaxe alternative ##Dim As DataType //symbolname//, [...]## est nouvelle pour ""FreeBASIC""
	- Les tableaux multidimensionnels sont stockés dans l'ordre ligne-prioritaire dans ""FreeBASIC"", ils sont stockés dans l'ordre des colonnes-prioritaire dans QB par défaut. Ordre ligne-prioritaire: les valeurs avec le même indice de fin sont contiguës. Ordre colonne-prioritaire: les valeurs avec le même indice de début sont contiguës.
	- Des tableaux de longueur variable jusqu'à 2 Go de taille sont possibles dans ""FreeBASIC"". Dans QB, ##$STATIC## les tableaux sont limités à 64 ""KiB"" , ou à la mémoire DOS libre (quelques 100 ""KiB"", au mieux) si ##$DYNAMIC## et ///AH// sont utilisés.
	- La forme elliptique pour les limites supérieures est nouvelle pour ""FreeBASIC"".

{{fbdoc item="see"}}
	- ##[[KeyPgVar Var]]##
	- ##[[KeyPgCommon Common]]##
	- ##[[KeyPgExtern Extern]]##
	- ##[[KeyPgRedim Redim]]##
	- ##[[KeyPgPreserve Preserve]]##
	- ##[[KeyPgShared Shared]]##
	- ##[[KeyPgStatic Static]]##
	- ##[[KeyPgErase Erase]]##
	- ##[[KeyPgLbound LBound]]##
	- ##[[KeyPgUbound UBound]]##
	- ##[[KeyPgDots ... (Ellipsis)]]##
{{fbdoc item="back" value="CatPgVariables|Variable Declarations"}}
