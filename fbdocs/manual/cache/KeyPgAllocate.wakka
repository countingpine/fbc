{{fbdoc item="title" value="ALLOCATE"}}----
Alloue un bloc de m&eacute;moire &agrave; partir de la m&eacute;moire libre

{{fbdoc item="syntax"}}##
	[[KeyPgDeclare declare]] [[KeyPgFunction function]] **Allocate** [[KeyPgCdecl cdecl]] ( [[KeyPgByval byval]] //count// [[KeyPgAs as]] [[KeyPgInteger integer]] ) [[KeyPgAs as]] [[KeyPgAny any]] [[KeyPgPtr ptr]]
##
{{fbdoc item="usage"}}##
	//result// = **Allocate**( //count// )
##
{{fbdoc item="param"}}
	##//count//##
		La taille, en octets du bloc de m&eacute;moire &agrave; allouer.

{{fbdoc item="section" value="Valeur retourn&eacute;e
	En cas de succ&egrave;s, l'adresse du d&eacute;but de la m&eacute;moire allou&eacute;e est retourn&eacute;e. Sinon, si la taille demand&eacute;e du bloc ne peut &ecirc;tre attribu&eacute;e ou si ##//count// < 0##, alors le pointeur (##0##) est retourn&eacute;.

{{fbdoc item="desc"}}
	Tente d'attribuer, ou de r&eacute;server, ##//count//## octets &agrave; partir de la m&eacute;moire libre (heap = tas). La valeur initiale de la m&eacute;moire nouvellement allou&eacute;e n'est pas sp&eacute;cifi&eacute;e. Le pointeur retourn&eacute; est un [[KeyPgAny Any]] [[KeyPgPtr Ptr]] et pointe sur le d&eacute;but de la m&eacute;moire allou&eacute;e. Ce pointeur est garanti comme &eacute;tant unique, m&ecirc;me si ##//count//## est z&eacute;ro.

	La m&eacute;moire occup&eacute;e doit &ecirc;tre lib&eacute;r&eacute;e, ou retourner au "tas"" libre, avec ##[[KeyPgDeallocate Deallocate]]## quand elle n'est plus utlis&eacute;e. 

	{{fbdoc item="ex"}}

	%%(freebasic)

'' This program uses the ALLOCATE(...) function to create a buffer of 15 integers that is
'' then filled with the first 15 numbers of the Fibonacci Sequence, then output to the
'' screen. Note the call to DEALLOCATE(...) at the end of the program.
Const integerCount As Integer = 15
'' Try allocating memory for a number of integers.

	''

	Dim buffer As Integer Ptr
	buffer = Allocate(integerCount * SizeOf(Integer))
	If (0 = buffer) Then
	Print "Error: unable to allocate memory, quitting."

	End -1
		End If
		'' Prime and fill the memory with the fibonacci sequence.
	''

	buffer[0] = 0
	buffer[1] = 1
	For i As Integer = 2 To integerCount - 1
	buffer[i] = buffer[i - 1] + buffer[i - 2]
	Next
		'' Display the sequence.
	''

	For i As Integer = 0 To integerCount - 1
	Print buffer[i] ;
	Next
		Deallocate(buffer)
	End 0

	%%
	Affichage:
<table class="fb_box">## 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377##;</table><div style="clear:both"> 
	Il est important de lib&eacute;rer la m&eacute;moire allou&eacute;e si elle ne sera plus utilis&eacute;e. La m&eacute;moire non utilis&eacute;e non-lib&eacute;r&eacute;e est simplement une perte de m&eacute;moire, et si son adresse est d'une certaine fa&ccedil;on &eacute;cras&eacute;e ou oubli&eacute;e, cette m&eacute;moire ne pourra jamais &ecirc;tre lib&eacute;r&eacute;e. Ceci est une perte de m&eacute;moire et doit &ecirc;tre &eacute;vit&eacute; &agrave; tout prix. Notez que la m&eacute;moire perdue est toujours enti&egrave;rement lib&eacute;r&eacute;e lorsque l'application se termine, soit par une sortie "ordinaire" ou un "crash", donc la fuite "persiste" tant que l'application s'ex&eacute;cute; malgr&eacute; tout c'est une bonne habitude de lib&eacute;rer toute la m&eacute;moire allou&eacute;e &agrave; l'int&eacute;rieur de votre application . L'exemple suivant montre une fonction avec une fuite de m&eacute;moire, o&ugrave; l'adresse de m&eacute;moire allou&eacute;e est perdue et n'est pas et ne peut pas &ecirc;tre lib&eacute;r&eacute;e. Si une telle fonction est appel&eacute;e souvent, le montant total de la m&eacute;moire perdue peut augmenter rapidement.
	%%(freebasic)
	'' Bad example of Allocate usage, causing memory leaks

	Sub BadAllocateExample()

Dim p As Byte Ptr
p = Allocate(420)   '' assign pointer to new memory

p = Allocate(420)   '' reassign same pointer to different memory,

	'' old address is lost and that memory is leaked

	Deallocate(p)

	End Sub
	                    '' Main

	BadAllocateExample() '' Creates a memory leak 

Print "Memory leak!"

	BadAllocateExample() '' ... and another
	Print "Memory leak!"
	End
	%%
	;</table>
	{{fbdoc item="target"}}
- Cette proc&eacute;dure n'est pas garantie d'&ecirc;tre "thread-safe".

{{fbdoc item="lang"}}
	- Non disponible dans le dialecte //[[CompilerOptlang -lang qb]]// sauf si r&eacute;f&eacute;renc&eacute; avec l'alias ##**__Allocate**## 

{{fbdoc item="diff"}}
	- Nouveau pour FreeBASIC

{{fbdoc item="see"}}
	- ##[[KeyPgCallocate CAllocate]]##

- ##[[KeyPgReallocate Reallocate]]##
	- ##[[KeyPgDeallocate Deallocate]]##
	- ##[[KeyPgReallocate Reallocate]]##
	- ##[[KeyPgDeallocate Deallocate]]##

{{fbdoc item="back" value="CatPgMemory|Memory Functions"}}