{{fbdoc item="title" value="MUTEXCREATE"}}----
Cr&eacute;e un "mutex" utilis&eacute; pour synchroniser l'ex&eacute;cution des "threads"

{{fbdoc item="syntax"}}##
	[[KeyPgDeclare declare]] [[KeyPgFunction function]] **Mutexcreate** ( ) [[KeyPgAs as]] [[KeyPgAny any]] [[KeyPgPtr ptr]]
##
{{fbdoc item="usage"}}##
	//result// = **Mutexcreate**
##
{{fbdoc item="section" value="Valeur retourn&eacute;e
	Le ##[[KeyPgAny Any]] [[KeyPgPtr Ptr]]## "handle" du "mutex" cr&eacute;&eacute;, ou le pointeur nul (0) en cas d'&eacute;chec.

{{fbdoc item="desc"}}
	Les "Mutex", abr&eacute;viation de "Mutually Exclusive" (Mutuellement exclusive), sont un moyen de synchroniser les donn&eacute;es partag&eacute;es dans les "threads".  S'il y a une variable globale utilis&eacute;e par plusieurs "threads" (ou une variable locale utilis&eacute;e par un "thread" unique, appel&eacute;e plusieurs fois), elle devrait &ecirc;tre "verrouill&eacute;e" lors de son utilisation avec un "mutex".  Ceci arr&ecirc;te tous les "threads" en utilisant ##[[KeyPgMutexLock MutexLock]]## avec ce "mutex", jusqu'&agrave; ce qu'il soit d&eacute;verrouill&eacute; avec ##[[KeyPgMutexUnlock MutexUnlock]]##.

	##Mutexcreate## cr&eacute;e un "mutex", et retourne un "handle" qui sert de r&eacute;f&eacute;rence lors du verrouillage, du d&eacute;verrouillage ou de la destruction du "mutex".  Les "mutex" cr&eacute;&eacute;s avec ##Mutexcreate## doivent &ecirc;tre d&eacute;truits lorsqu'ils ne sont plus n&eacute;cessaires ou avant la fin du programme avec ##[[KeyPgMutexDestroy MutexDestroy]]##.
	
	Un "mutex" est un verrou qui garantit trois choses:
	1. Atomicit&eacute; - Le verrouillage d'un "mutex" est une op&eacute;ration atomique, ce qui signifie que le syst&egrave;me d'exploitation (ou la biblioth&egrave;que "threads") vous assure que si vous avez verrouill&eacute; un "mutex", aucun autre "thread" r&eacute;ussira &agrave; verrouiller ce "mutex" en m&ecirc;me temps.
	2. Singularit&eacute; - Si un "thread" a r&eacute;ussi &agrave; verrouiller un "mutex", il est assur&eacute; qu'aucun autre "thread" ne sera en mesure de bloquer le "thread" jusqu'&agrave; ce que le "thread" d'origine ne lib&egrave;re le verrou.
	3. Attente non-occup&eacute;e - Si un "thread" tente de verrouiller un "thread" qui a &eacute;t&eacute; verrouill&eacute; par un second "thread", le premier "thread" sera suspendu (et ne consommera aucune ressource CPU) jusqu'&agrave; ce que le verrou soit lib&eacute;r&eacute; par le second "thread". A ce moment-l&agrave;, le premier "thread" va se r&eacute;veiller et poursuivre l'ex&eacute;cution, apr&egrave;s avoir lui-m&ecirc;me verrouill&eacute; le "mutex". 

{{fbdoc item="ex"}}
	%%(freebasic)

'' Threading syncronyzation using Mutexes
	'' If you comment out the lines containing "MutexLock" and "MutexUnlock",

'' the threads will not be in sync and some of the data may be printed
	'' out of place.
	Const MAX_THREADS = 10

Declare Sub thread( ByVal id_ptr As Any Ptr )
	Declare Sub teletype (ByVal text As String, ByVal x As Integer, ByVal y As Integer)

Dim Shared threadsync As Any Ptr
	Dim i As Integer
	Dim handleTb(0 To MAX_THREADS-1) As Any Ptr
	'' Create a mutex to syncronize the threads
	threadsync = MutexCreate
	'' Create threads

For i = 0 To MAX_THREADS-1