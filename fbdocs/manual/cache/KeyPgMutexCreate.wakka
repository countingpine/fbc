{{fbdoc item="title" value="MUTEXCREATE"}}----
Crée un "mutex" utilisé pour synchroniser l'exécution des "threads"

{{fbdoc item="syntax"}}##
	[[KeyPgDeclare declare]] [[KeyPgFunction function]] **Mutexcreate** ( ) [[KeyPgAs as]] [[KeyPgAny any]] [[KeyPgPtr ptr]]
##
{{fbdoc item="usage"}}##
	//result// = **Mutexcreate**
##
{{fbdoc item="ret"}}
	Le ##[[KeyPgAny any]] [[KeyPgPtr ptr]]## "handle" du "mutex" créé, ou le pointeur nul (0) en cas d'échec.

{{fbdoc item="desc"}}
	Les "Mutex", abréviation de "Mutually Exclusive" (Mutuellement exclusive), sont un moyen de synchroniser les données partagées dans les "threads".  S'il y a une variable globale utilisée par plusieurs "threads" (ou une variable locale utilisée par un "thread" unique, appelée plusieurs fois), elle devrait être "verrouillée" lors de son utilisation avec un "mutex".  Ceci arrête tous les "threads" en utilisant ##[[KeyPgMutexLock Mutexlock]]## avec ce "mutex", jusqu'à ce qu'il soit déverrouillé avec ##[[KeyPgMutexUnlock Mutexunlock]]##.

	##Mutexcreate## crée un "mutex", et retourne un "handle" qui sert de référence lors du verrouillage, du déverrouillage ou de la destruction du "mutex".  Les "mutex" créés avec ##Mutexcreate## doivent être détruits lorsqu'ils ne sont plus nécessaires ou avant la fin du programme avec ##[[KeyPgMutexDestroy Mutexdestroy]]##.
	
	Un "mutex" est un verrou qui garantit trois choses:
	1. Atomicité - Le verrouillage d'un "mutex" est une opération atomique, ce qui signifie que le système d'exploitation (ou la bibliothèque "threads") vous assure que si vous avez verrouillé un "mutex", aucun autre "thread" réussira à verrouiller ce "mutex" en même temps.
	2. Singularité - Si un "thread" a réussi à verrouiller un "mutex", il est assuré qu'aucun autre "thread" ne sera en mesure de bloquer le "thread" jusqu'à ce que le "thread" d'origine ne libère le verrou.
	3. Attente non-occupée - Si un "thread" tente de verrouiller un "thread" qui a été verrouillé par un second "thread", le premier "thread" sera suspendu (et ne consommera aucune ressource CPU) jusqu'à ce que le verrou soit libéré par le second "thread". A ce moment-là, le premier "thread" va se réveiller et poursuivre l'exécution, après avoir lui-même verrouillé le "mutex".

{{fbdoc item="ex"}}
{{fbdoc item="filename" value="examples/manual/threads/mutexcreate.bas"}}%%(freebasic)
'' Threading syncronyzation using Mutexes
'' If you comment out the lines containing "MutexLock" and "MutexUnlock",
'' the threads will not be in sync and some of the data may be printed
'' out of place.

const MAX_THREADS = 10

DECLARE SUB thread( byval id_ptr as any ptr )
DECLARE SUB teletype (BYVAL text AS STRING, BYVAL x AS INTEGER, BYVAL y AS INTEGER)

DIM SHARED threadsync AS any ptr

dim i as integer

DIM handleTb(0 to MAX_THREADS-1) AS any ptr

'' Create a mutex to syncronize the threads
threadsync = MUTEXCREATE

'' Create threads
for i = 0 to MAX_THREADS-1
	handleTb(i) = THREADCREATE(@thread, @i)
	IF handleTb(i) = 0 THEN
		PRINT "Error creating thread:"; i
		exit for
	END IF
next

'' Wait until all threads are finished
for i = 0 to MAX_THREADS-1
	if( handleTb(i) <> 0 ) then
		THREADWAIT( handleTb(i) )
	end if
next

teletype "Testing.................", 1, 1
teletype "Testing again...........", 10, 1

'' Discard the mutex when we are through using teletype
MUTEXDESTROY threadsync

SUB thread( byval id_ptr as any ptr )
	dim id as integer
	id = *cast( integer ptr, id_ptr )
	teletype "Thread (" & id & ").........", 1, 1+id
END SUB

'' Teletype unfurls some text across the screen at a given location
SUB teletype (BYVAL text AS STRING, BYVAL x AS INTEGER, BYVAL y AS INTEGER)
	DIM i AS INTEGER

	FOR i = 0 TO LEN(text)-1
	    '' MutexLock prevents the two simultaneously running
	    '' threads from sharing "x", "y", and "a"
	    MUTEXLOCK threadsync

	    LOCATE y, x+i
	    PRINT CHR(text[i])

	    '' MutexUnlock releases these variables for other use
	    MUTEXUNLOCK threadsync

	    SLEEP 25
   NEXT
END SUB
%%

{{fbdoc item="lang"}}
	- Les "Thread" n'existent pas dans le dialecte //[[CompilerOptlang -lang qb]]//.

{{fbdoc item="target"}}
	- La version DOS de ""FreeBASIC"" ne permet pas les "threads", car l'OS ne les supporte pas.
	- Dans Linux les "threads" sont toujours démarrés dans l'ordre de leur création, ceci n'est pas possible sous ""Win32"". Il s'agit de l'OS, pas une question ""FreeBASIC"".

{{fbdoc item="diff"}}
	- Nouveau pour ""FreeBASIC""

{{fbdoc item="see"}}
	- ##[[KeyPgMutexDestroy Mutexdestroy]]##
	- ##[[KeyPgMutexLock Mutexlock]]##
	- ##[[KeyPgMutexUnlock Mutexunlock]]##
	- ##[[KeyPgThreadCreate Threadcreate]]##
	- ##[[KeyPgThreadWait Threadwait]]##

{{fbdoc item="back" value="CatPgThreading|Threading Support Functions"}}

