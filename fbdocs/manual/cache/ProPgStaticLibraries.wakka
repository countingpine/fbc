{{fbdoc item="title" value="Biblioth&egrave;ques statiques"}}----
Une bibliothèque statique est du code compilé qui peut être utilisé plus tard lors de la construction d'un exécutable.

Lorsque le compilateur génère un exécutable, les fichiers sources de base sont d'abord transformés en fichiers objets.  Les fichiers objets sont ensuite liés ensemble pour créer un exécutable.  Lorsque nous compilons le code source, nous ne le faisons pas nécessairement pour créer un exécutable.  Nous pouvons plutôt grouper tous les fichiers objets (fabriqués à partir des sources) en un fichier unique appelé une bibliothèque statique.

La bibliothèque est appelée statique, parce que lorsque les fichiers objets qu'elle contient sont ensuite liés dans un fichier exécutable, une copie de tout le code nécessaire de la bibliothèque est ajouté à l'exécutable.

Une fois que la bibliothèque est générée, Une fois que la bibliothèque est générée, nous pouvons alors utiliser le code qu'elle contient comme si nous avions compilé les sources directement avec notre programme.

Voici un exemple simple créant une bibliothèque statique en utilisant ces trois fichiers:
	- ##mylib.bas## - le source de la bibliothèque
	- ##mylib.bi## - l'en-tête pour la bibliothèque
	- ##mytest.bas## - un programme de test

Notre bibliothèque sera un module unique assurant une fonction unique:

{{fbdoc item="filename" value="examples/manual/proguide/static-lib/mylib.bas"}}%%(freebasic)
'' mylib.bas
'' compiler avec: fbc -lib mylib.bas

'' Additionne deux nombres ensemble et retourne le résultat
Public Function Add2( ByVal x As Integer, ByVal y As Integer ) As Integer
  Return( x + y )
End Function
%%
Compiler la bibliothèque avec:
	##fbc -lib mylib.bas##

L'option //[[CompilerOptlib -lib]]// indique au compilateur de prendre le code source, ##mylib.bas##, et de le transformer en un fichier objet ##mylib.o##, puis de stocker le fichier objet dans un fichier bibliothèque, aussi appelé une archive, ##libmylib.a##.  Une bibliothèque peut contenir de nombreux modules (fichiers source), chacun avec de nombreuses fonctions, mais pour cet exemple simple, il n'y en a simplement qu'un seul.

Pour faire usage de la bibliothèque dans un autre code source , nous avons besoin d'une certaine façon de dire au compilateur ce qui est exactement dans la bibliothèque.  Une bonne façon pour y parvenir est de mettre les déclarations (également appelée une interface ou API) de la bibliothèque dans un fichier d'en-tête.

{{fbdoc item="filename" value="examples/manual/proguide/static-lib/mylib.bi"}}%%(freebasic)
'' mylib.bi
#inclib "mylib"
Declare Function Add2( ByVal x As Integer, ByVal y As Integer ) As Integer
%%
Il n'est pas nécessaire de compiler l'en-tête.  Nous le voulons dans sa forme source, comme cela il peut être inclus avec les autres fichiers source.  L'instruction  ##[[KeyPgInclib #inclib]]## dira au compilateur le nom de la bibliothèque statique que nous voulons lier lorsque, éventuellement, nous désirerons générer un exécutable.

Grâce à notre bibliothèque (un fichier .a) et un fichier d'en-tête (.bi file) nous pouvons les essayer dans un programme de test:

{{fbdoc item="filename" value="examples/manual/proguide/static-lib/mytest.bas"}}%%(freebasic)
'' mytest.bas
'' compiler avec: fbc mytest.bas
#include once "mylib.bi"
Print Add2(1,2)
%%
L'instruction ##[[KeyPgInclude #include]]## indique au compilateur d'inclure le code source de ##mylib.bi## comme si nous l'avions tapé dans le source original.  Avec la manière dont nous avons écrit notre fichier d'inclusion, il indique au compilateur tout ce qu'il doit savoir sur la bibliothèque.

Nous compilons ceci avec:
	##fbc mytest.bas##

Puis, quand nous lancerons l'exécutable ##mytest##, nous devrions obtenir ce résultat:
	##3##

Plus d'un module source peut être utilisé lors de la fabrication de la bibliothèque.  Et les programmes de base peuvent utiliser plus d'une bibliothèque en incluant les fichiers d'en-tête nécessaires.  Certaines bibliothèques sont si importantes qu'elles peuvent utiliser plusieurs en-têtes.  Pour de très grands projets, la création de bibliothèques avec certains modules de code qui ne changent que rarement peut améliorer considérablement les temps de compilation.

Les bibliothèques peuvent éventuellement contenir des informations de débogage spécifiées avec l'option de ligne de commande //[[CompilerOptg -g]]//.

Les fichiers objets, et donc les bibliothèques, sont dépendants de la plate-forme et dans certains cas dépendants d'une version particulière du compilateur et de la bibliothèque d'exécution FreeBASIC.

{{fbdoc item="see"}}
	- [[ProPgSharedLibraries Bibliothèques partagées]]
	- ##[[KeyPgInclib #inclib]]##
	- ##[[KeyPgInclude #include]]##
	- [[CompilerOptlib Option du compilateur: -lib]]

{{fbdoc item="back" value="CatPgProgrammer|Programmer's Guide"}}

