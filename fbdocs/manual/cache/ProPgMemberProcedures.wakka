{{fbdoc item="title" value="Membres des proc&eacute;dures"}}----
Procédures avec un accès complet aux membres d'un ##[[KeyPgType Type]]## ou d'une ##[[KeyPgClass Class]]##.

**{{anchor name="DECL|Déclaration et définition"}}**
	Déclarer et définir des membres de procédures.
**{{anchor name="USAGE|Usage"}}**
	Appel de membre de procédure.
**{{anchor name="THIS|Le paramètre caché, This"}}**
	Accès implicite à l'instance avec laquelle un membre de procédure non statique est appelé.
**{{anchor name="ACCESS|Les droits d'accès"}}**
	Faire référence à d'autres membres dans les membres de procédures.
**{{anchor name="OVERLOAD|Surcharge"}}**
	Déclarer deux ou plusieurs membres de procédures portant le même nom.
**{{anchor name="STATIC|Membres statiques de procédures"}}**
	Les différences avec les membres non-statiques de procédures.

~&//Le terme 'membre de procédure' fait référence aussi bien aux membres statiques que non-statiques des procédures, sauf indication contraire.//

{{anchor name="DECL"}}{{fbdoc item="section" value="Déclaration et définition"}}
	Les membres de procédures sont déclarés tout comme les procédures au niveau normal du module sauf qu'ils sont déclarés à l'intérieur, et définis à l'extérieur, d'une définition de ##[[KeyPgType Type]]## ou de ##[[KeyPgClass Class]]## //(voir note *)//.

	Lors de la définition d'un membre de procédure, the procedure name is prefixed with the name of the ##[[KeyPgType Type]]## or ##[[KeyPgClass Class]]## and the member access operator (##[[KeyPgOpMemberAccess Operator . (Accès Membre)]]##). It is an error to define a member procedure without a matching declaration in the ##[[KeyPgType Type]]## or ##[[KeyPgClass Class]]## definition.

	L'exemple suivant déclare et définit une procédure avec des membres ##[[KeyPgSub Sub]]## et ##[[KeyPgFunction Function]]##:

	{{fbdoc item="filename" value="examples/manual/proguide/members/foo1.bi"}}%%(freebasic)
'' foo1.bi

Type foo
	Declare Sub f (As Integer)
	Declare Function g As Integer

	i As Integer
End Type

Sub foo.f (n As Integer)
	Print n
End Sub

Function foo.g As Integer
	Return 420
End Function
%%

	* //À l'avenir, les membres de procédures pourraient être en mesure d'être définis dans la définition de ##[[KeyPgType Type]]## ou ##[[KeyPgClass Class]]##.//

{{anchor name="USAGE"}}{{fbdoc item="usage"}}
	Les membres de procédures sont mentionnées à l'instar des données membres, c'est-à-dire que leur nom est préfixé par le nom d'une instance de l'objet et l'opérateur d'accès membre (##[[KeyPgOpMemberAccess Operator . (Accès Membre)]]##) //(voir note *)//.

	L'exemple suivant, utilisant le code de l'exemple précédent, appelle des membres de procédure ##[[KeyPgSub Sub]]## et ##[[KeyPgFunction Function]]##:

	{{fbdoc item="filename" value="examples/manual/proguide/members/usage1.bas"}}%%(freebasic)
'' ... foo with non-static members as before ...
#include once "foo1.bi"

Dim bar As foo
bar.f(bar.g())
%%

	* //Les membres statiques de procédures ne nécessitent pas une instance d'objet afin d'être appelés.//

{{anchor name="THIS"}}	{{fbdoc item="section" value="Le paramètre caché, This"}}
	Les membres de procédures ont effectivement un paramètre supplémentaire ceux qui sont déclarés avec *. Quand ils sont appelés, en utilisant le nom d'une instance et ##[[KeyPgOpMemberAccess Operator . (Accès Membre)]]##, une référence de cette instance est passée avec d'autres arguments dans l'appel, permettant aux membres de la procédure un accès direct à l'instance.

	Le paramètre supplémentaire ajouté par le compilateur est appelé ##[[KeyPgThis This]]##, et puisque c'est une référence, toutes modifications apportées à ##[[KeyPgThis This]]## sont effectivement des modifications de l'instance qui a été passée au membre de la procédure quand il a été appelé. Vous pouvez utiliser ##[[KeyPgThis This]]## exactement comme une autre variable, à savoir, le passer à des procédures d'un objet du même type, appeler d'autres membres de procédures et accéder à un membre données en utilisant ##[[KeyPgOpMemberAccess Operator . (Accès Membre)]]##, etc.

	La plupart du temps, toutefois, utiliser ##[[KeyPgThis This]]## explicitement, est inutile; un membre de procédure peut se référer à d'autres membres de l'instance à laquelle il est passé directement par nom, sans avoir à le qualifier avec ##[[KeyPgThis This]]## et ##[[KeyPgOpMemberAccess Operator . (Accès Membre)]]##. Les seuls moments où vous devez qualifier le nom des membres avec ##[[KeyPgThis This]]## est lorsque le nom du membre est caché, par exemple, par un paramètre ou une variable locale. Dans ces situations, qualifier le nom du membre est le seul moyen de se référer à ces noms de membres cachés.

	L'exemple suivant utilise le mot-clé ##[[KeyPgThis This]]## pour se référer à un membre de données dont le nom est caché par par un paramètre et une variable locale:

	{{fbdoc item="filename" value="examples/manual/proguide/members/this.bas"}}%%(freebasic)
Type foo
	Declare Sub f (i As Integer)
	Declare Sub g ()

	i As Integer = 420
End Type

Sub foo.f (i As Integer)
	'' A parameter hides T.i, so it needs to be qualified to be used:
	Print this.i
End Sub

Sub foo.g ()
	'' A local variable hides T.i, so it needs to be qualified to be used:
	Dim i As Integer
	Print this.i
End Sub
%%
	
	* //Les membres statiques de procédures n'ont pas ce paramètre supplémentaire ajouté par le compilateur et ne peuvent donc pas accéder à l'instance objet à partir de laquelle ils ont été appelés.//

{{anchor name="ACCESS"}}{{fbdoc item="section" value="Les droits d'accès"}}
	Contrairement aux procédures normales de niveau module, les membres de procédures ont des droits d'accès complets aux membres du ##[[KeyPgType Type]]## ou de la ##[[KeyPgClass Class]]## où ils ont été déclarés; ils peuvent se référer aux membres publics, protégés et privés d'un ##[[KeyPgType Type]]## ou d'une ##[[KeyPgClass Class]]##.

{{anchor name="OVERLOAD"}}{{fbdoc item="section" value="Surcharge"}}
	Un membre de procédure peut être déclaré en ayant le même nom qu'un autre membre d'une procédure, à condition que les paramètres soient différents, que ce soit en nombre ou en type. C'est ce qu'on appelle la surcharge.

	Seuls les paramètres sont utilisés pour déterminer si une déclaration de procédure est une surcharge valide. Par exemple, un ##[[KeyPgType Type]]## ou une ##[[KeyPgClass Class]]## pourraient comporter des membres statiques et non-statiques de procédures ayant le même nom, ou des membres ##[[KeyPgSub Sub]]## et ##[[KeyPgFunction Function]]## de procédures avec le même nom.

	Contrairement à une procédure de niveau module, qui a besoin de spécifier la clause ##[[KeyPgOverload Overload]]## dans sa déclaration pour lui permettre d'être surchargée, un membre de procédure est surchargeable par défaut et n'a pas besoin de la clause ##[[KeyPgOverload Overload]]##.

	{{fbdoc item="filename" value="examples/manual/proguide/members/overload.bas"}}%%(freebasic)
Type T
	Declare Sub f
	
	'' Different number of parameters:
	Declare Sub f (As Integer)
	
	'' Different type of parameters:
	Declare Sub f (ByRef As String)
	
	'' Again, parameters are different:
	Declare Function f (As UByte) As Integer
	
	'' following three members would cause an error,
	'' number of parameters and/or types do not differ:

	'' Declare Function f As Integer
	'' Declare Function f (As UByte) As String
	'' Declare Static Function f (As UByte) As Integer

	'' ...
	somedata as any ptr
End Type
%%

{{anchor name="STATIC"}}{{fbdoc item="section" value="Membres statiques de procédures"}}
	Les membres statiques de procédures sont déclarés et définis de la même manière que les membres de procédures non-statiques, avec avec le mot-clé ##[[KeyPgStatic Static]]## précédant la déclaration et la définition.

	Les membres de procédures définis en utilisant le mot-clef ##[[KeyPgStatic Static]]## doivent être déclarés avec le mot-clef ##[[KeyPgStatic Static]]## dans la définition d'un [[KeyPgType Type]] ou d'une [[KeyPgClass Class]] ou le compilateur émettra un message d'erreur. Comme les membres non-statiques de procédures, c'est une erreur de définir un membre statique de procédure sans une déclaration correspondant à la définition de [[KeyPgType Type]] ou [[KeyPgClass Class]].
	
	Ne pas confondre ceci avec les définitions de procédure qui précisent le stockage statique pour leurs variables et des objets en ajoutant le mot-clé ##[[KeyPgStatic Static]]## à l'en-tete de la procédure. Le mot-clé ##[[KeyPgStatic Static]]## peut, néanmoins, être utilisé dans les deux contextes; les membres de procedures statiques peuvent être définis avec un stockage statique de variable et d'objet.

	L'exemple suivant déclare deux membres de procédure statiques, dont le premier a également un stockage statique de variable et d'objet. Notez que le mot-clé ##[[KeyPgStatic Static]]## est facultatif dans la définition du membre de la procédure:

	{{fbdoc item="filename" value="examples/manual/proguide/members/foo2.bi"}}%%(freebasic)
'' foo2.bi

Type foo
	Declare Static Sub f (As Integer)
	Declare Static Function g As Integer

	i As Integer
End Type

Static Sub foo.f (n As Integer) Static
	Print n
End Sub
	
Function foo.g As Integer
	Return 420
End Function
%%

	Les membres de procédure statiques peuvent être appelés comme des membres de procédure non-statiques, en qualifiant le nom de la procédure avec le nom d'une instance et l'opérateur d'accès aux membres de procédures (##[[KeyPgOpMemberAccess Operator . (Accès Membre)]]##).

	Ils peuvent aussi être appelés en qualifiant le nom de la procédure avec le nom du ##[[KeyPgType Type]]## ou de la ##[[KeyPgClass Class]]## où ils ont été déclarés et l'opérateur d'accès aux membres de procédures (##[[KeyPgOpMemberAccess Operator . (Accès Membre)]]##). En d'autres mots, une instance n'est pas nécessaire pour appeler des membres de procédures statiques.

	L'exemple suivant, utilise le code de l'exemple précédent et aussi les deux moyens d'appeler un membre de procédure statique:
	
	{{fbdoc item="filename" value="examples/manual/proguide/members/usage2.bas"}}%%(freebasic)
'' ... foo with static members as before ...
#include once "foo2.bi"

Dim bar As foo
bar.f(foo.g())
%%

	Contrairement aux membres de procédures non-statiques qui sont déclarés avec un paramètre supplémentaire ##[[KeyPgThis This]]##, les membres de procédure statiques n'ont pas besoin du passage d'une instance pour être appelés. Pour cette raison, les membres de procédures statiques peuvent seulement faire référence à des constantes, des énumérations d'autres membres statiques (données ou procédures), etc., sans qualifier leurs noms. Les membres de procédures statiques peuvent toujours se référer à des membres de procédures non-statiques quand ils sont qualifiés avec une instance, par exemple: un paramètre ou une variable locale.

	L'exemple suivant fait référence à un membre de procédure non-statique à partir d'une procédure statique:

	{{fbdoc item="filename" value="examples/manual/proguide/members/static.bas"}}%%(freebasic)
Type foo
	Declare Static Sub f (ByRef As foo)

	i As Integer
End Type

Sub foo.f (ByRef self As foo)
	'' Ok, self is an instance of foo:
	Print self.i

	'' would cause error
	'' cannot access non-static members, no foo instance:
	'' Print i
End Sub
%%

{{fbdoc item="back" value="CatPgProgrammer|Programmer's Guide"}}

