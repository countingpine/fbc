{{fbdoc item="title" value="Member Procedures"}}----
Proc&eacute;dures avec un acc&egrave;s complet aux membres d'un ##[[KeyPgType Type]]## ou d'une ##[[KeyPgClass Class]]##.

**[[#DECL">D&eacute;claration et d&eacute;finition]]**
	D&eacute;clarer et d&eacute;finir des membres de proc&eacute;dures.
**[[#USAGE">Usage]]**
	Appel de membre de proc&eacute;dure.
**[[#THIS">Le param&egrave;tre cach&eacute;, This]]**
	Acc&egrave;s implicite &agrave; l'instance avec laquelle un membre de proc&eacute;dure non statique est appel&eacute;.
**[[#ACCESS">Les droits d'acc&egrave;s]]**
	Faire r&eacute;f&eacute;rence &agrave; d'autres membres dans les membres de proc&eacute;dures.
**[[#OVERLOAD">Surcharge]]**
	D&eacute;clarer deux ou plusieurs membres de proc&eacute;dures portant le m&ecirc;me nom.
**[[#STATIC">Membres statiques de proc&eacute;dures]]**
	Les diff&eacute;rences avec les membres non-statiques de proc&eacute;dures.

//Le terme 'membre de proc&eacute;dure' fait r&eacute;f&eacute;rence aussi bien aux membres statiques que non-statiques des proc&eacute;dures, sauf indication contraire.//

<a name="DECL"></a>{{fbdoc item="section" value="D&eacute;claration et d&eacute;finition
	Les membres de proc&eacute;dures sont d&eacute;clar&eacute;s tout comme les proc&eacute;dures au niveau normal du module sauf qu'ils sont d&eacute;clar&eacute;s &agrave; l'int&eacute;rieur, et d&eacute;finis &agrave; l'ext&eacute;rieur, d'une d&eacute;finition de ##[[KeyPgType Type]]## ou de ##[[KeyPgClass Class]]## //(voir note *)//.

	Lors de la d&eacute;finition d'un membre de proc&eacute;dure, the procedure name is prefixed with the name of the ##[[KeyPgType Type]]## or ##[[KeyPgClass Class]]## and the member access operator (##[[KeyPgOpMemberAccess Operator . (Acc&egrave;s Membre)]]##). It is an error to define a member procedure without a matching declaration in the ##[[KeyPgType Type]]## or ##[[KeyPgClass Class]]## definition.

	L'exemple suivant d&eacute;clare et d&eacute;finit une proc&eacute;dure avec des membres ##[[KeyPgSub Sub]]## et ##[[KeyPgFunction Function]]##:

	%%(freebasic)
'' foo1.bi

Type foo
	Declare Sub f (As Integer)
	Declare Function g As Integer

	i As Integer
End Type

Sub foo.f (n As Integer)
	Print n
End Sub

Function foo.g As Integer
	Return 420
End Function
%%

	* //&Agrave; l'avenir, les membres de proc&eacute;dures pourraient &ecirc;tre en mesure d'&ecirc;tre d&eacute;finis dans la d&eacute;finition de ##[[KeyPgType Type]]## ou ##[[KeyPgClass Class]]##.//

<a name="USAGE"></a>
	{{fbdoc item="usage"}}

	Les membres de proc&eacute;dures sont mentionn&eacute;es &agrave; l'instar des donn&eacute;es membres, c'est-&agrave;-dire que leur nom est pr&eacute;fix&eacute; par le nom d'une instance de l'objet et l'op&eacute;rateur d'acc&egrave;s membre (##[[KeyPgOpMemberAccess Operator . (Acc&egrave;s Membre)]]##) //(voir note *)//.

	L'exemple suivant, utilisant le code de l'exemple pr&eacute;c&eacute;dent, appelle des membres de proc&eacute;dure ##[[KeyPgSub Sub]]## et ##[[KeyPgFunction Function]]##:
'' ... foo with non-static members as before ...
'' ... foo with non-static members as before ...

#include once "foo1.bi"
Dim bar As foo
bar.f(bar.g())

	%%

* //Les membres statiques de proc&eacute;dures ne n&eacute;cessitent pas une instance d'objet afin d'&ecirc;tre appel&eacute;s.//
	<a name="THIS"></a>

	{{fbdoc item="section" value="Le param&egrave;tre cach&eacute;, This

	Les membres de proc&eacute;dures ont effectivement un param&egrave;tre suppl&eacute;mentaire ceux qui sont d&eacute;clar&eacute;s avec *. Quand ils sont appel&eacute;s, en utilisant le nom d'une instance et ##[[KeyPgOpMemberAccess Operator . (Acc&egrave;s Membre)]]##, une r&eacute;f&eacute;rence de cette instance est pass&eacute;e avec d'autres arguments dans l'appel, permettant aux membres de la proc&eacute;dure un acc&egrave;s direct &agrave; l'instance.

	Le param&egrave;tre suppl&eacute;mentaire ajout&eacute; par le compilateur est appel&eacute; ##[[KeyPgThis This]]##, et puisque c'est une r&eacute;f&eacute;rence, toutes modifications apport&eacute;es &agrave; ##[[KeyPgThis This]]## sont effectivement des modifications de l'instance qui a &eacute;t&eacute; pass&eacute;e au membre de la proc&eacute;dure quand il a &eacute;t&eacute; appel&eacute;. Vous pouvez utiliser ##[[KeyPgThis This]]## exactement comme une autre variable, &agrave; savoir, le passer &agrave; des proc&eacute;dures d'un objet du m&ecirc;me type, appeler d'autres membres de proc&eacute;dures et acc&eacute;der &agrave; un membre donn&eacute;es en utilisant ##[[KeyPgOpMemberAccess Operator . (Acc&egrave;s Membre)]]##, etc.

	La plupart du temps, toutefois, utiliser ##[[KeyPgThis This]]## explicitement, est inutile; un membre de proc&eacute;dure peut se r&eacute;f&eacute;rer &agrave; d'autres membres de l'instance &agrave; laquelle il est pass&eacute; directement par nom, sans avoir &agrave; le qualifier avec ##[[KeyPgThis This]]## et ##[[KeyPgOpMemberAccess Operator . (Acc&egrave;s Membre)]]##. Les seuls moments o&ugrave; vous devez qualifier le nom des membres avec ##[[KeyPgThis This]]## est lorsque le nom du membre est cach&eacute;, par exemple, par un param&egrave;tre ou une variable locale. Dans ces situations, qualifier le nom du membre est le seul moyen de se r&eacute;f&eacute;rer &agrave; ces noms de membres cach&eacute;s.
L'exemple suivant utilise le mot-cl&eacute; ##[[KeyPgThis This]]## pour se r&eacute;f&eacute;rer &agrave; un membre de donn&eacute;es dont le nom est cach&eacute; par par un param&egrave;tre et une variable locale:
	%%(freebasic)
	Type foo

	Declare Sub f (i As Integer)
Declare Sub g ()

i As Integer = 420
	End Type
	Sub foo.f (i As Integer)
'' A parameter hides T.i, so it needs to be qualified to be used:

Print this.i
	End Sub
	Sub foo.g ()
	'' A local variable hides T.i, so it needs to be qualified to be used:
Dim i As Integer
Print this.i
	
	End Sub

%%
	* //Les membres statiques de proc&eacute;dures n'ont pas ce param&egrave;tre suppl&eacute;mentaire ajout&eacute; par le compilateur et ne peuvent donc pas acc&eacute;der &agrave; l'instance objet &agrave; partir de laquelle ils ont &eacute;t&eacute; appel&eacute;s.//

<a name="ACCESS"></a>
	{{fbdoc item="section" value="Les droits d'acc&egrave;s

	Contrairement aux proc&eacute;dures normales de niveau module, les membres de proc&eacute;dures ont des droits d'acc&egrave;s complets aux membres du ##[[KeyPgType Type]]## ou de la ##[[KeyPgClass Class]]## o&ugrave; ils ont &eacute;t&eacute; d&eacute;clar&eacute;s; ils peuvent se r&eacute;f&eacute;rer aux membres publics, prot&eacute;g&eacute;s et priv&eacute;s d'un ##[[KeyPgType Type]]## ou d'une ##[[KeyPgClass Class]]##.

	<a name="OVERLOAD"></a>

	{{fbdoc item="section" value="Surcharge
Un membre de proc&eacute;dure peut &ecirc;tre d&eacute;clar&eacute; en ayant le m&ecirc;me nom qu'un autre membre d'une proc&eacute;dure, &agrave; condition que les param&egrave;tres soient diff&eacute;rents, que ce soit en nombre ou en type. C'est ce qu'on appelle la surcharge.
	Seuls les param&egrave;tres sont utilis&eacute;s pour d&eacute;terminer si une d&eacute;claration de proc&eacute;dure est une surcharge valide. Par exemple, un ##[[KeyPgType Type]]## ou une ##[[KeyPgClass Class]]## pourraient comporter des membres statiques et non-statiques de proc&eacute;dures ayant le m&ecirc;me nom, ou des membres ##[[KeyPgSub Sub]]## et ##[[KeyPgFunction Function]]## de proc&eacute;dures avec le m&ecirc;me nom.
	
	Contrairement &agrave; une proc&eacute;dure de niveau module, qui a besoin de sp&eacute;cifier la clause ##[[KeyPgOverload Overload]]## dans sa d&eacute;claration pour lui permettre d'&ecirc;tre surcharg&eacute;e, un membre de proc&eacute;dure est surchargeable par d&eacute;faut et n'a pas besoin de la clause ##[[KeyPgOverload Overload]]##.
	%%(freebasic)
	
	Type T
	Declare Sub f
	
	'' Different number of parameters:
	Declare Sub f (As Integer)
	
	'' Different type of parameters:
	Declare Sub f (ByRef As String)

	'' Again, parameters are different:
	Declare Function f (As UByte) As Integer
	'' following three members would cause an error,

	'' number of parameters and/or types do not differ:
	'' Declare Function f As Integer
'' Declare Function f (As UByte) As String
'' Declare Static Function f (As UByte) As Integer

'' ...
	somedata As Any Ptr

	End Type
	
	%%

	<a name="STATIC"></a>

	{{fbdoc item="section" value="Membres statiques de proc&eacute;dures
Les membres statiques de proc&eacute;dures sont d&eacute;clar&eacute;s et d&eacute;finis de la m&ecirc;me mani&egrave;re que les membres de proc&eacute;dures non-statiques, avec avec le mot-cl&eacute; ##[[KeyPgStatic Static]]## pr&eacute;c&eacute;dant la d&eacute;claration et la d&eacute;finition.

Les membres de proc&eacute;dures d&eacute;finis en utilisant le mot-clef ##[[KeyPgStatic Static]]## doivent &ecirc;tre d&eacute;clar&eacute;s avec le mot-clef ##[[KeyPgStatic Static]]## dans la d&eacute;finition d'un [[KeyPgType Type]] ou d'une [[KeyPgClass Class]] ou le compilateur &eacute;mettra un message d'erreur. Comme les membres non-statiques de proc&eacute;dures, c'est une erreur de d&eacute;finir un membre statique de proc&eacute;dure sans une d&eacute;claration correspondant &agrave; la d&eacute;finition de [[KeyPgType Type]] ou [[KeyPgClass Class]].
	Ne pas confondre ceci avec les d&eacute;finitions de proc&eacute;dure qui pr&eacute;cisent le stockage statique pour leurs variables et des objets en ajoutant le mot-cl&eacute; ##[[KeyPgStatic Static]]## &agrave; l'en-tete de la proc&eacute;dure. Le mot-cl&eacute; ##[[KeyPgStatic Static]]## peut, n&eacute;anmoins, &ecirc;tre utilis&eacute; dans les deux contextes; les membres de procedures statiques peuvent &ecirc;tre d&eacute;finis avec un stockage statique de variable et d'objet.
	L'exemple suivant d&eacute;clare deux membres de proc&eacute;dure statiques, dont le premier a &eacute;galement un stockage statique de variable et d'objet. Notez que le mot-cl&eacute; ##[[KeyPgStatic Static]]## est facultatif dans la d&eacute;finition du membre de la proc&eacute;dure:

	%%(freebasic)
'' foo2.bi

Type foo
	Declare Static Sub f (As Integer)
Declare Static Function g As Integer
	
i As Integer
	End Type
Static Sub foo.f (n As Integer) Static
Print n

	End Sub

	Function foo.g As Integer

	Return 420
	
	End Function
%%
Les membres de proc&eacute;dure statiques peuvent &ecirc;tre appel&eacute;s comme des membres de proc&eacute;dure non-statiques, en qualifiant le nom de la proc&eacute;dure avec le nom d'une instance et l'op&eacute;rateur d'acc&egrave;s aux membres de proc&eacute;dures (##[[KeyPgOpMemberAccess Operator . (Acc&egrave;s Membre)]]##).

Ils peuvent aussi &ecirc;tre appel&eacute;s en qualifiant le nom de la proc&eacute;dure avec le nom du ##[[KeyPgType Type]]## ou de la ##[[KeyPgClass Class]]## o&ugrave; ils ont &eacute;t&eacute; d&eacute;clar&eacute;s et l'op&eacute;rateur d'acc&egrave;s aux membres de proc&eacute;dures (##[[KeyPgOpMemberAccess Operator . (Acc&egrave;s Membre)]]##). En d'autres mots, une instance n'est pas n&eacute;cessaire pour appeler des membres de proc&eacute;dures statiques.
L'exemple suivant, utilise le code de l'exemple pr&eacute;c&eacute;dent et aussi les deux moyens d'appeler un membre de proc&eacute;dure statique:
%%

	'' ... foo with static members as before ...

	#include once "foo2.bi"

	Dim bar As foo
bar.f(foo.g())
	%%

	Contrairement aux membres de proc&eacute;dures non-statiques qui sont d&eacute;clar&eacute;s avec un param&egrave;tre suppl&eacute;mentaire ##[[KeyPgThis This]]##, les membres de proc&eacute;dure statiques n'ont pas besoin du passage d'une instance pour &ecirc;tre appel&eacute;s. Pour cette raison, les membres de proc&eacute;dures statiques peuvent seulement faire r&eacute;f&eacute;rence &agrave; des constantes, des &eacute;num&eacute;rations d'autres membres statiques (donn&eacute;es ou proc&eacute;dures), etc., sans qualifier leurs noms. Les membres de proc&eacute;dures statiques peuvent toujours se r&eacute;f&eacute;rer &agrave; des membres de proc&eacute;dures non-statiques quand ils sont qualifi&eacute;s avec une instance, par exemple: un param&egrave;tre ou une variable locale.
L'exemple suivant fait r&eacute;f&eacute;rence &agrave; un membre de proc&eacute;dure non-statique &agrave; partir d'une proc&eacute;dure statique:

Sub foo.f (ByRef self As foo)
	Type foo
	Declare Static Sub f (ByRef As foo)

	i As Integer
	End Type
	Sub foo.f (ByRef self As foo)
'' Ok, self is an instance of foo:
Print self.i

'' would cause error