{{fbdoc item="title" value="CONST (Qualifier)"}}----
Indique que le type de donn&eacute;es ou un pointeur de type de donn&eacute;es est en lecture seule.

{{fbdoc item="syntax"}}##
	... [[KeyPgAs as]] [**Const**] //[[DataType datatype]]// [ [**Const**] [[KeyPgPtr ptr]] ... ]
##
{{fbdoc item="param"}}
	##//datatype//##
		Nom d'un type de donn&eacute;es standard ou d'un type de donn&eacute;es d&eacute;fini par l'utilisateur.

{{fbdoc item="desc"}}
	Indique que le ##//datatype (= type de donn&eacute;es)//## ou ##[[KeyPgPtr Ptr]]## imm&eacute;diatement &agrave; la droite du qualificateur ##**Const**## doit &ecirc;tre consid&eacute;r&eacute; comme &eacute;tant en lecture seule.  Les d&eacute;clarations en lecture seule (##**Const**##) sont une mesure de s&eacute;curit&eacute; de type qui peut &ecirc;tre comprise comme "//promesse de ne pas changer//".  Le compilateur utilise les d&eacute;clarations ##**Const**## pour v&eacute;rifier les op&eacute;rations sur les variables et param&egrave;tres et g&eacute;n&eacute;rer une erreur lors de la compilation si leurs donn&eacute;es pourraient changer.  Il n'y a pas d'annulation d'ex&eacute;cution pour l'utilisation du qualificateur ##**Const**## puisque tous les contr&ocirc;les sont effectu&eacute;s au moment de la compilation.

	##**Const**## peut &ecirc;tre utilis&eacute; partout o&ugrave; des d&eacute;clarations de type de donn&eacute;es sont pr&eacute;sentes.  Cela inclut les variables, les param&egrave;tres, les r&eacute;sultats de retour de fonction, des champs de type d&eacute;fini par l'utilisateur, alias de type et ##//casting//##.  Le ##//datatype (= type de donn&eacute;es)//## peut &ecirc;tre n'importe quel type int&eacute;gr&eacute; de donn&eacute;es standard ou de type d&eacute;fini par l'utilisateur.

	Les variables en lecture seule doivent avoir un initialisateur sinon la modification d'une variable en lecture seule par le biais d'une allocation g&eacute;n&eacute;rera une erreur de compilation.  L'initialisation peut appara&icirc;tre apr&egrave;s la d&eacute;claration de la variable.

	Des variables ##**Const**## et non-##**Const**## peuvent &ecirc;tre transmises &agrave; une proc&eacute;dure qui attend un param&egrave;tre ##**Const**##.  Toutefois, une variable ##**Const**## ne peut pas &ecirc;tre pass&eacute;e &agrave; une proc&eacute;dure exigeant un param&egrave;tre non-##**Const**##, cela g&eacute;n&eacute;rera une erreur de compilation.

	Les proc&eacute;dures peuvent &ecirc;tre surcharg&eacute;es sur la base ##**Const**## des param&egrave;tres.  Par exemple, une proc&eacute;dure peut &ecirc;tre surcharg&eacute;e, une version de la proc&eacute;dure ayant un param&egrave;tre '##//foo byref as bar//##' et l'autre version de la proc&eacute;dure ayant un param&egrave;tre '##//foo bar byref as const//##'.

	Avec une d&eacute;claration de pointeur, ##**Const**## peut &ecirc;tre utilis&eacute; pour indiquer quelle partie de la d&eacute;claration de pointeur est en lecture seule (toutes les autres parties sont par d&eacute;faut en lecture-&eacute;criture).  L'&eacute;l&eacute;ment en lecture seule du type de pointeur de donn&eacute;es peut &ecirc;tre le pointeur lui-m&ecirc;me (l'adresse), ce que le pointeur pointe (les donn&eacute;es), ou les deux.  Dans une d&eacute;claration avec plus d'un niveau d'indirection de ##[[KeyPgPtr Ptr]]##, le ##[[KeyPgPtr Ptr]]## le plus &agrave; droite indique le niveau le plus &eacute;lev&eacute; d'indirection et est donc d&eacute;r&eacute;f&eacute;renc&eacute; en premier.

	Le compilateur a une limite '##//hard//##' interne de huit (8) niveaux d'indirection pointeur en ce qui concerne les qualificateurs ##**Const**## et le comportement de ##**Const**## avec l'utilisation des types de donn&eacute;es ##[[KeyPgPtr Ptr]]## ayant plus de huit (8) niveaux d'indirection est ind&eacute;fini.

{{fbdoc item="ex"}}
{{fbdoc item="filename" value="examples/manual/datatype/const-var.bas"}}%%(freebasic)
'' Const Variables

'' procedure taking a const parameter
sub proc1( byref x as const integer )

  '' can't change x because it is const
  '' x = 10 '' compile error

  '' but we can use it in expressions and
  '' assign it to other variables
  dim y as integer
  y = x
  y = y * x + x

end sub

'' procedure taking a non-const parameter
sub proc2( byref x as integer )
  '' we can change the value
  x = 10
end sub

'' declare a non-const and const variable
dim a as integer
dim b as const integer = 5

'' proc1() will accept a non-const or const
'' argument because proc1() promises not to
'' change the variable passed to it.
proc1( a )
proc1( b )

'' proc2() will accept a non-const argument
proc2( a )

'' but not a const argument because proc2()
'' might change the variable's data and we
'' promised that 'b' would not change.
'' proc2( b ) '' compile error
%%

{{fbdoc item="filename" value="examples/manual/datatype/const-ptr.bas"}}%%(freebasic)
'' Const Pointers

'' an integer
dim x as integer = 1
dim y as integer = 2
dim z as integer = 3

'' To check that the compiler generates errors
'' when attempting to reassign const variables,
'' uncomment the assignments below.

''
scope
  '' a pointer to an integer
  dim p as integer ptr = @x

  p = @y       /' OK - pointer can be changed '/
  *p = z       /' OK - data can be changed '/

end scope

''
scope
  '' a pointer to a constant integer
  dim p as const integer ptr = @x

  p = @y       /' OK - pointer can be changed '/
  '' *p = z    /' Error - data is const '/

end scope

''
scope
  '' a constant pointer to an integer
  dim p as integer const ptr = @x

  '' p = @y    /' Error - pointer is const '/
  *p = z       /' OK - data can be changed '/

end scope

''
scope
  '' a constant pointer to a constant integer
  dim p as const integer const ptr = @x

  '' p = @y    /' Error - pointer is const '/
  '' *p = z    /' Error - data is const '/

end scope
%%

{{fbdoc item="filename" value="examples/manual/datatype/const-ovl.bas"}}%%(freebasic)
'' Const Parameters in an Overloaded Procedure

'' procedure with non-const parameter
sub foo overload( byref n as integer )
  print "called 'foo( byref n as integer )'"
end sub

'' procedure with const parameter
sub foo overload( byref n as const integer )
  print "called 'foo( byref n as const integer )'"
end sub

dim x as integer = 1
dim y as const integer = 2

foo( x )
foo( y )

'' OUTPUT:
'' called 'foo( byref n as integer )'
'' called 'foo( byref n as const integer )'
%%
{{fbdoc item="diff"}}
	- Nouveau pour FreeBASIC

{{fbdoc item="see"}}
	- ##[[KeyPgConst Const]]##
	- ##[[KeyPgConstMember Const (Member)]]##
	- ##[[KeyPgDim Dim]]##
	- ##[[KeyPgType Type]]##

{{fbdoc item="back" value="CatPgStdDataTypes|Standard Data Types"}}