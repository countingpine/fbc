{{fbdoc item="title" value="CONST (Qualifier)"}}----
Indique que le type de données ou un pointeur de type de données est en lecture seule.

{{fbdoc item="syntax"}}##
	... [[KeyPgAs as]] [**Const**] //[[DataType datatype]]// [ [**Const**] [[KeyPgPtr ptr]] ... ]
##
{{fbdoc item="param"}}
	##//datatype//##
		Nom d'un type de données standard ou d'un type de données défini par l'utilisateur.

{{fbdoc item="desc"}}
	Indique que le ##//datatype (= type de données)//## ou ##[[KeyPgPtr ptr]]## immédiatement à la droite du qualificateur ##**Const**## doit être considéré comme étant en lecture seule.  Les déclarations en lecture seule (##**Const**##) sont une mesure de sécurité de type qui peut être comprise comme "//promesse de ne pas changer//".  Le compilateur utilise les déclarations ##**Const**## pour vérifier les opérations sur les variables et paramètres et générer une erreur lors de la compilation si leurs données pourraient changer.  Il n'y a pas d'annulation d'exécution pour l'utilisation du qualificateur ##**Const**## puisque tous les contrôles sont effectués au moment de la compilation.

	##**Const**## peut être utilisé partout où des déclarations de type de données sont présentes.  Cela inclut les variables, les paramètres, les résultats de retour de fonction, des champs de type défini par l'utilisateur, alias de type et ##//casting//##.  Le ##//datatype (= type de données)//## peut être n'importe quel type intégré de données standard ou de type défini par l'utilisateur.

	Les variables en lecture seule doivent avoir un initialisateur sinon la modification d'une variable en lecture seule par le biais d'une allocation générera une erreur de compilation.  L'initialisation peut apparaître après la déclaration de la variable.

	Des variables ##**Const**## et non-##**Const**## peuvent être transmises à une procédure qui attend un paramètre ##**Const**##.  Toutefois, une variable ##**Const**## ne peut pas être passée à une procédure exigeant un paramètre non-##**Const**##, cela générera une erreur de compilation.

	Les procédures peuvent être surchargées sur la base ##**Const**## des paramètres.  Par exemple, une procédure peut être surchargée, une version de la procédure ayant un paramètre '##//foo byref as bar//##' et l'autre version de la procédure ayant un paramètre '##//foo bar byref as const//##'.

	Avec une déclaration de pointeur, ##**Const**## peut être utilisé pour indiquer quelle partie de la déclaration de pointeur est en lecture seule (toutes les autres parties sont par défaut en lecture-écriture).  L'élément en lecture seule du type de pointeur de données peut être le pointeur lui-même (l'adresse), ce que le pointeur pointe (les données), ou les deux.  Dans une déclaration avec plus d'un niveau d'indirection de ##[[KeyPgPtr Ptr]]##, le ##[[KeyPgPtr Ptr]]## le plus à droite indique le niveau le plus élevé d'indirection et est donc déréférencé en premier.

	Le compilateur a une limite '##//hard//##' interne de huit (8) niveaux d'indirection pointeur en ce qui concerne les qualificateurs ##**Const**## et le comportement de ##**Const**## avec l'utilisation des types de données ##[[KeyPgPtr Ptr]]## ayant plus de huit (8) niveaux d'indirection est indéfini.

{{fbdoc item="ex"}}
{{fbdoc item="filename" value="examples/manual/datatype/const-var.bas"}}%%(freebasic)
'' Const Variables

'' procedure taking a const parameter
sub proc1( byref x as const integer )

  '' can't change x because it is const
  '' x = 10 '' compile error

  '' but we can use it in expressions and
  '' assign it to other variables
  dim y as integer
  y = x
  y = y * x + x

end sub

'' procedure taking a non-const parameter
sub proc2( byref x as integer )
  '' we can change the value
  x = 10
end sub

'' declare a non-const and const variable
dim a as integer
dim b as const integer = 5

'' proc1() will accept a non-const or const
'' argument because proc1() promises not to
'' change the variable passed to it.
proc1( a )
proc1( b )

'' proc2() will accept a non-const argument
proc2( a )

'' but not a const argument because proc2()
'' might change the variable's data and we
'' promised that 'b' would not change.
'' proc2( b ) '' compile error
%%

{{fbdoc item="filename" value="examples/manual/datatype/const-ptr.bas"}}%%(freebasic)
'' Const Pointers

'' an integer
dim x as integer = 1
dim y as integer = 2
dim z as integer = 3

'' To check that the compiler generates errors
'' when attempting to reassign const variables,
'' uncomment the assignments below.

''
scope
  '' a pointer to an integer
  dim p as integer ptr = @x

  p = @y       /' OK - pointer can be changed '/
  *p = z       /' OK - data can be changed '/

end scope

''
scope
  '' a pointer to a constant integer
  dim p as const integer ptr = @x

  p = @y       /' OK - pointer can be changed '/
  '' *p = z    /' Error - data is const '/

end scope

''
scope
  '' a constant pointer to an integer
  dim p as integer const ptr = @x

  '' p = @y    /' Error - pointer is const '/
  *p = z       /' OK - data can be changed '/

end scope

''
scope
  '' a constant pointer to a constant integer
  dim p as const integer const ptr = @x

  '' p = @y    /' Error - pointer is const '/
  '' *p = z    /' Error - data is const '/

end scope
%%

{{fbdoc item="filename" value="examples/manual/datatype/const-ovl.bas"}}%%(freebasic)
'' Const Parameters in an Overloaded Procedure

'' procedure with non-const parameter
sub foo overload( byref n as integer )
  print "called 'foo( byref n as integer )'"
end sub

'' procedure with const parameter
sub foo overload( byref n as const integer )
  print "called 'foo( byref n as const integer )'"
end sub

dim x as integer = 1
dim y as const integer = 2

foo( x )
foo( y )

'' OUTPUT:
'' called 'foo( byref n as integer )'
'' called 'foo( byref n as const integer )'
%%
{{fbdoc item="diff"}}
	- Nouveau pour ""FreeBASIC""

{{fbdoc item="see"}}
	- ##[[KeyPgConst Const]]##
	- ##[[KeyPgConstMember Const (Member)]]##
	- ##[[KeyPgDim Dim]]##
	- ##[[KeyPgType Type]]##

{{fbdoc item="back" value="CatPgStdDataTypes|Standard Data Types"}}