{{fbdoc item="title" value="Constructeurs et destructeurs"}}----
En charge de la création et la destruction d'objets.

**{{anchor name="OVERVIEW|Vue d'ensemble"}}**
**{{anchor name="DECLARATION|Déclaration"}}**
**{{anchor name="DEFCTOR|Les constructeurs par défaut"}}**
**{{anchor name="COPYCTOR|Constructeurs de copie"}}**
**{{anchor name="CALLCTOR|Appel des constructeurs"}}**

{{anchor name="OVERVIEW"}}{{fbdoc item="section" value="Vue d'ensemble"}}
	Les constructeurs et les destructeurs sont responsables, respectivement, de la création et de la destruction d'objets. En général, les constructeurs donnent aux objets leur état initial, c'est à dire qu'ils donnent des valeurs significatives aux données membres de leurs objets. Les destructeurs accomplissent la fonction inverse; ils s'assurent que les ressources qui appartiennent aux objets sont correctement libérées.

	Simplement, les constructeurs sont des membres spéciaux des procédures qui sont appelés lorsqu'un objet est créé et les destructeurs sont des membres spéciaux des procédures qui sont appelés lorsqu'un objet est détruit. Les constructeurs et destructeurs sont appelés automatiquement par le compilateur chaque fois qu'un objet est créé ou détruit, ou détruit explicitement lors de l'utilisation des mots-clés ##[[KeyPgDim Dim]]## ou ##[[KeyPgOpNew New]]## ou ou implicitement par le passage d'un objet par valeur à une procédure ou via un objet sortant du champ d'application.

{{anchor name="DECLARATION"}}{{fbdoc item="section" value="Déclaration"}}
	Les constructeurs et les destructeurs sont déclarés comme membres de procédures, mais avec les mots-clefs ##[[KeyPgConstructor Constructor]]## ou ##[[KeyPgDestructor Destructor]]## à la place de ##[[KeyPgMemberSub Sub]]## ou ##[[KeyPgMemberFunction Function]]## et sans nom. De même, ils sont définis avec seulement le nom du ##[[KeyPgType Type]]## ou de la ##[[KeyPgClass Class]]## dans le(la)quel(le) ils sont déclarés.

	Un ##[[KeyPgType Type]]## ou une ##[[KeyPgClass Class]]## peuvent avoir plusieurs constructeurs, mais seulement un destructeur.

{{anchor name="DEFCTOR"}}{{fbdoc item="section" value="Les constructeurs par défaut"}}
	Les constructeurs par défaut sont des constructeurs qui soit n'ont pas de paramètres, soit la totalité de leurs paramètres ont une valeur par défaut. Ils sont appelés quand un objet est défini, mais pas initialisé, ou créés dans le cadre d'un tableau, avec les mots-clefs ##[[KeyPgDim Dim]]##, ##[[KeyPgRedim Redim]]## ou ##[[KeyPgOpNew New]]##[]. Le premier constructeur déclaré dans l'exemple ci-dessous est un constructeur par défaut.

{{anchor name="COPYCTOR"}}{{fbdoc item="section" value="Constructeurs de copie"}}
	Les constructeurs de copie sont des constructeurs appelés quand un objet est créé, ou cloné, à partir d'un autre objet du même type (ou d'un objet qui peut être converti dans ce type). Cela se produit explicitement lors de l'initialisation d'un objet avec un autre objet ou implicitement en passant par valeur un objet à une procédure. Les constructeurs de copie sont déclarés comme ayant un paramètre: un objet du même type passé par référence.

	Les constructeurs de copie ne sont appelés que lors de la création et l'initialisation d'instances d'objets. L'affectation à des objets est assurée par ##[[KeyPgOperator member operator let]]##.

{{anchor name="CALLCTOR"}}{{fbdoc item="section" value="Appel des constructeurs"}}
	Contrairement aux autres membres des procédures, les constructeurs ne peuvent pas être appelés directement à partir d'une instance d'objet. Au lieu de cela, un constructeur est précisé dans une instruction ##[[KeyPgDim Dim]]## avec un initialiseur ou sans ou dans une instruction ##[[KeyPgOpNew New]]## avec ou sans arguments.

	Lorsque vous spécifiez un initialiseur pour un objet, le nom du type suivi par tous les arguments qu'il exige est utilisé.

{{fbdoc item="filename" value="examples/manual/proguide/udt/ctordtor.bas"}}%%(freebasic)
type foo
	'' Declare a default ctor, copy ctor and normal ctor
	declare constructor
	declare constructor (byref as foo)
	declare constructor (as integer)

	'' Declare a destructor
	declare destructor

	ints as integer ptr
	numints as integer
end type

'' Define a constructor that creates 100 integers
constructor foo
	ints = new integer(100)
	numints = 100
end constructor

'' Define a constructor that copies the integers from another object
constructor foo (byref x as foo)
	ints = new integer(x.numints)
	numints = x.numints
end constructor

'' Define a constructor that creates some integers based on a parameter
constructor foo (n as integer)
	ints = new integer(n)
	numints = n
end constructor

'' Define a destructor that destroys those integers
destructor foo
	delete[] ints
end destructor

scope
	'' calls foo's default ctor
	dim a as foo
	dim x as foo ptr = new foo

	'' calls foo's copy ctor
	dim b as foo = a
	dim y as foo ptr = new foo(*x)

	'' calls foo's normal ctor
	dim c as foo = foo(20)
	dim z as foo ptr = new foo(20)

	'' calls foo's dtor
	delete x
	delete y
	delete z
end scope '' <- a, b and c are destroyed here as well
%%

{{anchor name="COMPCTORDTOR"}}{{fbdoc item="section" value="Constructeurs et destructeurs fournis par le compilateur"}}
	Si aucun constructeur de copie n'est déclaré pour un ##[[KeyPgType Type]]## ou une ##[[KeyPgClass Class]]##, le compilateur en fournit un. Si aucun constructeur n'a été déclaré, le compilateur en fournit également un par défaut.

	Le constructeur par défaut fourni par le compilateur initialise les données des membres à des valeurs par défaut, c'est à dire, que les membres numériques et pointeurs sont mis à zéro (0) et les membres object sont construits par défaut. Le constructeur de copie déclaré par le compilateur fait des copies rapides de toutes les données membres d'un type à un autre: les types numériques et pointeur sont initialisés avec les membres de données correspondant à l'objet qui est copié, et les membres objet sont construits à partir de la copie de leurs membres objet correspondants. Cela signifie que les ressources dynamiques, telle que la mémoire pointée par un membre de données pointeur, ne sont pas copiées; seule l'adresse est copiée. Donc, si un objet possède une ressource, cela signifie qu'il est responsable de sa création et de sa destruction, le constructeur de copie généré par le compilateur ne sera pas suffisant.

	Si un destructeur n'est pas déclaré, le compilateur en génère un. Ce destructeur appelle les destructeurs des membres de l'objet et ne fait rien pour les types numériques et pointeurs. Encore une fois, si un objet possède une ressource dynamique, alors le destructeur généré par le compilateur ne sera pas suffisant, car la ressource ne sera pas libérée lorsque l'objet sera détruit.

	Ceci est communément appelé la "règle des 3": Si un objet a besoin d'un constructeur de copie personnalisé, opérateur d'affectation ou destructeur, il y a des chances qu'il ait besoin des trois.

{{fbdoc item="back" value="CatPgProgrammer|Programmer's Guide"}}

